---
title: "Quick Template: Mediation with Observed Variables"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    options:
      toc:
        depth: 2
      number_sections: true
vignette: >
  %\VignetteIndexEntry{Quick Template: Mediation with Observed Variables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
csl: apa.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = ""
)
```

# Introduction

This and other "Quick Template" vignettes
are examples of R code to test do power
analysis or determine sample size in
typical models using
[power4mome](https://sfcheung.github.io/power4mome/).
Users can quickly adapt
them for their scenarios.

# Prerequisite

Basic knowledge about fitting models
by `lavaan` and `power4mome` is required.
This file is not intended to be an introduction
on how to use functions in `power4mome`.

# Scope

This file has code examples for various
mediation models.

# Estimate the Power for a Sample Size

An example to estimate power given
other factors.

The code:

```{r med_simple, eval=TRUE, results="hide", message=FALSE}
library(power4mome)
#
# ====== Model: Form ======
model <-
"
m ~ x
y ~ m + x
"
#
# ====== Model: Population Values ======
# l: large (.50 by default)
# m: medium (.30 by default)
# s: small (.10 by default)
model_es <-
"
m ~ x: s
y ~ m: l
y ~ x: m
"
#
# ====== Test the Model Specification ======
out <- power4test(nrep = 2,
                  model = model,
                  pop_es = model_es,
                  n = 50000,
                  iseed = 1234)
#
# ====== Check the Data Generated ======
print(out,
      data_long = TRUE)
#
# ====== Estimate the Power ======
# For n = 100,
# when testing the indirect effect by
# Monte Carlo confidence interval
out <- power4test(nrep = 400,
                  model = model,
                  pop_es = model_es,
                  n = 100,
                  R = 1000,
                  ci_type = "mc",
                  test_fun = test_indirect_effect,
                  test_args = list(x = "x",
                                   m = "m",
                                   y = "y",
                                   mc_ci = TRUE),
                  iseed = 1234,
                  parallel = TRUE)
#
# ====== Compute the Rejection Rate ======
rejection_rates(out)
```

The results:

```{r med_simple_out}
print(out,
      data_long = TRUE)
rejection_rates(out)
```

# Try Another Sample Size

The code:

```{r med_simple_new_n, eval=TRUE, results="hide", message=FALSE}
#
# ===== Reuse the output of power4test() =====
# Estimate power for n = 150
# Set n to 150
out_new_n <- power4test(out,
                        n = 150)
#
# ===== Compute Rejection Rate (Power) =====
rejection_rates(out_new_n)
```

The results:

```{r med_simple_new_n_out}
rejection_rates(out_new_n)
```

# Try Several Sample Sizes

The code:

```{r med_simple_ns, eval=TRUE, results="hide", message=FALSE}
#
# ===== Reuse the output of power4test() =====
# Estimate power for n = 200, 250, 300
# Use power4test_by_n()
out_ns <- power4test_by_n(out,
                          n = c(200, 250, 300),
                          by_seed = 5789)
#
# ===== Compute Rejection Rate (Power) =====
rejection_rates(out_ns)
```

The results:

```{r med_simple_ns_out}
rejection_rates(out_ns)
```

# Find the Sample Size With Power Approximately .80

## Use the Output of `power4test()`

Suppose we do this step right after calling `power4test()`
on one sample size.

It can take some time to run if estimated power
of the sample size is too different from
the target power.

The code:

```{r med_simple_n_from, eval=TRUE, results="hide", message=FALSE, fig.keep="none"}
#
# ===== Reuse the output of power4test() =====
# Call x_from_power()
# To set desired precision:
# - Set final number of R: final_R = 1000 (Default, can be omitted)
# - Set final number of replications: final_nrep = 400 (Default, can be omitted)
n_power_80 <- x_from_power(out,
                           x = "n",
                           seed = 1357)
#
# ===== Print the Summary =====
summary(n_power_80)
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80)
```

The results:

```{r med_simple_n_from_out}
#
# ===== Print the Summary =====
summary(n_power_80)
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80)
```

## Use the Output of `power4test_by_n()`

We already tried several other sample
sizes using `power4test_by_n()`. We
can also continue the search using its output
by calling `x_from_power()` on its
output.

It can take some time to run if estimated levels
of power
of the sample sizes are too different from
the target power.

The code:

```{r med_simple_n_from_by, eval=TRUE, results="hide", message=FALSE, fig.keep="none"}
#
# ===== Reuse the output of power4test_by_n() =====
# Call x_from_power()
# To set desired precision:
# - Set final number of R: final_R = 1000 (Default, can be omitted)
# - Set final number of replications: final_nrep = 400 (Default, can be omitted)
n_power_80_ns <- x_from_power(out_ns,
                              x = "n",
                              seed = 1357)
#
# ===== Print the Summary =====
summary(n_power_80_ns)
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80_ns)
```

The results:

```{r med_simple_n_from_by_out}
#
# ===== Print the Summary =====
summary(n_power_80_ns)
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80_ns)
```

# Final Remarks

For details on how to use `power4test()`,
`power4test_by_n()`, and `x_from_power()`,
please refer to the [Get-Started article](https://sfcheung.github.io/power4mome/articles/power4mome.html),
and the [article](https://sfcheung.github.io/power4mome/articles/power4mome.html)
on finding the sample size
given desired power using `x_from_power()`,
as well as the help pages of these
functions.
