---
title: "Quick Function: Serial Mediation with Latent Variables"
date: "`r Sys.Date()`"
output:
  html_document:
    fig.align: "center"
    toc: true
    toc_depth: 2
    number_sections: false
bibliography: references.bib
csl: apa.csl
---

```{r knitr_setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "",
  fig.align = "center"
)
```

```{r load_pre, child=c("template_q_med_ins_preamble.txt")}
```

# Scope

This file is for serial mediation models,
and only use one function `q_power_mediation_serial()`
from the package
[power4mome](https://sfcheung.github.io/power4mome/).

```{r}
library(power4mome)
```

# The Model

Suppose this is the model:

```{r template_q_med_lav_serial_model, echo = FALSE, fig.cap = "The Model"}
library(semPlot)
library(semptools)
suppressMessages(library(lavaan))
mod <-
"
m1 ~ l*x
m2 ~ l*m1 + x
y ~ m*m2 + m1 + s*x
x =~ x1 + x2 + x3
m1 =~ m11 + m12 + m13 + m14
m2 =~ m21 + m22 + m23
y =~ y1 + y2 + y3
"
fit0 <- sem(mod, do.fit = FALSE, fixed.x = FALSE)
set.seed(1234)
onames <- lavNames(fit0)
p <- length(onames)
dat <- data.frame(MASS::mvrnorm(100, rep(0, p), diag(p)))
colnames(dat) <- onames
fit0 <- sem(mod, dat, do.fit = FALSE)
layout_m <- matrix(c(NA, "m1", NA, "m2",  NA,
                     "x", NA,  NA,  NA,  "y"), 2, 5, byrow = TRUE)
p <- semPaths(fit0,
              whatLabels = "label",
              nCharNodes = 0,
              exoCov = FALSE,
              edge.label.cex = .85 * 1.5,
              label.cex = 1,
              residuals = FALSE,
              sizeMan = 8,
              sizeMan2 = 4,
              sizeLat = 10,
              sizeLat2 = 9,
              asize = 3,
              DoNotPlot = TRUE)
p2 <- set_sem_layout(
          p,
          factor_layout = layout_m,
          factor_point_to = c(x = "left",
                              m1 = "left",
                              m2 = "right",
                              y = "right"),
          indicator_push = c(m1 = 3,
                             m2 = 3,
                             x = 2,
                             y = 2)
        )
p2$graphAttributes$Edges$labels[1:6] <-
  c("a",
    "b1",
    "bx2",
    "b2",
    "b1y",
    "c'")
p2$graphAttributes$Edges$width[1:6] <-
  c("a" = 4,
    "b1" = 4,
    "bx2" = 1,
    "b2" = 4,
    "b1y" = 1,
    "c'" = 2)
p2$graphAttributes$Edges$lty[1:6] <-
  c("a" = 1,
    "b1" = 1,
    "bx2" = 2,
    "b2" = 1,
    "b1y" = 2,
    "c'" = 1)
# p2$graphAttributes$Edges$labels[1:5] <-
#   c("l\n(large:\n.50)",
#     "l\n(large:\n.50)",
#     "l\n(large:\n.50)",
#     "m\n(medium:\n.30)",
#     "s\n(small:\n.10)")
p2 <- p2 |> set_curve(c("y ~ m1" = 0))
plot(p2)
text(label = "Serial Mediation Model",
     x = 0, y = -1,
     cex = 1.25)
```

This is a serial mediation model, but
the model is on the latent variables,
each with some indicators.

We want to do power analysis for the
indirect effect along the path
`x->m1->m2->y`.
Suppose these are the expected
effects:

- `x->m1`: medium

- `m1->m2`: medium

- `m2->y`: large

- `x->y`: small

The other paths involving
the mediators, `x->m2` and `m1->y`, are
assumed to have no effect (`nil`).

```{r load_convention, child=c("template_q_med_ins_convention.txt")}
```

```{r load_cov, child=c("template_q_med_ins_covariates.txt")}
```

## Model with Hypothesized Path Coefficients


This is the model with the effect sizes:

```{r template_q_med_lav_serial_model_es, echo = FALSE, fig.cap = "The Model"}
library(semPlot)
suppressMessages(library(lavaan))
mod <-
"
m1 ~ l*x
m2 ~ m*m1 + x
y ~ s*m2 + m1 + s*x
"
fit0 <- sem(mod, do.fit = FALSE, fixed.x = FALSE)
set.seed(1234)
dat <- data.frame(MASS::mvrnorm(100, rep(0, 5), diag(5)))
colnames(dat) <- lavNames(fit0)
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c(NA, "m1", "m2", NA,
                     "x", NA,   NA, "y"), 2, 4, byrow = TRUE)
p <- semPaths(fit0,
              whatLabels = "label",
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              edge.label.cex = 1.25,
              label.cex = 1.5,
              residuals = FALSE,
              sizeMan = 8,
              asize = 5,
              DoNotPlot = TRUE)
p$graphAttributes$Edges$labels <-
  c("a" = "l\n(large:\n.50)",
    "b1" = "m\n(medium:\n.30)",
    "bx2" = "nil\n(0)",
    "b2" = "s\n(small:\n.10)",
    "b1y" = "nil\n(0)",
    "c'" = "s\n(small:\n.10)")
# p$graphAttributes$Edges$labels <-
#   c("l\n(large:\n.50)",
#     "l\n(large:\n.50)",
#     "l\n(large:\n.50)",
#     "m\n(medium:\n.30)",
#     "s\n(small:\n.10)")
p$graphAttributes$Edges$width <-
  c("a" = 4,
    "b1" = 4,
    "bx2" = 1,
    "b2" = 4,
    "b1y" = 1,
    "c'" = 2)
p$graphAttributes$Edges$lty <-
  c("a" = 1,
    "b1" = 1,
    "bx2" = 2,
    "b2" = 1,
    "b1y" = 2,
    "c'" = 1)
p$graphAttributes$Nodes$shape[] <- "circle"
plot(p)
text(label = "Serial Mediation Model",
     x = 0, y = -1.4,
     cex = 1)
```

```{r load_mc, child=c("template_q_med_ins_mc.txt")}
```

```{r load_mc, child=c("template_q_med_ins_loadings_reliability.txt")}
```

# Find the Power

To estimate the power for a sample size,
this is the code:

```{r power, eval=TRUE, results="hide", message=FALSE}
out_power <- q_power_mediation_serial(
  ab = c("m", "m", "l"),
  ab_other = "nil",
  cp = "s",
  number_of_indicators = c(x = 3,
                           m1 = 4,
                           m2 = 3,
                           y = 3),
  reliability = c(x = .70,
                  m1 = .80,
                  m2 = .70,
                  y = .70),
  target_power = .80,
  nrep = 400,
  n = 150,
  R = 1000,
  seed = 1234
)
```

These are the arguments:

- `ab`: The hypothesized standardized effects
  along the path from the predictor `x`
  to the outcome variable `y`. This
  should be a character vector with elements
  equal to the number of mediators
  for the path coefficients `x->m1->m2->...->y`.
  Can be one of the labels supported
  by the [convention](#convention), or
  a numeric value.

- `ab_other`: The hypothesized standardized
  effect for all other paths involving
  the mediators. For simplicity, it only
  support one value, and this value will
  be used for all these paths.
  Can be one of the labels supported
  by the [convention](#convention), or
  a numeric value.

- `cp`: The hypothesized standardized direct
  effect from
  the predictor `x` to the outcome variable `y`.
  Can be one of the labels supported
  by the [convention](#convention), or
  a numeric value.

- `number_of_indicators`: A named
  numeric vector of the numbers of
  indicators. The names need to be
  `x`, `m1`, `m2`, ... , and `y`. If it has only one
  value, then all latent variables have
  the same number of indicators.

- `reliability`: A named
  numeric vector of the population
  reliability. The names need to be
  `x`, `m1`, `m2`, ... , and `y`. If it has only one
  value, then all latent variables have
  the same value for reliability.

```{r load_args, child=c("template_q_med_ins_arguments.txt")}
```

This is the output:

```{r}
out_power
```

```{r load_p4t_output, child=c("template_q_med_ins_power4test_output.txt")}
```

```{r load_regions, child=c("template_q_med_ins_regions.txt")}
```

```{r region, eval=TRUE, results="hide", message=FALSE}
out_region <- q_power_mediation_serial(
  ab = c("m", "m", "l"),
  ab_other = "nil",
  cp = "s",
  number_of_indicators = c(x = 3,
                           m1 = 4,
                           m2 = 3,
                           y = 3),
  reliability = c(x = .70,
                  m1 = .80,
                  m2 = .70,
                  y = .70),
  target_power = .80,
  nrep = 400,
  n = 150,
  R = 1000,
  seed = 1234,
  mode = "region"
)
```

```{r load_regions_out, child=c("template_q_med_ins_regions_printout.txt")}
```


```{r template_q_med_lav_serial_model_region, echo = FALSE, fig.cap = "The Plot of Sample Sizes Searched"}
plot(out_region)
```

The region between the shaded areas is the
approximate region of sample sizes found.


```{r load_final, child=c("template_q_med_ins_final_remarks.txt")}
```
