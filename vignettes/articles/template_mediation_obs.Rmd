---
title: "Quick Template: Mediation with Observed Variables"
date: "2025-06-02"
output:
  html_document:
    fig.align: "center"
    toc: true
    toc_depth: 2
    number_sections: false
bibliography: references.bib
csl: apa.csl
---




# Introduction

This and other "Quick Template" vignettes
are examples of R code to do power
analysis or determine sample size in
typical models using
[power4mome](https://sfcheung.github.io/power4mome/).
Users can quickly adapt
them for their scenarios.

# Prerequisite

Basic knowledge about fitting models
by `lavaan` and `power4mome` is required.

This file is not intended to be an introduction
on how to use functions in `power4mome`.
For details on how to use `power4test()`,
`power4test_by_n()`, and `x_from_power()`,
refer to the [Get-Started article](https://sfcheung.github.io/power4mome/articles/power4mome.html),
and the [article](https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html)
on finding the sample size
given desired power using `x_from_power()`,
as well as the help pages of these
functions.


# Common Flow

The following chart summarizes the steps covered
below.


```{r temp_fig_flowchart, fig.cap="Common Workflow", fig.align="center", message=FALSE}
library(DiagrammeR)
# https://mermaid.live/edit#pako:eNqFk9tu4jAQhl_F8lUrASUHCHEpUrX0st1KVHuxmxUyZHKQHDtynKVZxLvXcQ4NFKl39sz3z-FPfMR7EQImOGLisE-oVOhtHfCAI7RntCjWEKEQIloyhaKUMcLSOFE7VsL9NcYeQLEE4PdNrUJVDJCSFW8AZIgKmO76mc_0KOwaUCMbUM91_ibA-oheRV4yqlLBkQkH-LalnjZfkV9UT1wsd_JutUxXuci3-naXrlrVTw4vWvQmKyQ4IP4JHkC6Cgp1czvAN_APJGWdpGiuiBdfddtdteUXYir3yYuZsT4hjg6pSpCiMtZDG2lX530bSZFtTeysyCMXKgHZTUCb6zeDG6PLXSxpnrRe_wlw697fc5cJIf0nHY9Xja-DYEMDD3vZ0wY9PKyMlZ2laDzppBfdzZ-gm7_Wc_bNjWZZV-n2G-7aZDrvr2WMseeFhvgw2qMdcJE4267vM9xnIL0MmxqDKB7hDGRG01A_tGPNBFgXzCDARB9bTwMc8JNGaanEpuJ7TJQsYYSlKOMEk4iyQt_KPKQK1inVRmZ9NKf8txBZJ4EwVUI-Ny_bPHCDYHLE75jYnjWZu9bCdxZz33Mdd4QrTGbuZGp7tjubu747s1xrfhrh_6bodOI5lufOp5bnO_bCt0c4lvUy7YDaKJA_RMkVJo5vOacPm8xrNw
mermaid('
flowchart TD
  classDef default fill:lightblue;
  classDef default2 fill:lightgreen;

  style tryn fill: lightyellow
  style model fill: lightyellow

  SetModel("Set Population Model")
  SetES("Set Population Values<br/><i>pop_es</i>")
  OneN("Try one n<br/><i>power4test()</i>")
  SeveralN("Try several ns<br/><i>power4test_by_n()</i>")
  SearchN("Search n with target power<br/><i>x_from_power()</i>")
  AnotherN("Try another n<br/><i>power4test()</i>")

  subgraph model ["Model"]

  SetModel:::default2 --> SetES:::default2

  end

  SetES ==> OneN
  OneN -.-> SetES

  subgraph tryn ["Power"]

  OneN <==> AnotherN
  AnotherN <==> SeveralN
  AnotherN <==> SearchN
  OneN <==> SeveralN
  OneN <==> SearchN
  SeveralN <==> SearchN

  end

  AnotherN -.-> SetES
  SeveralN -.-> SetES
  SearchN -.-> SetES
', height = 760, width = 500)
```

In practice, steps can be repeated,
and population values changed, until
the desired goal is achieved (e.g.,
a sample size with power close to
the target power is found).

# Scope

This file is for simple mediation models.

# Try One N

Estimate the power for a sample size.

The code:


``` r
library(power4mome)
#
# ====== Model: Form ======
model <-
"
m ~ x
y ~ m + x
"
#
# ====== Model: Population Values ======
# l: large (.50 by default)
# m: medium (.30 by default)
# s: small (.10 by default)
model_es <-
"
m ~ x: s
y ~ m: l
y ~ x: m
"
#
# ====== Test the Model Specification ======
out <- power4test(nrep = 2,
                  model = model,
                  pop_es = model_es,
                  n = 50000,
                  iseed = 1234)
#
# ====== Check the Data Generated ======
print(out,
      data_long = TRUE)
#
# ====== Estimate the Power ======
# For n = 100,
# when testing the indirect effect by
# Monte Carlo confidence interval
out <- power4test(nrep = 400,
                  model = model,
                  pop_es = model_es,
                  n = 100,
                  R = 1000,
                  ci_type = "mc",
                  test_fun = test_indirect_effect,
                  test_args = list(x = "x",
                                   m = "m",
                                   y = "y",
                                   mc_ci = TRUE),
                  iseed = 1234,
                  parallel = TRUE)
#
# ====== Compute the Rejection Rate ======
rejection_rates(out)
```

The results:


``` r
print(out,
      data_long = TRUE)
#>
#> ====================== Model Information ======================
#>
#> == Model on Factors/Variables ==
#>
#> m ~ x
#> y ~ m + x
#>
#> == Model on Variables/Indicators ==
#>
#> m ~ x
#> y ~ m + x
#>
#> ====== Population Values ======
#>
#> Regressions:
#>                    Population
#>   m ~
#>     x                 0.100
#>   y ~
#>     m                 0.500
#>     x                 0.300
#>
#> Variances:
#>                    Population
#>    .m                 0.990
#>    .y                 0.630
#>     x                 1.000
#>
#> == Population Indirect Effect(s) ==
#>
#> ==  Indirect Effect(s)   ==
#>               ind
#> x -> m -> y 0.050
#>
#>  - The 'ind' column shows the indirect effects.
#>
#> ======================= Data Information =======================
#>
#> Number of Replications:  400
#> Sample Sizes:  100
#>
#> ==== Descriptive Statistics ====
#>
#>   vars     n  mean sd  skew kurtosis   se
#> m    1 40000  0.00  1  0.01    -0.01 0.01
#> y    2 40000 -0.01  1 -0.02    -0.03 0.01
#> x    3 40000  0.00  1  0.01    -0.02 0.01
#>
#> ==== Parameter Estimates Based on All 400 Samples Combined ====
#>
#> Total Sample Size: 40000
#>
#> ==== Standardized Estimates ====
#>
#> Variances and error variances omitted.
#>
#> Regressions:
#>                     est.std
#>   m ~
#>     x                 0.099
#>   y ~
#>     m                 0.499
#>     x                 0.305
#>
#>
#> ==================== Extra Element(s) Found ====================
#>
#> - fit
#> - mc_out
#>
#> === Element(s) of the First Dataset ===
#>
#> ============ <fit> ============
#>
#> lavaan 0.6-19 ended normally after 1 iteration
#>
#>   Estimator                                         ML
#>   Optimization method                           NLMINB
#>   Number of model parameters                         5
#>
#>   Number of observations                           100
#>
#> Model Test User Model:
#>
#>   Test statistic                                 0.000
#>   Degrees of freedom                                 0
#>
#> =========== <mc_out> ===========
#>
#>
#> == A 'mc_out' class object ==
#>
#> Number of Monte Carlo replications: 1000
#>
#>
#> ====================== Test(s) Conducted ======================
#>
#> - test_indirect: x->m->y
#>
#> Call print() and set 'test_long = TRUE' for a detailed report.
rejection_rates(out)
#>                     test test_label   p.v reject r.cilo r.cihi
#> 1 test_indirect: x->m->y       Test 1.000  0.195  0.156  0.234
#> Notes:
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
```

# Try Another N

To rerun the simulation to estimate
power for another sample size.

The code:


``` r
#
# ===== Reuse the output of power4test() =====
# Estimate power for n = 150
# Set n to 150
out_new_n <- power4test(out,
                        n = 150)
#
# ===== Compute Rejection Rate (Power) =====
rejection_rates(out_new_n)
```

The results:


``` r
rejection_rates(out_new_n)
#>                     test test_label   p.v reject r.cilo r.cihi
#> 1 test_indirect: x->m->y       Test 1.000  0.290  0.246  0.334
#> Notes:
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
```

# Try Several N's

Rerun the simulation to estimate
power for with several sample sizes.

The code:


``` r
#
# ===== Reuse the output of power4test() =====
# Estimate power for n = 200, 250, 300
# Use power4test_by_n()
out_ns <- power4test_by_n(out,
                          n = c(200, 250, 300),
                          by_seed = 5789)
#
# ===== Compute Rejection Rate (Power) =====
rejection_rates(out_ns)
```

The results:


``` r
rejection_rates(out_ns)
#>     n                   test test_label   p.v reject r.cilo r.cihi
#> 1 200 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368
#> 2 250 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368
#> 3 300 test_indirect: x->m->y       Test 1.000  0.445  0.396  0.494
#> Notes:
#> - n: The sample size in a trial.
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
```

# Search N With Target Power

Search, by simulation, the sample size
with estimated power close to a target
level (e.g., .80).

## Use the Output of `power4test()`

Do this step after calling `power4test()`
on a sample size.

It can take some time to run if estimated power
of the sample size is too different from
the target power.

The code:


``` r
#
# ===== Reuse the output of power4test() =====
# Call x_from_power()
# - Set target power: target_power = .80 (Default, can be omitted)
# To set desired precision:
# - Set final number of R: final_R = 1000 (Default, can be omitted)
# - Set final number of replications: final_nrep = 400 (Default, can be omitted)
n_power_80 <- x_from_power(out,
                           x = "n",
                           seed = 1357)
#
# ===== Print the Summary =====
summary(n_power_80)
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80)
```

The results:


``` r
#
# ===== Print the Summary =====
summary(n_power_80)
#>
#> ====== x_from_power Results ======
#>
#> Call:
#> x_from_power(object = out, x = "n", seed = 1357)
#> Predictor (x): Sample Size
#>
#> - Target Power: 0.800
#>
#> === Major Results ===
#>
#> - Final Value: 668
#> - Final Estimated Power: 0.762
#> - Confidence Interval: [0.721; 0.804]
#> - Level of confidence: 95.0%
#> - Based on 400 replications.
#>
#> === Technical Information ===
#>
#> - The range of values explored: 100 to 1492
#> - Time spent in the search: 2.22 mins
#> - The final crude model for the power-predictor relation:
#>
#> Model Type: Nonlinear Regression Model
#>
#> Call:
#> power_curve(object = by_x_1, formula = power_model, start = stats::coef(fit_1),
#>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,
#>     nls_control = nls_control, verbose = progress)
#>
#> Predictor: n (Sample Size)
#>
#> Model:
#> Nonlinear regression model
#>   model: reject ~ I((x - c0)^e)/(b + I((x - c0)^e))
#>    data: "(Omitted)"
#>        b       c0        e
#> 2171.282    0.000    1.326
#>  weighted residual sum-of-squares: 1.548
#>
#> Algorithm "port", convergence message: relative convergence (4)
#>
#> - Detailed Results:
#>
#>       n                   test test_label   p.v reject r.cilo r.cihi
#> 1   100 test_indirect: x->m->y       Test 1.000  0.195  0.156  0.234
#> 2   255 test_indirect: x->m->y       Test 1.000  0.340  0.247  0.433
#> 3   410 test_indirect: x->m->y       Test 1.000  0.510  0.412  0.608
#> 4   645 test_indirect: x->m->y       Test 1.000  0.752  0.668  0.837
#> 5   668 test_indirect: x->m->y       Test 1.000  0.762  0.721  0.804
#> 6   693 test_indirect: x->m->y       Test 1.000  0.743  0.689  0.797
#> 7   694 test_indirect: x->m->y       Test 1.000  0.720  0.632  0.808
#> 8   750 test_indirect: x->m->y       Test 1.000  0.780  0.699  0.861
#> 9   936 test_indirect: x->m->y       Test 1.000  0.863  0.829  0.896
#> 10 1492 test_indirect: x->m->y       Test 1.000  0.963  0.944  0.981
#> Notes:
#> - n: The sample size in a trial.
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80)
```

<div class="figure" style="text-align: center">
<img src="temp_med_obs_med_simple_n_from_out-1.png" alt="Power Curve"  />
<p class="caption">Power Curve</p>
</div>

## Use the Output of `power4test_by_n()`

Do this step after calling `power4test_by_n()`
on a sample size.

Continue the search using the output
on several sample sizes
by calling `x_from_power()` on the
output of `power4test_by_n()`.

It can take some time to run if estimated levels
of power
of the sample sizes are too different from
the target power.

The code:


``` r
#
# ===== Reuse the output of power4test_by_n() =====
# Call x_from_power()
# - Set target power: target_power = .80 (Default, can be omitted)
# To set desired precision:
# - Set final number of R: final_R = 1000 (Default, can be omitted)
# - Set final number of replications: final_nrep = 400 (Default, can be omitted)
n_power_80_ns <- x_from_power(out_ns,
                              x = "n",
                              seed = 1357)
#
# ===== Print the Summary =====
summary(n_power_80_ns)
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80_ns)
```

The results:


``` r
#
# ===== Print the Summary =====
summary(n_power_80_ns)
#>
#> ====== x_from_power Results ======
#>
#> Call:
#> x_from_power(object = out_ns, x = "n", seed = 1357)
#> Predictor (x): Sample Size
#>
#> - Target Power: 0.800
#>
#> === Major Results ===
#>
#> - Final Value: 807
#> - Final Estimated Power: 0.818
#> - Confidence Interval: [0.780; 0.855]
#> - Level of confidence: 95.0%
#> - Based on 400 replications.
#>
#> === Technical Information ===
#>
#> - The range of values explored: 200 to 807
#> - Time spent in the search: 2.061 mins
#> - The final crude model for the power-predictor relation:
#>
#> Model Type: Logistic Regression
#>
#> Call:
#> power_curve(object = by_x_i, formula = power_model, start = start,
#>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,
#>     nls_control = nls_control, verbose = progress)
#>
#> Predictor: n (Sample Size)
#>
#> Model:
#>
#> Call:  stats::glm(formula = reject ~ x, family = "binomial", data = reject1)
#>
#> Coefficients:
#> (Intercept)            x
#>   -1.608780     0.004152
#>
#> Degrees of Freedom: 1399 Total (i.e. Null);  1398 Residual
#> Null Deviance:	    1879
#> Residual Deviance: 1830 	AIC: 1834
#>
#> - Detailed Results:
#>
#>      n                   test test_label   p.v reject r.cilo r.cihi
#> 1  200 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368
#> 2  250 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368
#> 3  300 test_indirect: x->m->y       Test 1.000  0.445  0.396  0.494
#> 4  420 test_indirect: x->m->y       Test 1.000  0.540  0.442  0.638
#> 5  539 test_indirect: x->m->y       Test 1.000  0.630  0.535  0.725
#> 6  651 test_indirect: x->m->y       Test 1.000  0.708  0.663  0.752
#> 7  666 test_indirect: x->m->y       Test 1.000  0.770  0.688  0.852
#> 8  721 test_indirect: x->m->y       Test 1.000  0.787  0.736  0.838
#> 9  722 test_indirect: x->m->y       Test 1.000  0.733  0.689  0.776
#> 10 785 test_indirect: x->m->y       Test 1.000  0.842  0.770  0.913
#> 11 807 test_indirect: x->m->y       Test 1.000  0.818  0.780  0.855
#> Notes:
#> - n: The sample size in a trial.
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
#
# ===== Plot the (Crude) Power Curve =====
plot(n_power_80_ns)
```

<div class="figure" style="text-align: center">
<img src="temp_med_obs_med_simple_n_from_by_out-1.png" alt="Power Curve"  />
<p class="caption">Power Curve</p>
</div>

# Change Population Values and Repeat

If necessary, change the population value(s)
and repeat the steps.

For example, set both the `m ~ x` path
and `y ~ m` path to medium (.30)
(population indirect effect .09).

The code:


``` r
model_es2 <-
"
m ~ x: m
y ~ m: m
y ~ x: m
"
#
# ====== Estimate the Power ======
out2 <- power4test(nrep = 400,
                   model = model,
                   pop_es = model_es2,
                   n = 100,
                   R = 1000,
                   ci_type = "mc",
                   test_fun = test_indirect_effect,
                   test_args = list(x = "x",
                                    m = "m",
                                    y = "y",
                                    mc_ci = TRUE),
                   iseed = 1234,
                   parallel = TRUE)
#
# ====== Compute the Rejection Rate ======
rejection_rates(out2)
```

The results:


``` r
print(out2,
      data_long = TRUE)
#>
#> ====================== Model Information ======================
#>
#> == Model on Factors/Variables ==
#>
#> m ~ x
#> y ~ m + x
#>
#> == Model on Variables/Indicators ==
#>
#> m ~ x
#> y ~ m + x
#>
#> ====== Population Values ======
#>
#> Regressions:
#>                    Population
#>   m ~
#>     x                 0.300
#>   y ~
#>     m                 0.300
#>     x                 0.300
#>
#> Variances:
#>                    Population
#>    .m                 0.910
#>    .y                 0.766
#>     x                 1.000
#>
#> == Population Indirect Effect(s) ==
#>
#> ==  Indirect Effect(s)   ==
#>               ind
#> x -> m -> y 0.090
#>
#>  - The 'ind' column shows the indirect effects.
#>
#> ======================= Data Information =======================
#>
#> Number of Replications:  400
#> Sample Sizes:  100
#>
#> ==== Descriptive Statistics ====
#>
#>   vars     n  mean sd  skew kurtosis   se
#> m    1 40000  0.00  1  0.01     0.00 0.01
#> y    2 40000 -0.01  1 -0.01    -0.01 0.01
#> x    3 40000  0.00  1  0.01    -0.02 0.01
#>
#> ==== Parameter Estimates Based on All 400 Samples Combined ====
#>
#> Total Sample Size: 40000
#>
#> ==== Standardized Estimates ====
#>
#> Variances and error variances omitted.
#>
#> Regressions:
#>                     est.std
#>   m ~
#>     x                 0.299
#>   y ~
#>     m                 0.298
#>     x                 0.306
#>
#>
#> ==================== Extra Element(s) Found ====================
#>
#> - fit
#> - mc_out
#>
#> === Element(s) of the First Dataset ===
#>
#> ============ <fit> ============
#>
#> lavaan 0.6-19 ended normally after 1 iteration
#>
#>   Estimator                                         ML
#>   Optimization method                           NLMINB
#>   Number of model parameters                         5
#>
#>   Number of observations                           100
#>
#> Model Test User Model:
#>
#>   Test statistic                                 0.000
#>   Degrees of freedom                                 0
#>
#> =========== <mc_out> ===========
#>
#>
#> == A 'mc_out' class object ==
#>
#> Number of Monte Carlo replications: 1000
#>
#>
#> ====================== Test(s) Conducted ======================
#>
#> - test_indirect: x->m->y
#>
#> Call print() and set 'test_long = TRUE' for a detailed report.
rejection_rates(out2)
#>                     test test_label   p.v reject r.cilo r.cihi
#> 1 test_indirect: x->m->y       Test 1.000  0.745  0.702  0.788
#> Notes:
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
```

For illustration, go directly to
searching by `x_from_power()`:

The code:


``` r
#
# ===== Reuse the output of power4test() =====
n2_power_80 <- x_from_power(out2,
                            x = "n",
                            seed = 1357)
#
# ===== Print the Summary =====
summary(n2_power_80)
#
# ===== Plot the (Crude) Power Curve =====
plot(n2_power_80)
```

The results:


``` r
#
# ===== Print the Summary =====
summary(n2_power_80)
#>
#> ====== x_from_power Results ======
#>
#> Call:
#> x_from_power(object = out2, x = "n", seed = 1357)
#> Predictor (x): Sample Size
#>
#> - Target Power: 0.800
#>
#> === Major Results ===
#>
#> - Final Value: 101
#> - Final Estimated Power: 0.802
#> - Confidence Interval: [0.763; 0.842]
#> - Level of confidence: 95.0%
#> - Based on 400 replications.
#>
#> === Technical Information ===
#>
#> - The range of values explored: 100 to 120
#> - Time spent in the search: 2.039 mins
#> - The final crude model for the power-predictor relation:
#>
#> Model Type: Logistic Regression
#>
#> Call:
#> power_curve(object = by_x_i, formula = power_model, start = start,
#>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,
#>     nls_control = nls_control, verbose = progress)
#>
#> Predictor: n (Sample Size)
#>
#> Model:
#>
#> Call:  stats::glm(formula = reject ~ x, family = "binomial", data = reject1)
#>
#> Coefficients:
#> (Intercept)            x
#>    -2.39667      0.03479
#>
#> Degrees of Freedom: 599 Total (i.e. Null);  598 Residual
#> Null Deviance:	    663.6
#> Residual Deviance: 662.6 	AIC: 666.6
#>
#> - Detailed Results:
#>
#>     n                   test test_label   p.v reject r.cilo r.cihi
#> 1 100 test_indirect: x->m->y       Test 1.000  0.745  0.702  0.788
#> 2 101 test_indirect: x->m->y       Test 1.000  0.802  0.763  0.842
#> 3 102 test_indirect: x->m->y       Test 1.000  0.770  0.688  0.852
#> 4 104 test_indirect: x->m->y       Test 1.000  0.790  0.710  0.870
#> 5 107 test_indirect: x->m->y       Test 1.000  0.780  0.699  0.861
#> 6 108 test_indirect: x->m->y       Test 1.000  0.787  0.747  0.828
#> 7 109 test_indirect: x->m->y       Test 1.000  0.755  0.701  0.809
#> 8 116 test_indirect: x->m->y       Test 1.000  0.888  0.828  0.948
#> 9 120 test_indirect: x->m->y       Test 1.000  0.840  0.804  0.876
#> Notes:
#> - n: The sample size in a trial.
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
#
# ===== Plot the (Crude) Power Curve =====
plot(n2_power_80)
```

<div class="figure" style="text-align: center">
<img src="temp_med_obs_med_simple2_n_from_out-1.png" alt="Power Curve"  />
<p class="caption">Power Curve</p>
</div>
