---
title: "Quick Function: Parallel Mediation with Latent Variables"
date: "`r Sys.Date()`"
output:
  html_document:
    fig.align: "center"
    toc: true
    toc_depth: 2
    number_sections: false
bibliography: references.bib
csl: apa.csl
---

```{r knitr_setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "",
  fig.align = "center"
)
```

```{r load_pre, child=c("template_q_med_ins_preamble.txt")}
```

# Scope

This file is for parallel mediation models,
and only use one function `q_power_mediation_parallel()`
from the package
[power4mome](https://sfcheung.github.io/power4mome/).

```{r}
library(power4mome)
```

# The Model

Suppose this is the model:

```{r template_q_med_lav_parallel_model, echo = FALSE, fig.cap = "The Model"}
library(semPlot)
library(semptools)
suppressMessages(library(lavaan))
mod <-
"
m1 ~ m*x
m2 ~ m*x
y ~ l*m1 + l*m2 + s*x
x =~ x1 + x2 + x3
m1 =~ m11 + m12 + m13 + m14
m2 =~ m21 + m22 + m23
y =~ y1 + y2 + y3
"
fit0 <- sem(mod, do.fit = FALSE, fixed.x = FALSE)
set.seed(1234)
onames <- lavNames(fit0)
p <- length(onames)
dat <- data.frame(MASS::mvrnorm(100, rep(0, p), diag(p)))
colnames(dat) <- onames
fit0 <- sem(mod, dat, do.fit = FALSE)
layout_m <- matrix(c(NA, "m1", NA,
                     "x", NA,  "y",
                     NA, "m2", NA), 3, 3, byrow = TRUE)
p <- semPaths(fit0,
              whatLabels = "label",
              nCharNodes = 0,
              exoCov = FALSE,
              edge.label.cex = 1.25 * 1.5,
              label.cex = 1.25,
              residuals = FALSE,
              sizeMan = 6,
              sizeMan2 = 4,
              asize = 5,
              DoNotPlot = TRUE)
p2 <- set_sem_layout(
          p,
          factor_layout = layout_m,
          factor_point_to = c(x = "left",
                              m1 = "up",
                              m2 = "down",
                              y = "right"),
          indicator_push = c(x = 1,
                             y = 1),
          indicator_spread = c(x = 2,
                               y = 2,
                               m1 = 2,
                               m2 = 2)
        ) |>
      set_curve(c("y ~ m1" = 0))
p2$graphAttributes$Edges$labels[1:5] <-
  c("a1",
    "a2",
    "b1",
    "b2",
    "c'")

# p2$graphAttributes$Edges$labels[1:5] <-
#   c("m\n(medium: .30)",
#     "m\n(medium: .30)",
#     "l\n(large: .50)",
#     "l\n(large: .50)",
#     "s\n(small: .10)")

plot(p2)
text(label = "Parallel Mediation Model",
     x = 0, y = -1.3,
     cex = 1.5)
```

This is a parallel mediation model, but
the model is on the latent variables,
each with some indicators.

We want to do power analysis for the
indirect effects from `x` to `y`:
`x->m1->y` and `x->m2->y`.
Suppose these are the expected
effects:

- `x->m1`: medium

- `x->m2`: large

- `m1->y`: large

- `m2->y`: medium

- `x->y`: small

```{r load_convention, child=c("template_q_med_ins_convention.txt")}
```

```{r load_cov, child=c("template_q_med_ins_covariates.txt")}
```

## Model with Hypothesized Path Coefficients


This is the model with the effect sizes,
showing only the latent variables:

```{r template_q_med_lav_parallel_model_es, echo = FALSE, fig.cap = "The Model (with Effect Sizes)"}
library(semPlot)
suppressMessages(library(lavaan))
mod <-
"
m1 ~ m*x
m2 ~ m*x
y ~ s*m1 + m*m2 + s*x
"
fit0 <- sem(mod, do.fit = FALSE, fixed.x = FALSE)
set.seed(1234)
dat <- data.frame(MASS::mvrnorm(100, rep(0, 5), diag(5)))
colnames(dat) <- lavNames(fit0)
fit0 <- sem(mod, dat, do.fit = FALSE, fixed.x = FALSE)
layout_m <- matrix(c(NA, "m1", NA,
                     "x", NA, "y",
                     NA, "m2", NA), 3, 3, byrow = TRUE)
p <- semPaths(fit0,
              whatLabels = "label",
              layout = layout_m,
              nCharNodes = 0,
              exoCov = FALSE,
              edge.label.cex = 1.25,
              label.cex = 1.5,
              residuals = FALSE,
              sizeMan = 8,
              asize = 5,
              DoNotPlot = TRUE)
p$graphAttributes$Edges$labels <-
  c("a1" = "m\n(medium: .30)",
    "a2" = "l\n(large: .50)",
    "b1" = "l\n(large: .50)",
    "b2" = "m\n(medium: .30)",
    "c'" = "s\n(small: .10)")

# p$graphAttributes$Edges$labels <-
#   c("m\n(medium: .30)",
#     "m\n(medium: .30)",
#     "m\n(medium: .30)",
#     "s\n(small: .10)",
#     "m\n(medium: .30)",
#     "l\n(large: .50)",
#     "s\n(small: .10)")
p$graphAttributes$Nodes$shape[] <- "circle"
plot(p)
text(label = "Parallel Mediation Model",
     x = 0, y = -1.4,
     cex = 1.25)
```

```{r load_mc, child=c("template_q_med_ins_mc.txt")}
```

```{r load_mc, child=c("template_q_med_ins_loadings_reliability.txt")}
```

# Find the Power

To estimate the power for a sample size,
this is the code:

```{r power, eval=TRUE, results="hide", message=FALSE}
out_power <- q_power_mediation_parallel(
  as = c("m", "l"),
  bs = c("l", "m"),
  cp = "s",
  number_of_indicators = c(x = 3,
                           m1 = 4,
                           m2 = 3,
                           y = 3),
  reliability = c(x = .70,
                  m1 = .80,
                  m2 = .70,
                  y = .70),
  target_power = .80,
  nrep = 400,
  n = 300,
  R = 1000,
  seed = 1234
)
```


- `as`: The hypothesized standardized effects
  from the predictor `x`
  to each mediator. This
  should be a character vector with elements
  equal to the number of mediators
  for the path coefficients `x->m1`, `x->m2`,
  up to `x->mk`, `k` being the number of mediators.
  Can be one of the labels supported
  by the [convention](#convention), or
  a numeric value.

- `bs`: The hypothesized standardized effects
  from each mediator to the outcome variable `y`.
  This
  should be a character vector with elements
  equal to the number of mediators
  for the path coefficients `m1->y`, `m2->y`,
  up to `mk->y`, `k` being the number of mediators.
  Can be one of the labels supported
  by the [convention](#convention), or
  a numeric value.

- `cp`: The hypothesized standardized direct
  effect from
  the predictor `x` to the outcome variable `y`.
  Can be one of the labels supported
  by the [convention](#convention), or
  a numeric value.

- `number_of_indicators`: A named
  numeric vector of the numbers of
  indicators. The names need to be
  `x`, `m1`, `m2`, ... , and `y`. If it has only one
  value, then all latent variables have
  the same number of indicators.

- `reliability`: A named
  numeric vector of the population
  reliability. The names need to be
  `x`, `m1`, `m2`, ... , and `y`. If it has only one
  value, then all latent variables have
  the same value for reliability.

```{r load_args, child=c("template_q_med_ins_arguments.txt")}
```

This is the output:

```{r}
out_power
```


```{r load_p4t_output, child=c("template_q_med_ins_power4test_output.txt")}
```

```{r load_regions, child=c("template_q_med_ins_regions.txt")}
```


```{r region, eval=TRUE, results="hide", message=FALSE}
out_region <- q_power_mediation_parallel(
  as = c("m", "l"),
  bs = c("l", "m"),
  cp = "s",
  number_of_indicators = c(x = 3,
                           m1 = 4,
                           m2 = 3,
                           y = 3),
  reliability = c(x = .70,
                  m1 = .80,
                  m2 = .70,
                  y = .70),
  target_power = .80,
  nrep = 400,
  n = 300,
  R = 1000,
  seed = 1234,
  mode = "region"
)
```

```{r load_regions_out, child=c("template_q_med_ins_regions_printout.txt")}
```


```{r template_q_med_lav_parallel_model_region, echo = FALSE, fig.cap = "The Plot of Sample Sizes Searched"}
plot(out_region)
```


The region between the shaded areas is the
approximate region of sample sizes found.


```{r load_final, child=c("template_q_med_ins_final_remarks.txt")}
```

