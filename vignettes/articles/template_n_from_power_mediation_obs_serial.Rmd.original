---
title: "Quick Template: Serial Mediation with Observed Variables"
date: "`r Sys.Date()`"
output:
  html_document:
    fig.align: "center"
    toc: true
    toc_depth: 2
    number_sections: false
bibliography: references.bib
csl: apa.csl
---

```{r knitr_setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "",
  fig.align = "center"
)
```

```{r load_pre, child=c("template_n_preamble.txt")}
```

```{r load_flow, echo=FALSE, results="asis"}
# Adapted from this answer
cat(readLines("template_n_flowchart.txt"),
    sep = "\n")
```

# Scope

This file is for serial mediation models.

# Try One N

Estimate the power for a sample size.

The code:

```{r med, eval=TRUE, results="hide", message=FALSE}
library(power4mome)
#
# ====== Model: Form ======
# Omit any paths hypothesized to be zero
model <-
"
m1 ~ x
m2 ~ m1 + x
m3 ~ m2 + m1 + x
y ~ m3 + m2 + m1 + x
"
#
# ====== Model: Population Values ======
# l: large (.50 by default)
# m: medium (.30 by default)
# s: small (.10 by default)
# -l, -m, and -s denote negative values
# Can also set to a number directly
# Set each path to the hypothesized magnitude
model_es <-
"
m1 ~ x: l
m2 ~ m1: l
m3 ~ m2: l
y ~ m3: m
y ~ x: s
"
#
# ====== Test the Model Specification ======
out <- power4test(nrep = 2,
                  model = model,
                  pop_es = model_es,
                  n = 50000,
                  iseed = 1234)
#
# ====== Check the Data Generated ======
print(out,
      data_long = TRUE)
#
# ====== Estimate the Power ======
# For n = 50,
# when testing the indirect effect by
# Monte Carlo confidence interval
out <- power4test(nrep = 400,
                  model = model,
                  pop_es = model_es,
                  n = 50,
                  R = 1000,
                  ci_type = "mc",
                  test_fun = test_indirect_effect,
                  test_args = list(x = "x",
                                   m = c("m1", "m2", "m3"),
                                   y = "y",
                                   mc_ci = TRUE),
                  iseed = 1234,
                  parallel = TRUE)
#
# ====== Compute the Rejection Rate ======
rejection_rates(out)
```

The results:

```{r med_out}
print(out,
      data_long = TRUE)
rejection_rates(out)
```

## Try Another N

We can rerun the simulation to estimate
power for another sample size before going
to the next step. This can be useful if
the estimated power of the initial attempt
is too different from the target power.

However, this step is optional because
the next step, though may take longer,
should still be able to find the
desired region.

The code:

```{r med_new_n, eval=TRUE, results="hide", message=FALSE}
#
# ===== Reuse the output of power4test() =====
# Estimate power for n = 150
# Set n to 150
out_new_n <- power4test(out,
                        n = 150)
#
# ===== Compute Rejection Rate (Power) =====
rejection_rates(out_new_n)
```

The results:

```{r med_new_n_out}
rejection_rates(out_new_n)
```

# Find the Regions of *N* Based on the Target Power

Search, by simulation, the following
two regions of sample sizes:

- Sample sizes with estimated levels of
  power significantly below the target
  level (e.g., .80). That is, we find
  the largest sample size with
  the *upper bound* (`ub`) of the
  confidence interval of its power
  touches to the
  target level.

- Sample sizes with estimated levels of
  power significantly above the target
  level (e.g., .80). That is, we find
  the smallest sample size with
  the *lower bound* (`ub`) of the
  confidence interval of its power
  touches to the
  target level.

In practice, we nearly need high precision
for these regions for sample size planning.
Therefore, we only need to find the two
sample sizes with the corresponding
confidence bounds *close* *enough* to
the target power, defined by a tolerance value.
In the function below, this value is .02
by default.

Do this step after calling `power4test()`
on a sample size.

It can take some time to run if estimated power
of the sample size is too different from
the target power.

## Finding the Two Regions Using `n_region_from_power()`

Instead of doing the search by calling
`n_from_power()` twice, we can find them
by calling `n_region_from_power()`.

The code:

```{r med_n_serial_n_from, eval=TRUE, results="hide", message=FALSE, fig.keep="none"}
#
# ===== Reuse the output of power4test() =====
# Call n_from_power()
# - Set target power: target_power = .80 (Default, can be omitted)
# - Set the seed for the simulation: Integer. Should always be set.
# To set desired precision:
# - Set final number of R: final_R = 1000 (Default, can be omitted)
# - Set final number of replications: final_nrep = 400 (Default, can be omitted)
n_power_region <- n_region_from_power(out,
                                      seed = 1357)
#
# ===== Basic Results =====
n_power_region
#
# ===== Plot the (Crude) Power Curve and the Regions =====
plot(n_power_region)
```

The results:

```{r temp_n_med_obs_med_serial_n_from_out, fig.cap = "Power Curve"}
#
# ===== Basic Results =====
n_power_region
#
# ===== Plot the (Crude) Power Curve and the Regions =====
plot(n_power_region)
```

As shown above, approximately:

- sample sizes lower than
  `r n_power_region$below$x_final` have
  power significantly lower than .80, and

- sample sizes higher than
  `r n_power_region$above$x_final` have
  power significantly higher than .80.

In other words, sample sizes between
`r n_power_region$below$x_final` and
`r n_power_region$above$x_final` have
power not significantly different from
.80.

If necessary, detailed results can be
printed by `summary()`:

```{r summary}
# ===== Detailed Results =====
summary(n_power_region)
```

# Change Population Values and Repeat

If necessary, change the population value(s)
and repeat the steps.

For example, set all the paths along
the indirect effect to medium (.30).

The code:

```{r med_serial2, eval=TRUE, results="hide", message=FALSE}
model_es2 <-
"
m1 ~ x: m
m2 ~ m1: m
m3 ~ m2: m
y ~ m3: m
y ~ x: s
"
#
# ====== Estimate the Power ======
out2 <- power4test(nrep = 400,
                   model = model,
                   pop_es = model_es2,
                   n = 100,
                   R = 1000,
                   ci_type = "mc",
                   test_fun = test_indirect_effect,
                   test_args = list(x = "x",
                                    m = c("m1", "m2", "m3"),
                                    y = "y",
                                    mc_ci = TRUE),
                   iseed = 1234,
                   parallel = TRUE)
#
# ====== Compute the Rejection Rate ======
rejection_rates(out2)
```

The results:

```{r med_serial2_out}
print(out2,
      data_long = TRUE)
rejection_rates(out2)
```

## Find the Two Regions Using `n_region_from_power()`

```{r med_n_serial_n_from2, eval=TRUE, results="hide", message=FALSE, fig.keep="none"}
#
# ===== Reuse the output of power4test() =====
n_power_region2 <- n_region_from_power(out2,
                                       seed = 1357)
#
# ===== Basic Results =====
n_power_region2
#
# ===== Plot the (Crude) Power Curve and the Regions =====
plot(n_power_region2)
```

The results:

```{r temp_n_med_obs_med_serial_n_from_out2, fig.cap = "Power Curve"}
#
# ===== Basic Results =====
n_power_region2
#
# ===== Plot the (Crude) Power Curve and the Regions =====
plot(n_power_region2)
```

As shown above, with the indirect effect
decreased, approximately:

- sample sizes lower than
  `r n_power_region2$below$x_final` have
  power significantly lower than .80, and

- sample sizes higher than
  `r n_power_region2$above$x_final` have
  power significantly higher than .80.

In other words, sample sizes between
`r n_power_region2$below$x_final` and
`r n_power_region2$above$x_final` have
power not significantly different from
.80. The required sample sizes are
larger than the original case.

If necessary, detailed results can be
printed by `summary()`:

```{r summary2}
# ===== Detailed Results =====
summary(n_power_region2)
```

# Code Template {#code_template}

This is the code used above:

```{r code_example, eval = FALSE}
library(power4mome)

# ====== Model and Effect Size (Population Values) ======

model <-
"
m1 ~ x
m2 ~ m1 + x
m3 ~ m2 + m1 + x
y ~ m3 + m2 + m1 + x
"

model_es <-
"
m1 ~ x: l
m2 ~ m1: l
m3 ~ m2: l
y ~ m3: m
y ~ x: s
"

# Test the Model Specification

out <- power4test(nrep = 2,
                  model = model,
                  pop_es = model_es,
                  n = 50000,
                  iseed = 1234)

# Check the Data Generated

print(out,
      data_long = TRUE)

# ====== Try One N and Estimate the Power ======

# For n = 100,
# when testing the indirect effect by
# Monte Carlo confidence interval

out <- power4test(nrep = 400,
                  model = model,
                  pop_es = model_es,
                  n = 100,
                  R = 1000,
                  ci_type = "mc",
                  test_fun = test_indirect_effect,
                  test_args = list(x = "x",
                                   m = c("m1", "m2", "m3"),
                                   y = "y",
                                   mc_ci = TRUE),
                  iseed = 1234,
                  parallel = TRUE)
rejection_rates(out)

# ====== Regions of Ns ======

# Call n_from_power()
# - Set target power: target_power = .80 (Default, can be omitted)
# - Set the seed for the simulation: Integer. Should always be set.
# To set desired precision:
# - Set final number of R: final_R = 1000 (Default, can be omitted)
# - Set final number of replications: final_nrep = 400 (Default, can be omitted)

n_power_region <- n_region_from_power(out,
                                      seed = 1357)
n_power_region
plot(n_power_region)
summary(n_power_region)
```

```{r load_final, child=c("template_n_final_remarks.txt")}
```

