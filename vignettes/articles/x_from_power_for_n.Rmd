---
title: "Sample Size Given Desired Power"
author: "Shu Fai Cheung, Wendie Yang, & Sing-Hang Cheung"
date: "2025-05-25"
output:
  rmarkdown::html_vignette:
    options:
      toc:
        depth: 2
      number_sections: true
vignette: >
  %\VignetteIndexEntry{Sample Size Given Desired Power}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
csl: apa.csl
---



# Introduction

This article is a brief illustration of how
to use `x_from_power()` and `power4test()`
from the package
[power4mome](https://sfcheung.github.io/power4mome/)
to do find by simulation the sample
size with power close to a desired level
to detect an effect, given the level of
population effect size.

The illustration will use an indirect
effect tested by Monte Carlo confidence
interval as an example, though the
procedure is similar for other tests
supported by `power4test()`.

# Prerequisite

Basic knowledge about fitting models
by `lavaan` is required. Readers are
also expected to know how to use
`power4test()`
(see this [get-started](power4mome.html)
for an introduction).

# Scope

This is a brief illustration. More
complicated scenarios and other features
of `x_from_power()` will be described in
other vignettes.

Some sections are repeated from other
vignettes to make this vignette
self-contained.

# Package

This illustration needs the following
package(s):


``` r
library(power4mome)
```

# Workflow

Three functions, along with some methods,
are sufficient for estimating the sample
size, given the desired power, along with
other factors such as the test,
the model, and population
values. This is the basic workflow:

1.  Specify the model syntax for the
    population model, in `lavaan`
    style, and set the population values of
    the model parameters.

3.  Call `power4test()` to examine the setup
    and the datasets generated. Repeat
    previous steps until the model is
    specified correctly.

4.  Call `power4test()` again, with the
    test to do specified, using an initial
    sample size.

5.  Call `rejection_rates()` to
    compute the power and verify that
    the test is setup correctly.

6.  Call `x_from_power()` to estimated
    the sample size required for the
    desired power.

# Mediation

Let's consider a simple mediation
model. We would like to estimate the
sample size required to detect
a mediation effect
by Monte Carlo confidence interval.

## Specify the Population Model

This is the model syntax


``` r
mod <-
"
m ~ x
y ~ m + x
"
```

Note that, even if we are going to
test mediation.
This will be taken care of by the
test functions, through the use of
the package
[`manymome`](https://sfcheung.github.io/manymome/)
[@cheung_manymome_2024].


## Specify The Population Values {#es_convention}

There are two approaches to do this:
using named vectors or lists, or using
a long string similar to `lavaan`
model syntax. The second approach is
demonstrated below.

Suppose we want to estimate the power
when:

- The path from `x` to `m` are "large"
  in strength.

- The path from `m` to `y` are "medium"
  in strength.

- The path from `x` to `m` are "small"
  in strength.

By default, `power4mome` use this convention
for regression path and correlation:^[
Users can explicitly specify the values
if this convention is not suitable.]

- Small: .10 (or -.10)

- Medium: .30 (or -.30)

- Large: .50 (or -.50)

All these values are for the standardized
solution (the so-called "betas").

The following string denotes the desired
values:


``` r
mod_es <-
"
m ~ x: l
y ~ m: m
y ~ x: s
"
```

Each line starts with a *tag*, which
is the parameter presented in `lavaan`
syntax. The tag ends with a colon, `:`.

After the colon is population value, which
can be:

- A word denoting the value. By default:

    - `s`: Small. (`-s` for small and negative.)

    - `m`: Medium. (`-m` for medium and negative.)

    - `l`: Large. (`-l` for large and negative.)

    - `nil`: Zero.

All regression coefficients and covariances,
if not specified, are set to zero.

## Call `power4test()` to Check the Model


``` r
out <- power4test(nrep = 2,
                  model = mod,
                  pop_es = mod_es,
                  n = 50000,
                  iseed = 1234)
```

These are the arguments used:

- `nrep`: The number of replications.
  In this stage, a small number can
  be used. It is more important to
  have a large sample size than to have
  more replications.

- `model`: The model syntax.

- `pop_es`: The string setting the
  population values.

- `n`: The sample size in each replications.
  In this stage, just for checking the
  model and the data generation, this
  number can be set to a large one unless
  the model is slow to fit when the
  sample size is large.

- `iseed`: If supplied, it is used to
  set the seed for the random number
  generator. It is advised to always set
  this to an arbitrary integer, to make
  the results reproducible.^[The functions
  used are `parallel::clusterSetRNGStream()`
  for parallel processing, and `set.seed()`
  for serial processing.]

The population values can be shown by
print this object:


``` r
print(out,
      data_long = TRUE)
#> 
#> ====================== Model Information ======================
#> 
#> == Model on Factors/Variables ==
#> 
#> m ~ x
#> y ~ m + x
#> 
#> == Model on Variables/Indicators ==
#> 
#> m ~ x
#> y ~ m + x
#> 
#> ====== Population Values ======
#> 
#> Regressions:
#>                    Population
#>   m ~                        
#>     x                 0.500  
#>   y ~                        
#>     m                 0.300  
#>     x                 0.100  
#> 
#> Variances:
#>                    Population
#>    .m                 0.750  
#>    .y                 0.870  
#>     x                 1.000  
#> 
#> ======================= Data Information =======================
#> 
#> Number of Replications:  2 
#> Sample Sizes:  50000 
#> 
#> ==== Descriptive Statistics ====
#> 
#>   vars     n mean sd skew kurtosis se
#> m    1 1e+05 0.00  1 0.01     0.03  0
#> y    2 1e+05 0.01  1 0.01     0.00  0
#> x    3 1e+05 0.00  1 0.01     0.01  0
#> 
#> ===== Parameter Estimates Based on All 2 Samples Combined =====
#> 
#> Total Sample Size: 100000 
#> 
#> ==== Standardized Estimates ====
#> 
#> Variances and error variances omitted.
#> 
#> Regressions:
#>                     est.std
#>   m ~                      
#>     x                 0.500
#>   y ~                      
#>     m                 0.295
#>     x                 0.102
#> 
#> 
#> ==================== Extra Element(s) Found ====================
#> 
#> - fit
#> 
#> === Element(s) of the First Dataset ===
#> 
#> ============ <fit> ============
#> 
#> lavaan 0.6-19 ended normally after 1 iteration
#> 
#>   Estimator                                         ML
#>   Optimization method                           NLMINB
#>   Number of model parameters                         5
#> 
#>   Number of observations                         50000
#> 
#> Model Test User Model:
#>                                                       
#>   Test statistic                                 0.000
#>   Degrees of freedom                                 0
```

The argument `data_long = TRUE` is
used to verify the simulation.

The population values for the regression
paths in the section
`Population Values` are what we specified.
So the model is specified correctly.

The section `Descriptive Statistics`, generated
by `psych::describe()`, shows basic
descriptive statistics for the observed
variables. As expected, they have means
close to zero and standard deviations
close to one, because the datasets were
generated using the standardized model.

The section `Parameter Estimates Based on`
shows the parameter estimates when the
population model is fitted to all the
datasets combined. When the total
sample size is large, these estimates
should be close to the population values.

By the default, the population model
will be fitted to each dataset, hence
the section `<fit>`. This section just
verifies that the population can be
fitted

The results show that population model
is the desired one. We can proceed to
the next stage

## Call `power4test()` to Do the Target Test {#med_power}

We can now do the simulation to estimate
power for an initial sample size, to
verify the test we wan to do.
A large number of datasets (e.g., 500)
of the target sample size are to be generated,
and then the target test will be conducted
in each of these datasets.

Suppose we would like to estimate the
power of using Monte Carlo confidence interval
to test the indirect effect from `x` to
`y` through `m`, when sample size is 50.
This is the call, based on the previous
one:


``` r
out <- power4test(nrep = 50,
                  model = mod,
                  pop_es = mod_es,
                  n = 50,
                  R = 2000,
                  ci_type = "mc",
                  test_fun = test_indirect_effect,
                  test_args = list(x = "x",
                                   m = "m",
                                   y = "y",
                                   mc_ci = TRUE),
                  iseed = 1234,
                  parallel = TRUE)
```

If our goal is to find a sample size for
a specific level of power, with sufficient
precision, we do not need a large number
of replications (`nrep`) in this stage.
We can use as few as 50. We can set the
target number of replications when
calling the function
`x_from_power()`. It will successively
increase `nrep` in the search, and
accepts a solution based on the target
number of replications.

These are the new arguments used:

- `R`: The number of replications used
  to generate the Monte Carlo simulated
  estimates, 2000 in this example.

- `ci_type`: The method used to
  generate estimates. Support Monte
  Carlo (`"mc"`) and nonparametric
  bootstrapping (`"boot"`).^[They
  are implemented by `manymome::do_mc()`
  and `manymome::do_boot()`, respectively.]
  Although bootstrapping is usually used
  to test an indirect effect, it is very
  slow to do `R` bootstrapping in `nrep`
  datasets (the model will be fitted
  `R * nrep` times). Therefore, it is
  preferable to use Monte Carlo to do
  the initial estimation.

- `test_fun`: The function to be used
  to do the test for each replication.
  Any function following a specific
  requirement can be used, and
  `power4mome` comes with several
  built-in function for some tests.
  The function `test_indirect_effect()`
  is used to test an indirect effect
  in the model.

- `test_args`: A named list of arguments
  to be supplied to `test_fun`.
  For `test_indirect_effect()`, it is
  a named list specifying the predictor
  (`x`), the mediator(s) (`m`), and
  the outcome (`y`). A path with any
  number of mediators can be supported.
  Please refer to the help page of
  `test_indirect_effect()`.^[The test
  is implemented by `manymome::indirect()`.]

- `parallel`: If the test to be conducted
  is slow, which is the case for
  test done by Monte Carlo or nonparametric
  bootstrapping confidence interval,
  it is advised to enable parallel
  processing by setting `parallel` to
  `TRUE`.^[The number of cores is determined
  automatically but can be set directly
  by the `ncores` argument.]

Note that the simulation can take some
time to run (3 to 4 minutes using 20 cores).
Progress will be printed when run in an
interactive session.

This is the default printout:


``` r
print(out,
      test_long = TRUE)
#> 
#> ====================== Model Information ======================
#> 
#> == Model on Factors/Variables ==
#> 
#> m ~ x
#> y ~ m + x
#> 
#> == Model on Variables/Indicators ==
#> 
#> m ~ x
#> y ~ m + x
#> 
#> ====== Population Values ======
#> 
#> Regressions:
#>                    Population
#>   m ~                        
#>     x                 0.500  
#>   y ~                        
#>     m                 0.300  
#>     x                 0.100  
#> 
#> Variances:
#>                    Population
#>    .m                 0.750  
#>    .y                 0.870  
#>     x                 1.000  
#> 
#> ======================= Data Information =======================
#> 
#> Number of Replications:  50 
#> Sample Sizes:  50 
#> 
#> Call print with 'data_long = TRUE' for further information.
#> 
#> ==================== Extra Element(s) Found ====================
#> 
#> - fit
#> - mc_out
#> 
#> === Element(s) of the First Dataset ===
#> 
#> ============ <fit> ============
#> 
#> lavaan 0.6-19 ended normally after 1 iteration
#> 
#>   Estimator                                         ML
#>   Optimization method                           NLMINB
#>   Number of model parameters                         5
#> 
#>   Number of observations                            50
#> 
#> Model Test User Model:
#>                                                       
#>   Test statistic                                 0.000
#>   Degrees of freedom                                 0
#> 
#> =========== <mc_out> ===========
#> 
#> 
#> == A 'mc_out' class object ==
#> 
#> Number of Monte Carlo replications: 2000 
#> 
#> 
#> =============== <test_indirect: x->m->y> ===============
#> 
#> Mean(s) across replication:
#>    est   cilo  cihi   sig
#>  0.139 -0.026 0.337 0.400
#> 
#> - The value 'sig' is the rejection rate.
#> - If the null hypothesis is false, this is the power.
#> - Number of valid replications for rejection rate: 50 
#> - Proportion of valid replications for rejection rate: 1.000
```

The argument `test_long = TRUE` is added
to verify the test we set up.

As shown above, the setup is correct.
We can now call `x_from_power()` to
do the search.

## Call `x_from_power()` to Estimate the Sample Size

This is a simplified description of
how `x_from_power()` works:

- It rerun the simulation and test
  in an output of `power4test()`
  for different sample sizes, and then
  estimate the power levels for each
  of them.

- It will try to estimate the relation
  between the power and the sample size,
  and select the next sample size(s) to
  try.

- It will adopt a sample size as the
  solution if (a) the confidence interval
  of the estimated power includes the
  target power (default level 95%), and (b)
  the number of replications used
  in the estimation is the target one
  (to ensure the standard error is of
  the desired level).


``` r
out_n <- x_from_power(out,
                      x = "n",
                      target_power = .80,
                      final_nrep = 400,
                      seed = 1234)
```

The argument used above:

- `x`: What we want to find, `"n"`
  stands for sample size.

- `target_power`: The target power.
  Default is .80.

- `final_nrep`: The number of replications
  desired in the solution. When using
  the normal approximation to form the
  95% confidence interval for a sample
  proportion (power in this case). For
  `nrep = 400`, the 95% confidence limits
  for a power of .80 are about .04 below
  and above .80. This should be precise
  enough for estimating the sample size
  required.

- `seed`: To make the search reproducible,
  if possible, set this seed to an
  integer.

## Examine the Output

This is the basic output:


``` r
out_n
#> Call:
#> x_from_power(object = out, x = "n", target_power = 0.8, final_nrep = 400, 
#>     seed = 1234)
#> Predictor (x): Sample Size 
#> - Target Power: 0.800 
#> - Final Value: 103 
#> - Final Estimated Power: 0.782 
#> Call `summary()` for detailed results.
```

The estimated sample size to have a power
close to .80 power to detect the indirect effect
by Monte Carlo interval is
103. The estimated power
based on simulation is
0.782.

To obtain a more detailed results for
the search, we can use the `summary()`
method:


``` r
summary(out_n)
#> 
#> ====== x_from_power Results ======
#> 
#> Call:
#> x_from_power(object = out, x = "n", target_power = 0.8, final_nrep = 400, 
#>     seed = 1234)
#> Predictor (x): Sample Size 
#> 
#> - Target Power: 0.800 
#> 
#> === Major Results ===
#> 
#> - Final Value: 103 
#> - Final Estimated Power: 0.782 
#> - Confidence Interval: [0.742; 0.823]
#> - Level of confidence: 95.0%
#> - Based on 400 replications.
#> 
#> === Technical Information ===
#> 
#> - The range of values explored: 50 to 131 
#> - Time spent in the search: 2.469 mins 
#> - The final crude model for the power-predictor relation:
#> 
#> Model Type: Logistic Regression 
#> 
#> Call:
#> power_curve(object = by_x_i, formula = power_model, start = start, 
#>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args, 
#>     nls_control = nls_control, verbose = progress)
#> 
#> Predictor: n (Sample Size)
#> 
#> Model:
#> 
#> Call:  stats::glm(formula = reject ~ x, family = "binomial", data = reject1)
#> 
#> Coefficients:
#> (Intercept)            x  
#>    -1.75189      0.03008  
#> 
#> Degrees of Freedom: 149 Total (i.e. Null);  148 Residual
#> Null Deviance:	    200.2 
#> Residual Deviance: 187.7 	AIC: 191.7
#> 
#> - Detailed Results:
#> 
#>     n                   test test_label   p.v reject r.cilo r.cihi
#> 1  50 test_indirect: x->m->y       Test 1.000  0.400  0.264  0.536
#> 2  75 test_indirect: x->m->y       Test 1.000  0.700  0.573  0.827
#> 3  81 test_indirect: x->m->y       Test 1.000  0.682  0.637  0.728
#> 4  97 test_indirect: x->m->y       Test 1.000  0.786  0.678  0.893
#> 5 100 test_indirect: x->m->y       Test 1.000  0.740  0.618  0.862
#> 6 103 test_indirect: x->m->y       Test 1.000  0.782  0.742  0.823
#> 7 104 test_indirect: x->m->y       Test 1.000  0.861  0.812  0.910
#> 8 113 test_indirect: x->m->y       Test 1.000  0.792  0.683  0.902
#> 9 131 test_indirect: x->m->y       Test 1.000  0.882  0.851  0.914
#> Notes:
#> - n: The sample size in a trial.
#> - p.v: The proportion of valid replications.
#> - reject: The proportion of 'significant' replications, that is, the
#>   rejection rate.If the null hypothesis is true, this is the Type I
#>   error rate. If the null hypothesis is false, this is the power.
#> - r.cilo,r.cihi: The confidence interval of the rejection rate, based
#>   on normal approximation.
#> - Refer to the tests for the meanings of other columns.
```

It reports the 95% confidence interval
of the estimated power,
[0.742; 0.823].

It also reports major technical
information regarding
the search, such as the range of
sample sizes tried, the time spent,
and the table with all the sample sizes
examined, along with the estimated
power levels and confidence intervals.

It also prints the model, the "power curve",
used to estimate
the relation between the power and the
sample size. Note that this is only
a crude model intended only for the
values of sample size examined. It is
not intended to estimate power for
sample sizes outside the range studied.

Even though the model is a crude one,
it can still give a rough idea about
the relation. A simple plot can be
requested by `plot()`:


``` r
plot(out_n)
```

<div class="figure" style="text-align: center">
<img src="x_from_power_for_n_plot-1.png" alt="The Power Curve"  />
<p class="caption">The Power Curve</p>
</div>

The black line is the plot of the
sample sizes studied, along with the
estimated power levels and the 95%
confidence intervals. The intervals
vary in width because of different number
of replications.

The red line is the plot based on the
model (a logistic model in this case),
along the range of sample sizes examined.

# Advanced Features

This brief illustration only cover
basic features of `x_from_power()`.
There are other ways to customize the
search, such as the range of sample
sizes to examine (the default is 50 to 2000),
the level of confidence for the
confidence interval, and the number of
trials (10 by default). Please refer
to the help page of `x_from_power()`
for these and other options.

# References
