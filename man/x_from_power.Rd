% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/x_from_power.R
\name{x_from_power}
\alias{x_from_power}
\alias{print.x_from_power}
\title{Sample Size and Effect Size Determination}
\usage{
x_from_power(
  object,
  x,
  pop_es_name = NULL,
  target_power = 0.8,
  xs_per_trial = 3,
  ci_level = 0.95,
  power_min = 0.01,
  power_max = 0.9,
  x_interval = switch(x, n = c(50, 2000), es = c(0, 0.7)),
  extendInt = NULL,
  progress = TRUE,
  simulation_progress = TRUE,
  max_trials = 10,
  final_nrep = 500,
  final_R = 1000,
  nrep_steps = 1,
  seed = NULL,
  x_include_interval = FALSE,
  power_model = NULL,
  start = NULL,
  lower_bound = NULL,
  upper_bound = NULL,
  nls_control = list(),
  nls_args = list(),
  save_sim_all = FALSE
)

\method{print}{x_from_power}(x, digits = 3, ...)
}
\arguments{
\item{object}{A \code{power4test} object,
which is the output of \code{\link[=power4test]{power4test()}}.}

\item{x}{The output of
\code{\link[=x_from_power]{x_from_power()}}, the
\code{print} method of
an \code{x_from_power} object,
which is the output of
\code{\link[=x_from_power]{x_from_power()}}.}

\item{pop_es_name}{The name of the
parameter. Required if \code{x} is \code{"es"}.
See the help page
of \code{\link[=ptable_pop]{ptable_pop()}} on the names for
the argument \code{pop_es}.}

\item{target_power}{The target power,
a value greater than 0 and less than
one.}

\item{xs_per_trial}{The initial number
of values (sample sizes or population
values) to consider in each
trial. Should be an integer at least
\enumerate{
\item Rounded
up if not an integer.
}}

\item{ci_level}{The level of confidence
of the confidence intervals computed
for the estimated power. Default is
.95.}

\item{power_min, power_max}{The minimum
and maximum values, respectively,
of power
when determining the values to
try in each trail. Default is .01.}

\item{x_interval}{A vector of
two values, the minimum value
and the maximum sample values, in
the search for the values
(sample sizes or population values).}

\item{extendInt}{Whether \code{x_interval}
can be expanded when estimating the
the values to try. The value will
be passed to the argument of the
same name in \code{\link[stats:uniroot]{stats::uniroot()}}.
If \code{x} is \code{"n"}, then the default
value is \code{"upX"}.
That is, a value higher than
the maximum in \code{x_interval} is
allowed, if predicted by the tentative
model. Otherwise, the default value
is \code{"no"}. See the help page of
\code{\link[stats:uniroot]{stats::uniroot()}} for further
information.}

\item{progress}{Logical. Whether
the searching progress is reported.}

\item{simulation_progress}{Logical.
Whether the progress in each call
to \code{\link[=power4test]{power4test()}} or \code{\link[=power4test_by_n]{power4test_by_n()}}
is shown. To be passed to
the \code{progress} argument of these two
functions.}

\item{max_trials}{The maximum number
of trials in searching the value
with the target power. Rounded
up if not an integer.}

\item{final_nrep}{The number of
replications in the final stage,
also the maximum number of replications
in each call to \code{\link[=power4test]{power4test()}},
\code{\link[=power4test_by_n]{power4test_by_n()}}, or
\code{\link[=power4test_by_es]{power4test_by_es()}}.}

\item{final_R}{The number of
Monte Carlo simulation or
bootstrapping samples in the final
stage. The \code{R} in calling
\code{\link[=power4test]{power4test()}} or \code{\link[=power4test_by_n]{power4test_by_n()}}
will be stepped up to this value
when approaching to the target
power. Do not need to be very large
because the goal is to estimate
power by replications, not for high
precision in one single replication.}

\item{nrep_steps}{How many steps
the number of replications will be
increased to \code{final_nrep}, if the
initial number of replications
(\code{nrep} in \code{\link[=power4test]{power4test()}}) is
less than \code{final_nrep}. The number
of replications will be successively
increased by this number of steps
to increase the precision in estimating
the power. Should be at least 1.
Increasing this number will result
in more trials and take longer to
run, but will try more values.
Rounded up if not an integer.}

\item{seed}{If not \code{NULL}, \code{\link[=set.seed]{set.seed()}}
will be used to make the process
reproducible. This is not always
possible if many stages of
parallel processing is involved.}

\item{x_include_interval}{Logical.
Whether \code{x_interval} is mandatory
to be included in the values
to be searched.}

\item{power_model}{The nonlinear
model to be used when estimating
the relation between power and
sample size. Should be a formula
acceptable by \code{\link[stats:nls]{stats::nls()}},
with \code{reject} on the left-hand side,
and \code{x} (stands for sample size)
on the right-hand
side, with one or more parameters.
Can also be set to a list of
models.
Users rarely need to change the
default value. If \code{NULL}, the default,
then the default model(s) will be
determined by \code{\link[=power_curve]{power_curve()}}.}

\item{start}{A named numeric vector
of the starting values for \code{power_model}
when fitted by \code{\link[stats:nls]{stats::nls()}}. If
\code{power_model} is a list, this should
be a list of the same length.
Users rarely need to change the
default values.}

\item{lower_bound}{A named numeric vector
of the lower bounds for parameters
in \code{power_model}
when fitted by \code{\link[stats:nls]{stats::nls()}}. If
\code{power_model} is a list, this should
be a list of the same length.
Users rarely need to change the
default values.}

\item{upper_bound}{A named numeric vector
of the upper bounds for parameters
in \code{power_model}
when fitted by \code{\link[stats:nls]{stats::nls()}}. If
\code{power_model} is a list, this should
be a list of the same length.
Users rarely need to change the
default values.}

\item{nls_control}{A named list of
arguments to be passed the \code{control}
argument of \code{\link[stats:nls]{stats::nls()}} when
estimating the relation between
power and sample size. The values will
override internal default values,
and also override \code{nls_args}.}

\item{nls_args}{A named list of
arguments to be used when calling
\code{\link[stats:nls]{stats::nls()}}. Used to override
internal default, such as the
algorithm (default is \code{"port"}).
Used with cautions.}

\item{save_sim_all}{If \code{FALSE},
the default, the data in each
\code{power4test} object for each
value of \code{x} is not saved,
to reduce the size of the output.
If set to \code{TRUE}, the size of the
output can be very large in size.}

\item{digits}{The number of digits
after the decimal when printing
the results.}

\item{...}{Optional arguments.
Not used for now.}
}
\value{
The function \code{\link[=x_from_power]{x_from_power()}}
returns a \code{x_from_power} object,
which is a list with the following
elements:
\itemize{
\item \code{power4test_trials}: The output of
\code{\link[=power4test_by_n]{power4test_by_n()}} for all sample
sizes examined, or of
\code{\link[=power4test_by_es]{power4test_by_es()}} for all
population values of the selected
parameter examined.
\item \code{rejection_rates}: The output of
\code{\link[=rejection_rates]{rejection_rates()}}.
\item \code{x_tried}: The sample sizes or
population values
examined.
\item \code{power_tried}: The estimated
rejection rates for all the values
examined.
\item \code{x_final}: The sample size or
population values in the
solution. \code{NA} if solution not found.
\item \code{power_final}: The estimated power
of the value in the solution.
\code{NA} if solution not found.
\item \code{i_final}: The position of the
solution in \code{power4test_trials}.
\code{NA} if solution not found.
\item \code{ci_final}: The confidence interval
of the estimated power in the solution.
\code{NA} if solution not found.
\item \code{ci_level}: The level of confidence
of \code{ci_final}.
\item \code{nrep_final}: The number of
replications (\code{nrep}) when estimating
the power in the solution.
\item \code{power_curve}: The output of
\code{\link[=power_curve]{power_curve()}} when estimating the
power curve.
\item \code{target_power}: The requested
target power.
\item \code{power_tolerance}: The allowed
difference between the solution's
estimated power and the target
power. Determined by the number
of replications and the level of
confidence of the confidence intervals.
\item \code{x_estimated}: The value
(sample size or population value)
with the target power, estimated by
\code{power_curve}. This is used, when
solution not found, to determine the
range of the values to search when
calling the function again.
\item \code{start}: The time and date when
the process started.
\item \code{end}: The time and date when the
process ended.
\item \code{time_spent}: The time spent in
doing the search.
\item \code{args}: A named list of the arguments
of \code{\link[=x_from_power]{x_from_power()}} used in the search.
\item \code{call}: The call when this function
is called.
}

The \code{print}-method of \code{x_from_power}
objects returns the object \code{x}
invisibly.
It is called for its side effect.
}
\description{
It searches by simulation
the sample size (given other factors,
such as effect sizes) or effect size
(given other factors, such as sample
size) with power to
detect an effect close to a target
value.

The \code{print} method only print
basic information. Call
\code{\link[=summary.x_from_power]{summary.x_from_power()}} and its
\code{print} method for detailed output.
}
\details{
This is how to use this function:
\itemize{
\item Specify the model by \code{\link[=power4test]{power4test()}},
with \code{do_the_test = FALSE}, and set
the magnitude of the effect sizes
to the minimum levels to detect.
\item Add the test using \code{\link[=power4test]{power4test()}}
using \code{test_fun} and \code{test_args}
(see the help page of \code{\link[=power4test]{power4test()}}
for details). Run it on the
starting sample size or
effect size.
\item Call \code{\link[=x_from_power]{x_from_power()}} on the output
of \code{\link[=power4test]{power4test()}} returned from
the previous step. This
function will iteratively repeat
the analysis on either other sample
sizes, or other values for a
selected population values (the
effect sizes),
trying to find a value (a sample
size, or a population value of
the selected parameter) with
a power level close enough to the
target power.
}

Usually, the default values of the
arguments should be sufficient.

The results can be viewed using
\code{\link[=summary]{summary()}}, and the output has
a \code{\link[=plot.x_from_power]{plot.x_from_power()}} method to
plot the relation between power and
sample size for the sample sizes
examined.
\subsection{Technical Details}{

(TODO: To draft)
}
}
\examples{

# TODO:
# - Update the example

mod <-
"
m ~ a*x
y ~ b*m + x
ab := a * b
"

mod_es <- c("y ~ m" = "l",
            "m ~ x" = "m",
            "y ~ x" = "n")

sim_only <- power4test(nrep = 10,
                       model = mod,
                       pop_es = mod_es,
                       n = 100,
                       do_the_test = FALSE,
                       iseed = 1234)

test_out <- power4test(object = sim_only,
                       test_fun = test_parameters,
                       test_args = list(pars = "ab"))

# In real analysis, to have more stable results:
# - Use a larger final_nrep (e.g., 500).
# - Use the default xs_per_trial of 3, or just remove it.

# If the default values are OK, this call is sufficient:
# power_vs_n <- x_from_power(test_out,
#                            x = "n",
#                            target_power = .80,
#                            seed = 4567)
power_vs_n <- x_from_power(test_out,
                           x = "n",
                           progress = TRUE,
                           target_power = .80,
                           final_nrep = 10,
                           xs_per_trial = 1,
                           nrep_steps = 1,
                           max_trials = 1,
                           seed = 4567)
summary(power_vs_n)
plot(power_vs_n)

}
\seealso{
\code{\link[=power4test]{power4test()}}, \code{\link[=power4test_by_n]{power4test_by_n()}},
and \code{\link[=power4test_by_es]{power4test_by_es()}}.
}
