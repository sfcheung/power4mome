% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power4test.R
\name{power4test}
\alias{power4test}
\title{Estimate the Power of a Test}
\usage{
power4test(
  nrep = 10,
  model,
  pop_es,
  n,
  number_of_indicators = NULL,
  reliability = NULL,
  fit_model_args = list(),
  R = 100,
  gen_mc_args = list(),
  test_fun = NULL,
  test_args = list(),
  map_names = c(fit = "fit"),
  results_fun = NULL,
  results_args = list(),
  test_name = NULL,
  test_note = NULL,
  do_the_test = TRUE,
  sim_all = NULL,
  iseed = NULL,
  parallel = FALSE,
  progress = FALSE,
  ncores = max(1, parallel::detectCores(logical = FALSE) - 1)
)
}
\arguments{
\item{nrep}{The number of replications
to generate the simulated datasets.
Default is 10.}

\item{model}{The \code{lavaan} model
syntax of the population model.
Required.}

\item{pop_es}{The character to
specify population effect sizes.
See 'Details' on how to set the
effect sizes for this argument.
Required.}

\item{n}{The sample size for each
dataset. Default is 100.}

\item{number_of_indicators}{A named
vector to specify the number of
indicators for each factors. See
'Details' on how to set this
argument. Default is \code{NULL} and all
variables in the model syntax are
observed variables.}

\item{reliability}{A named vector
to set the reliability coefficient
of each set of indicators. Default
is \code{NULL}.}

\item{fit_model_args}{A list of the
arguments to be passed to
\code{\link[lavaan:sem]{lavaan::sem()}} when fitting the
model.
Should be a named argument
with names being the names of the
arguments.}

\item{R}{The number of replications
to generate the Monte Carlo estimates
for each fit output. No Monte Carlo
estimates will be generated if \code{R}
is set to \code{NULL}.}

\item{gen_mc_args}{A list of
arguments to be passed to
\code{\link[manymome:do_mc]{manymome::do_mc()}} when generating
the Monte Carlo estimates.
Should be a named argument
with names being the names of the
arguments.}

\item{test_fun}{A function to do the
test. See the help page of
\code{\link[=do_test]{do_test()}} for the requirements of
this function.}

\item{test_args}{A list of arguments
to be passed to the \code{test_fun}
function. Default is \code{list()}.}

\item{map_names}{A named character
vector specifying how the content of
the element \code{extra} in
each replication of \code{sim_all} map
to the argument of \code{test_fun}.
Default is \code{c(fit = "fit")},
indicating that the element \code{fit}
in the element \code{extra} is set to
the argument \code{fit} of \code{test_fun}.
That is, for the first replication,
\code{fit = sim_out[[1]]$extra$fit} when
calling \code{test_fun}.}

\item{results_fun}{The function to be
used to extract the test results.
See \code{Details} for the requirements
of this function. Default is \code{NULL},
assuming that the output of
\code{test_fun} can be used directly.}

\item{results_args}{A list of
arguments to be passed to the
\code{results_fun} function. Default is
\code{list()}.}

\item{test_name}{String. The name
of the test. Default is \code{NULL},
and the name will be created from
\code{test_fun}. Note that if \code{sim_out}
is a \code{power4test} object and already
has a test of this name stored, it
will be replaced by the new results}

\item{test_note}{String. An optional
note for the test, stored in the
attribute \code{test_note} of the output
of \code{\link[=do_test]{do_test()}}. Default is \code{NULL}.}

\item{do_the_test}{If \code{TRUE},
\code{\link[=do_test]{do_test()}} will be called to do the
specified test in the fit output of
each dataset.}

\item{sim_all}{If set to either a
\code{sim_out} object (the output of
\code{\link[=sim_out]{sim_out()}} or a \code{power4test} object
(the output of \code{\link[=power4test]{power4test()}}), the
stored datasets and fit outputs will
be used for doing the test.}

\item{iseed}{The seed for the random
number generator. Default is \code{NULL}
and the seed is not changed. This
seed will be set only once, when
calling \code{\link[=sim_data]{sim_data()}}.}

\item{parallel}{If \code{TRUE}, parallel
processing will be used when calling
other functions, if appropriate.
Default is \code{FALSE}.}

\item{progress}{If \code{TRUE}, the progress
of each step will be displayed.
Default is `FALSE.}

\item{ncores}{The number of CPU
cores to use if parallel processing
is used.}
}
\value{
An object of the class \code{power4test},
which is a list of with two elements:
\itemize{
\item \code{sim_all}: The output of \code{\link[=sim_out]{sim_out()}}.
\item \code{test_all}: A named list of the
output of \code{\link[=do_test]{do_test()}}. The names
are the values of \code{test_name}.
This list can have more than one
test because a call to
\code{\link[=power4test]{power4test()}} can add new tests
to a \code{power4mome} object.
}
}
\description{
An all-in-one function
that receives a model specification,
generate datasets, fits a model, does
the target test, and returns the test
results.
}
\details{
It is an all-in-one function for
estimating the power of a test for
a model, given the sample size
and effect sizes.

This is the workflow:
\itemize{
\item If an object with model and data
already generated is supplied
through \code{sim_all}, such as the
output of \code{\link[=sim_out]{sim_out()}} or of
\code{\link[=power4test]{power4test()}} with \code{do_the_test}
set to \code{FALSE}, the following steps
will be skipped and go directly to
doing the test.
\itemize{
\item Call \code{\link[=sim_data]{sim_data()}} to determine
the population model and
generate the datasets.
\item Call \code{\link[=fit_model]{fit_model()}} to fit the
model to each of the datasets.
\item If \code{R} is not \code{NULL}, call
\code{\link[=gen_mc]{gen_mc()}} to generate Monte
Carlo estimates using
\code{\link[manymome:do_mc]{manymome::do_mc()}}.
\item Merge the results into a
\code{sim_out} object by calling
\code{\link[=sim_out]{sim_out()}}.
\item If \code{do_the_test} is \code{FALSE},
skip the reaming steps and
return a \code{power4test} object,
which contains only the
generated and optionally the
Monte Carlo estimates.
}
\item If \code{do_the_test} is \code{TRUE}, do
the test.
\itemize{
\item \code{\link[=do_test]{do_test()}} will be called to do
the test in the fit output of
each datasets.
}
\item Return a \code{power4test} object which
include the output of \code{sim_out}
and, if \code{do_the_test} is \code{TRUE},
the output of \code{\link[=do_test]{do_test()}}.
}

This function is to be used when
users are interested only in the
power of a specific test on a
particular aspect of the model, such
as a parameter, given a specific
effect sizes and sample sizes.
}
\examples{


model_simple_med <-
"
m ~ a*x
y ~ b*m + x
ab := a * b
"

model_simple_med_es <- c("y ~ m" = "l",
                         "m ~ x" = "m",
                         "y ~ x" = "n")

test_ab <- function(object,
                    alpha = .05) {
  est <- lavaan::parameterEstimates(object)
  i <- match("ab", est$lhs)
  out <- c(est = est[i, "est"],
           cilo = est[i, "ci.lower"],
           cihi = est[i, "ci.upper"],
           sig = as.numeric(est[i, "pvalue"] < alpha))
  out
}

ab_results <- function(object) {
  object
}

power_all_test_only_par <- power4test(nrep = 50,
                                      model = model_simple_med,
                                      pop_es = model_simple_med_es,
                                      n = 100,
                                      fit_model_args = list(estimator = "ML"),
                                      R = NULL,
                                      test_fun = test_ab,
                                      map_names = c(object = "fit"),
                                      results_fun = ab_results,
                                      parallel = FALSE,
                                      progress = TRUE)
names(power_all_test_only_par$test_all)
test_results_all <- sapply(power_all_test_only_par$test_all$test_ab,
                           function(xx) xx$test_results)
test_results_all <- as.data.frame(t(test_results_all))
colMeans(test_results_all, na.rm = TRUE)

}
