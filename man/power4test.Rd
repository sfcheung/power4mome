% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power4test.R
\name{power4test}
\alias{power4test}
\alias{print.power4test}
\title{Estimate the Power of a Test}
\usage{
power4test(
  object = NULL,
  nrep = NULL,
  ptable = NULL,
  model = NULL,
  pop_es = NULL,
  n = NULL,
  number_of_indicators = NULL,
  reliability = NULL,
  x_fun = list(),
  fit_model_args = list(),
  R = NULL,
  ci_type = "mc",
  gen_mc_args = list(),
  gen_boot_args = list(),
  test_fun = NULL,
  test_args = list(),
  map_names = c(fit = "fit"),
  results_fun = NULL,
  results_args = list(),
  test_name = NULL,
  test_note = NULL,
  do_the_test = TRUE,
  sim_all = NULL,
  iseed = NULL,
  parallel = FALSE,
  progress = TRUE,
  ncores = max(1, parallel::detectCores(logical = FALSE) - 1),
  es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5),
  es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15)
)

\method{print}{power4test}(
  x,
  what = c("data", "test"),
  digits = 3,
  digits_descriptive = 2,
  data_long = FALSE,
  test_long = FALSE,
  fit_to_all_args = list(),
  ...
)
}
\arguments{
\item{object}{Optional. If set to a
\code{power4test} object, it will be
updated using the value(s) in \code{n},
\code{pop_es}, and/or \code{nrep}. Default is \code{NULL}.}

\item{nrep}{The number of replications
to generate the simulated datasets.
Default is \code{NULL}. Must be set when
called to create a \code{power4test}
object.}

\item{ptable}{The output of
\code{\link[=ptable_pop]{ptable_pop()}}, which is a
\code{ptable_pop} object, representing the
population model. If \code{NULL}, the
default, \code{\link[=ptable_pop]{ptable_pop()}} will be
called to generate the \code{ptable_pop}
object using \code{model} and \code{pop_es}.}

\item{model}{The \code{lavaan} model
syntax of the population model.
Required. Ignored if \code{ptable} is
specified. See 'Details' of
\code{\link[=ptable_pop]{ptable_pop()}} on how to use it for
models with latent factors
and indicators. Ignored if \code{ptable} is
specified.}

\item{pop_es}{The character vector to
specify population effect sizes. See
'Details' of \code{\link[=ptable_pop]{ptable_pop()}} on how to
set the effect sizes for this
argument. Ignored if \code{ptable} is
specified.}

\item{n}{The sample size for each
dataset. Default is 100.}

\item{number_of_indicators}{A named
vector to specify the number of
indicators for each factors. See
'Details' of \code{\link[=sim_data]{sim_data()}} on how to set this
argument. Default is \code{NULL} and all
variables in the model syntax are
observed variables.}

\item{reliability}{A named vector
to set the reliability coefficient
of each set of indicators. Default
is \code{NULL}. See 'Details' of
\code{\link[=sim_data]{sim_data()}} on how to set this
argument.}

\item{x_fun}{The function(s) used to
generate the exogenous variables. If
not supplied, or set to \code{list()}, the
default, the variables are generated
from a multivariate normal
distribution. See 'Details' of
\code{\link[=sim_data]{sim_data()}} on how to use this
argument.}

\item{fit_model_args}{A list of the
arguments to be passed to \code{\link[=fit_model]{fit_model()}}
when fitting the
model.
Should be a named argument
with names being the names of the
arguments.}

\item{R}{The number of replications
to generate the Monte Carlo or
bootstrapping estimates
for each fit output. No Monte Carlo
nor bootstrapping
estimates will be generated if \code{R}
is set to \code{NULL}.}

\item{ci_type}{The type of
simulation-based confidence
intervals to use. Can be either
\code{"mc"} for Monte Carlo method
(the default) or \code{"boot"} for
nonparametric bootstrapping method.
See \code{\link[=sim_data]{sim_data()}} on the details.}

\item{gen_mc_args}{A list of
arguments to be passed to
\code{\link[manymome:do_mc]{manymome::do_mc()}} when generating
the Monte Carlo estimates.
Should be a named argument
with names being the names of the
arguments. Used only if
\code{ci_type} is \verb{"mc".}}

\item{gen_boot_args}{A list of
arguments to be passed to
\code{\link[manymome:do_boot]{manymome::do_boot()}} when generating
the bootstrap estimates.
Should be a named argument
with names being the names of the
arguments. Used only if
\code{ci_type} is `"boot".}

\item{test_fun}{A function to do the
test. See the help page of
\code{\link[=do_test]{do_test()}} for the requirements of
this function.}

\item{test_args}{A list of arguments
to be passed to the \code{test_fun}
function. Default is \code{list()}.}

\item{map_names}{A named character
vector specifying how the content of
the element \code{extra} in
each replication of \code{sim_all} map
to the argument of \code{test_fun}.
Default is \code{c(fit = "fit")},
indicating that the element \code{fit}
in the element \code{extra} is set to
the argument \code{fit} of \code{test_fun}.
That is, for the first replication,
\code{fit = sim_out[[1]]$extra$fit} when
calling \code{test_fun}.}

\item{results_fun}{The function to be
used to extract the test results.
See \code{Details} of \code{\link[=do_test]{do_test()}} for the requirements
of this function. Default is \code{NULL},
assuming that the output of
\code{test_fun} can be used directly.}

\item{results_args}{A list of
arguments to be passed to the
\code{results_fun} function. Default is
\code{list()}.}

\item{test_name}{String. The name
of the test. Default is \code{NULL},
and the name will be created from
\code{test_fun}. Note that if \code{sim_out}
is a \code{power4test} object and already
has a test of this name stored, it
will be replaced by the new results.}

\item{test_note}{String. An optional
note for the test, stored in the
attribute \code{test_note} of the output
of \code{\link[=do_test]{do_test()}}. Default is \code{NULL}.}

\item{do_the_test}{If \code{TRUE},
\code{\link[=do_test]{do_test()}} will be called to do the
specified test in the fit output of
each dataset.}

\item{sim_all}{If set to either a
\code{sim_out} object (the output of
\code{\link[=sim_out]{sim_out()}} or a \code{power4test} object
(the output of \code{\link[=power4test]{power4test()}}), the
stored datasets and fit outputs will
be used for doing the test.}

\item{iseed}{The seed for the random
number generator. Default is \code{NULL}
and the seed is not changed. This
seed will be set only once, when
calling \code{\link[=sim_data]{sim_data()}}.}

\item{parallel}{If \code{TRUE}, parallel
processing will be used when calling
other functions, if appropriate.
Default is \code{FALSE}.}

\item{progress}{If \code{TRUE}, the progress
of each step will be displayed.
Default is `FALSE.}

\item{ncores}{The number of CPU
cores to use if parallel processing
is used.}

\item{es1}{A named vector to set the
values for each label of the effect
size of correlations and regression
paths.
Default is \code{c("n" = .00, "nil" = .00, "s" = .10, "m" = .30, "l" = .50)}.
Used only if \code{pop_es} is a named
vector. See \code{\link[=ptable_pop]{ptable_pop()}} for
further information.}

\item{es2}{A named vector to set the
values for each label of the effect
size of product term.
Default is \code{c("n" = .00, "nil" = .00, "s" = .05, "m" = .10, "l" = .15)}.
Used only if \code{pop_es} is a named
vector. See \code{\link[=ptable_pop]{ptable_pop()}} for
further information.}

\item{x}{The object
to be printed.}

\item{what}{A string vector of
what to print, \code{"data"} for
simulated data and \code{"test"} for
stored test(s). Default is
\code{c("data", "test")}.}

\item{digits}{The numbers of digits
displayed after the decimal.}

\item{digits_descriptive}{The
number of digits displayed after
the decimal for the descriptive
statistics table.}

\item{data_long}{If \code{TRUE}, detailed
results will be printed when printing
the simulated data.}

\item{test_long}{If \code{TRUE}, detailed
results will be printed when printing
test(s).}

\item{fit_to_all_args}{A named list
of arguments to be passed to
\code{\link[lavaan:sem]{lavaan::sem()}} when the model is
fitted to a sample combined from}

\item{...}{Optional arguments to
be passed to other print methods.}
}
\value{
An object of the class \code{power4test},
which is a list of with two elements:
\itemize{
\item \code{sim_all}: The output of \code{\link[=sim_out]{sim_out()}}.
\item \code{test_all}: A named list of the
output of \code{\link[=do_test]{do_test()}}. The names
are the values of \code{test_name}.
This list can have more than one
test because a call to
\code{\link[=power4test]{power4test()}} can add new tests
to a \code{power4test} object.
}

The \code{print} method of \code{power4test}
returns \code{x} invisibly. Called for
its side effect.
}
\description{
An all-in-one function
that receives a model specification,
generates datasets, fits a model, does
the target test, and returns the test
results.
}
\details{
It is an all-in-one function for
estimating the power of a test for
a model, given the sample size
and effect sizes.

This is the workflow:
\itemize{
\item If an object with model and data
already generated is supplied
through \code{sim_all}, such as the
output of \code{\link[=sim_out]{sim_out()}} or of
\code{\link[=power4test]{power4test()}} with \code{do_the_test}
set to \code{FALSE}, the following steps
will be skipped and go directly to
doing the test.
\itemize{
\item Call \code{\link[=sim_data]{sim_data()}} to determine
the population model and
generate the datasets.
\item Call \code{\link[=fit_model]{fit_model()}} to fit the
model to each of the datasets.
\item If \code{R} is not \code{NULL} and
\code{ci_type = "mc"}, call
\code{\link[=gen_mc]{gen_mc()}} to generate Monte
Carlo estimates using
\code{\link[manymome:do_mc]{manymome::do_mc()}}.
\item If \code{R} is not \code{NULL} and
\code{ci_type = "boot"}, call
\code{\link[=gen_boot]{gen_boot()}} to generate
bootstrap estimates using
\code{\link[manymome:do_boot]{manymome::do_boot()}}.
\item Merge the results into a
\code{sim_out} object by calling
\code{\link[=sim_out]{sim_out()}}.
\item If \code{do_the_test} is \code{FALSE},
skip the remaining steps and
return a \code{power4test} object,
which contains only the data
generated and optionally the
Monte Carlo or bootstrap
estimates.
}
\item If \code{do_the_test} is \code{TRUE}, do
the test.
\itemize{
\item \code{\link[=do_test]{do_test()}} will be called to do
the test in the fit output of
each datasets.
}
\item Return a \code{power4test} object which
include the output of \code{sim_out}
and, if \code{do_the_test} is \code{TRUE},
the output of \code{\link[=do_test]{do_test()}}.
}

This function is to be used when
users are interested only in the
power of one or several tests on a
particular aspect of the model, such
as a parameter, given a specific
effect sizes and sample sizes.
\subsection{Updating a Condition}{

This function can also be used to
update a condition when only some
selected aspects changed. For example,
without calling this function with
all the arguments set just to change
the sample size, it can be called
by supplying an existing
\code{power4test} object and set only
\code{n} to a new sample size. The data
and the tests will be updated
automatically.
}

\subsection{Multiple Models}{

More than one model can be fitted to
each replication. This is done
by setting \code{fit_model_args} to
a named list. The names are the names
used to identify the models, and
each element is a list of named
list of arguments for a model.

For example:

\preformatted{
fit_model_args = list(fit = list(),
                      fit2 = list(model = mod2),
                      fit3 = list(model = mod3))
}

Three models will be fitted. The
first model is the model ued to
generate the data, named \code{"fit"}.
The second and first models are
named \code{"fit2"} and \code{"fit3"},
respectively, with \code{"fit2"} fitted
with \code{model = mod2} and \code{"fit3"}
fitted with \code{model = mod3}.

If Monte Carlos or bootstrap estimates
are to be generated, they will be
generated for each model, using the
values for their arguments.
}
}
\examples{

model_simple_med <-
"
m ~ a * x
y ~ b * m + x
ab := a * b
"

model_simple_med_es <- c("y ~ m" = "l",
                         "m ~ x" = "m",
                         "y ~ x" = "n")

out <- power4test(nrep = 50,
                  model = model_simple_med,
                  pop_es = model_simple_med_es,
                  n = 100,
                  test_fun = test_parameters,
                  test_args = list(pars = "a"),
                  iseed = 1234,
                  parallel = FALSE,
                  progress = TRUE)

print(out,
      test_long = TRUE)

# Add one more test

out <- power4test(out,
                  test_fun = test_parameters,
                  test_args = list(op = ":="))
print(out,
      test_long = TRUE)

}
