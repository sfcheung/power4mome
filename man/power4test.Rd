% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power4test.R
\name{power4test}
\alias{power4test}
\alias{print.power4test}
\title{Estimate the Power of a Test}
\usage{
power4test(
  object = NULL,
  nrep = NULL,
  ptable = NULL,
  model = NULL,
  pop_es = NULL,
  standardized = TRUE,
  n = NULL,
  number_of_indicators = NULL,
  reliability = NULL,
  x_fun = list(),
  fit_model_args = list(),
  R = NULL,
  ci_type = "mc",
  gen_mc_args = list(),
  gen_boot_args = list(),
  test_fun = NULL,
  test_args = list(),
  map_names = c(fit = "fit"),
  results_fun = NULL,
  results_args = list(),
  test_name = NULL,
  test_note = NULL,
  do_the_test = TRUE,
  sim_all = NULL,
  iseed = NULL,
  parallel = FALSE,
  progress = TRUE,
  ncores = max(1, parallel::detectCores(logical = FALSE) - 1),
  es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5),
  es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15),
  n_std = 1090000,
  std_force_monte_carlo = FALSE
)

\method{print}{power4test}(
  x,
  what = c("data", "test"),
  digits = 3,
  digits_descriptive = 2,
  data_long = FALSE,
  test_long = FALSE,
  fit_to_all_args = list(),
  ...
)
}
\arguments{
\item{object}{Optional. If set to a
\code{power4test} object, it will be
updated using the value(s) in \code{n},
\code{pop_es}, and/or \code{nrep}. Default is \code{NULL}.}

\item{nrep}{The number of replications
to generate the simulated datasets.
Default is \code{NULL}. Must be set when
called to create a \code{power4test}
object.}

\item{ptable}{The output of
\code{\link[=ptable_pop]{ptable_pop()}}, which is a
\code{ptable_pop} object, representing the
population model. If \code{NULL}, the
default, \code{\link[=ptable_pop]{ptable_pop()}} will be
called to generate the \code{ptable_pop}
object using \code{model} and \code{pop_es}.}

\item{model}{The \code{lavaan} model
syntax of the population model.
Required. Ignored if \code{ptable} is
specified. See 'Details' of
\code{\link[=ptable_pop]{ptable_pop()}} on how to use it for
models with latent factors
and indicators. Ignored if \code{ptable} is
specified.}

\item{pop_es}{The character vector to
specify population effect sizes. See
'Details' of \code{\link[=ptable_pop]{ptable_pop()}} on how to
set the effect sizes for this
argument. Can also be a multiline
string, explained in 'Details'.
Ignored if \code{ptable} is
specified.}

\item{standardized}{Logical. If
\code{TRUE}, the default, variances and
error variances are scaled to ensure
the population variances of the
endogenous variables are close to
one, and hence the effect sizes are
standardized effect sizes if the
variances of the continuos exogenous
variables are also equal to one.}

\item{n}{The sample size for each
dataset. Default is 100.}

\item{number_of_indicators}{A named
vector to specify the number of
indicators for each factors. See
'Details' of \code{\link[=sim_data]{sim_data()}} on how to set this
argument. Default is \code{NULL} and all
variables in the model syntax are
observed variables.}

\item{reliability}{A named vector
to set the reliability coefficient
of each set of indicators. Default
is \code{NULL}. See 'Details' of
\code{\link[=sim_data]{sim_data()}} on how to set this
argument.}

\item{x_fun}{The function(s) used to
generate the exogenous variables. If
not supplied, or set to \code{list()}, the
default, the variables are generated
from a multivariate normal
distribution. See 'Details' of
\code{\link[=sim_data]{sim_data()}} on how to use this
argument.}

\item{fit_model_args}{A list of the
arguments to be passed to \code{\link[=fit_model]{fit_model()}}
when fitting the
model.
Should be a named argument
with names being the names of the
arguments.}

\item{R}{The number of replications
to generate the Monte Carlo or
bootstrapping estimates
for each fit output. No Monte Carlo
nor bootstrapping
estimates will be generated if \code{R}
is set to \code{NULL}.}

\item{ci_type}{The type of
simulation-based confidence
intervals to use. Can be either
\code{"mc"} for Monte Carlo method
(the default) or \code{"boot"} for
nonparametric bootstrapping method.
See \code{\link[=sim_data]{sim_data()}} on the details.}

\item{gen_mc_args}{A list of
arguments to be passed to
\code{\link[manymome:do_mc]{manymome::do_mc()}} when generating
the Monte Carlo estimates.
Should be a named argument
with names being the names of the
arguments. Used only if
\code{ci_type} is \verb{"mc".}}

\item{gen_boot_args}{A list of
arguments to be passed to
\code{\link[manymome:do_boot]{manymome::do_boot()}} when generating
the bootstrap estimates.
Should be a named argument
with names being the names of the
arguments. Used only if
\code{ci_type} is `"boot".}

\item{test_fun}{A function to do the
test. See 'Details' for the requirement
of this function. There are some
built-in test functions in \code{power4mome},
described in 'Details'.}

\item{test_args}{A list of arguments
to be passed to the \code{test_fun}
function. Default is \code{list()}.}

\item{map_names}{A named character
vector specifying how the content of
the element \code{extra} in
each replication of \code{sim_all} map
to the argument of \code{test_fun}.
Default is \code{c(fit = "fit")},
indicating that the element \code{fit}
in the element \code{extra} is set to
the argument \code{fit} of \code{test_fun}.
That is, for the first replication,
\code{fit = sim_out[[1]]$extra$fit} when
calling \code{test_fun}.}

\item{results_fun}{The function to be
used to extract the test results.
See \code{Details} for the requirements
of this function. Default is \code{NULL},
assuming that the output of
\code{test_fun} can be used directly.}

\item{results_args}{A list of
arguments to be passed to the
\code{results_fun} function. Default is
\code{list()}.}

\item{test_name}{String. The name
of the test. Default is \code{NULL},
and the name will be created from
\code{test_fun}. Note that if \code{sim_out}
is a \code{power4test} object and already
has a test of this name stored, it
will be replaced by the new results.}

\item{test_note}{String. An optional
note for the test, stored in the
attribute \code{test_note} of the output
of \code{\link[=do_test]{do_test()}}. Default is \code{NULL}.}

\item{do_the_test}{If \code{TRUE},
\code{\link[=do_test]{do_test()}} will be called to do the
specified test in the fit output of
each dataset.}

\item{sim_all}{If set to either a
\code{sim_out} object (the output of
\code{\link[=sim_out]{sim_out()}} or a \code{power4test} object
(the output of \code{\link[=power4test]{power4test()}}), the
stored datasets and fit outputs will
be used for doing the test.}

\item{iseed}{The seed for the random
number generator. Default is \code{NULL}
and the seed is not changed. This
seed will be set only once, when
calling \code{\link[=sim_data]{sim_data()}}.}

\item{parallel}{If \code{TRUE}, parallel
processing will be used when calling
other functions, if appropriate.
Default is \code{FALSE}.}

\item{progress}{If \code{TRUE}, the progress
of each step will be displayed.
Default is `FALSE.}

\item{ncores}{The number of CPU
cores to use if parallel processing
is used.}

\item{es1}{A named vector to set the
values for each label of the effect
size of correlations and regression
paths.
Default is \code{c("n" = .00, "nil" = .00, "s" = .10, "m" = .30, "l" = .50)}.
Used only if \code{pop_es} is a named
vector. See \code{\link[=ptable_pop]{ptable_pop()}} for
further information.}

\item{es2}{A named vector to set the
values for each label of the effect
size of product term.
Default is \code{c("n" = .00, "nil" = .00, "s" = .05, "m" = .10, "l" = .15)}.
Used only if \code{pop_es} is a named
vector. See \code{\link[=ptable_pop]{ptable_pop()}} for
further information.}

\item{n_std}{The sample size used to
determine the error variances by
simulation when \code{std_force_monte_carlo}
is \code{TRUE}. Default is 100000.}

\item{std_force_monte_carlo}{Logical.
If \code{FALSE}, the default,
standardization is done analytically
if the model has no product terms,
and by simulation if the model has
product terms. If \code{TRUE}, simulation
will be used whether the model has
product terms or not. Always fall
back to standardization if
analytical standardization failed.}

\item{x}{The object
to be printed.}

\item{what}{A string vector of
what to print, \code{"data"} for
simulated data and \code{"test"} for
stored test(s). Default is
\code{c("data", "test")}.}

\item{digits}{The numbers of digits
displayed after the decimal.}

\item{digits_descriptive}{The
number of digits displayed after
the decimal for the descriptive
statistics table.}

\item{data_long}{If \code{TRUE}, detailed
results will be printed when printing
the simulated data.}

\item{test_long}{If \code{TRUE}, detailed
results will be printed when printing
test(s).}

\item{fit_to_all_args}{A named list
of arguments to be passed to
\code{\link[lavaan:sem]{lavaan::sem()}} when the model is
fitted to a sample combined from}

\item{...}{Optional arguments to
be passed to other print methods}
}
\value{
An object of the class \code{power4test},
which is a list of with two elements:
\itemize{
\item \code{sim_all}: The output of \code{\link[=sim_out]{sim_out()}}.
\item \code{test_all}: A named list of the
output of \code{\link[=do_test]{do_test()}}. The names
are the values of \code{test_name}.
This list can have more than one
test because a call to
\code{\link[=power4test]{power4test()}} can add new tests
to a \code{power4test} object.
}

The \code{print} method of \code{power4test}
returns \code{x} invisibly. Called for
its side effect.
}
\description{
An all-in-one function
that receives a model specification,
generates datasets, fits a model, does
the target test, and returns the test
results.
}
\details{
It is an all-in-one function for
estimating the power of a test for
a model, given the sample size
and effect sizes.
}
\section{Workflow}{
This is the workflow:
\itemize{
\item If an object with model and data
already generated is supplied
through \code{sim_all}, such as the
output of \code{\link[=sim_out]{sim_out()}} or of
\code{\link[=power4test]{power4test()}} with \code{do_the_test}
set to \code{FALSE}, the following steps
will be skipped and go directly to
doing the test.
\itemize{
\item Call \code{\link[=sim_data]{sim_data()}} to determine
the population model and
generate the datasets.
\item Call \code{\link[=fit_model]{fit_model()}} to fit the
model to each of the datasets.
\item If \code{R} is not \code{NULL} and
\code{ci_type = "mc"}, call
\code{\link[=gen_mc]{gen_mc()}} to generate Monte
Carlo estimates using
\code{\link[manymome:do_mc]{manymome::do_mc()}}.
\item If \code{R} is not \code{NULL} and
\code{ci_type = "boot"}, call
\code{\link[=gen_boot]{gen_boot()}} to generate
bootstrap estimates using
\code{\link[manymome:do_boot]{manymome::do_boot()}}.
\item Merge the results into a
\code{sim_out} object by calling
\code{\link[=sim_out]{sim_out()}}.
\item If \code{do_the_test} is \code{FALSE},
skip the remaining steps and
return a \code{power4test} object,
which contains only the data
generated and optionally the
Monte Carlo or bootstrap
estimates.
}
\item If \code{do_the_test} is \code{TRUE}, do
the test.
\itemize{
\item \code{\link[=do_test]{do_test()}} will be called to do
the test in the fit output of
each datasets.
}
\item Return a \code{power4test} object which
include the output of \code{sim_out}
and, if \code{do_the_test} is \code{TRUE},
the output of \code{\link[=do_test]{do_test()}}.
}

This function is to be used when
users are interested only in the
power of one or several tests on a
particular aspect of the model, such
as a parameter, given a specific
effect sizes and sample sizes.

Detailed description on major
arguments can be found in sections
below.
}

\section{Model Fitting Arguments}{
For power analysis, usually, the
population model (\code{model}) is to be
fitted, and there is no need to
set \code{fit_model_args}.

If power analysis is to be conducted
for fitting a model that is not the
population model, of if non-default
settings are desired when fitting
a model, then the argument \code{fit_model_args}
needed to be set to customize the
call to \code{\link[=fit_model]{fit_model()}}. For example,
users may want to examine the power
of a test when a misspecified model
is fitted, or the power of a test
when MLR is used as the estimator
when calling \code{\link[lavaan:sem]{lavaan::sem()}}.

This is
an advanced feature, to be described
in a vignette.
}

\section{Advanced Features}{
\subsection{Updating a Condition}{

This function can also be used to
update a condition when only some
selected aspects changed. For example,
without calling this function with
all the arguments set just to change
the sample size, it can be called
by supplying an existing
\code{power4test} object and set only
\code{n} to a new sample size. The data
and the tests will be updated
automatically.
}

\subsection{Multiple Models}{

More than one model can be fitted to
each replication. This is done
by setting \code{fit_model_args} to
a named list. The names are the names
used to identify the models, and
each element is a list of named
list of arguments for a model.

For example:

\preformatted{
fit_model_args = list(fit = list(),
                      fit2 = list(model = mod2),
                      fit3 = list(model = mod3))
}

Three models will be fitted. The
first model is the model ued to
generate the data, named \code{"fit"}.
The second and first models are
named \code{"fit2"} and \code{"fit3"},
respectively, with \code{"fit2"} fitted
with \code{model = mod2} and \code{"fit3"}
fitted with \code{model = mod3}.

If Monte Carlos or bootstrap estimates
are to be generated, they will be
generated for each model, using the
values for their arguments.
}
}

\section{Major Test-Related Arguments}{
\subsection{The test function (test_fun)}{

The function set to \code{test_fun},
the \emph{test function}, usually
should work
on the output of \code{\link[lavaan:sem]{lavaan::sem()}},
\code{\link[lmhelprs:many_lm]{lmhelprs::many_lm()}}, or
\code{\link[stats:lm]{stats::lm()}}, but can also be a
function that works on the output
of the function set to \code{fit_function}
when calling \code{\link[=fit_model]{fit_model()}} or
\code{\link[=power4test]{power4test()}} (see \code{fit_model_args}).

The function has two default
requirements.

First, it has an argument \code{fit}, to
be set to the output of
\code{\link[lavaan:sem]{lavaan::sem()}} or another output
stored in the element \code{extra$fit} of
a replication in the \code{sim_all}
object. (This requirement can be
relaxed; see the section on \code{map_names}.)

That is, the function definition
should be of this from: \code{FUN(fit, ...)}. This is the form of all
\verb{test_*} functions in \code{power4mome}.

If other arguments are to be passed
to the test function, they can be set
to \code{test_args} as a named list.

Second, the test function must
returns an output that (a) can be
processed by the results function
(see below), or (b) is of
the required format for the output of
a results function (see the next
section). If it already returns
an output of the required format,
then there is no need to set the
results function.
}

\subsection{The results function (results_fun)}{

The test results will be extracted
from the output of \code{test_fun} by the
function set to \code{results_fun},
the \emph{results function}. If
the \code{test_fun} already returns an
output of the expected format
(see below), then set \code{results_fun}
to \code{NULL}, the default. The output
of \code{test_fun} will be used for
estimating power.

The function set to \code{results_fun}
must accept the output of \code{test_fun},
as the first argument, and return a
named list (which can be a data frame)
or a named vector with some
of the following
elements:
\itemize{
\item \code{est}: Optional. The estimate of a
parameter, if applicable.
\item \code{se}: Optional. The standard error
of the estimate, if applicable.
\item \code{cilo}: Optional. The lower limit of the
confidence interval, if applicable.
\item \code{cihi}: Optional. The upper limit of the
confidence interval, if applicable.
\item \code{sig}: Required. If \code{1}, the test is
significant. If \code{0}, the test is not
significant. If the test cannot be
done for any reason, it should be
\code{NA}.
}

The results can then be used to
estimate the power or Type I
error of the test.

For example, if
the null hypothesis is false, then
the proportion of significant, that
is, the mean of the values of \code{sig}
across replications, is the power.
}

\subsection{Built-in test functions}{

The package \code{power4mome} has some ready-to-use
test functions:
\itemize{
\item \code{\link[=test_indirect_effect]{test_indirect_effect()}}
\item \code{\link[=test_cond_indirect]{test_cond_indirect()}}
\item \code{\link[=test_cond_indirect_effects]{test_cond_indirect_effects()}}
\item \code{\link[=test_moderation]{test_moderation()}}
\item \code{\link[=test_index_of_mome]{test_index_of_mome()}}
\item \code{\link[=test_parameters]{test_parameters()}}
}

Please refer to their help pages
for examples.
}

\subsection{The argument map_names}{

This argument is for developers using
a test function that has a different
name for the argument of the fit
object (\code{"fit"}, the default).

If \code{test_fun} is set to a function
that works on an output of, say,
\code{\link[lavaan:sem]{lavaan::sem()}} but the argument name
for the output is not \code{fit}, the
mapping can be changed by
\code{map_names}.

For example,
\code{\link[lavaan:parameterEstimates]{lavaan::parameterEstimates()}}
receives an output of \code{\link[lavaan:sem]{lavaan::sem()}}
and reports the test results of model
parameters. However, the argument
name for the \code{lavaan} output is
\code{object.} To instruct \code{\link[=do_test]{do_test()}} to
do the test correctly when setting
\code{test_fun} to
\code{lavaan::parameterEstimates}, add
\code{map_names = c(object = "fit")}. The
element \code{fit} in a replication will
then set to the argument \code{object} of
\code{\link[lavaan:parameterEstimates]{lavaan::parameterEstimates()}}.
}
}

\section{Specify 'pop_es' Using a Multiline String}{
When setting the argumeng \code{pop_es},
instead of using a named vector
or named list for
\code{pop_es}, the population values of
model parameters can also be
specified using a multiline string,
as illustrated below, to be parsed
by \code{\link[=pop_es_yaml]{pop_es_yaml()}}.
\subsection{Single-Group Model}{

This is an example of the multiline string
for a single-group model:

\preformatted{y ~ m: l
m ~ x: m
y ~ x: nil}

The string must follow this format:
\itemize{
\item Each line starts with \verb{tag:}.
\itemize{
\item \code{tag} can be the name of a
parameter, in \code{lavaan} model
syntax format.
\itemize{
\item For example, \code{m ~ x}
denotes the path from \code{x} to \code{m}.
}
\item A tag in \code{lavaan} model syntax can
specify more than one parameter
using \code{+}.
\itemize{
\item For example, \code{y ~ m + x}
denotes the two paths from \code{m} and
\code{x} to \code{y}.
}
\item Alternatively, the \code{tag} can be
either \code{.beta.} or \code{.cov.}.
\itemize{
\item Use \code{.beta.} to set the default
values for all regression coefficients.
\item Use \code{.cov.} to set the default
values for all correlations of
exogenous variables (e.g., predictors).
}
}
\item After each tag is the value of the
population value:

-\code{nil} for nil (zero),
\itemize{
\item \code{s} for small,
\item \code{m} for medium, and
\item \code{l} for large.
}

Note: \code{n} \emph{cannot} be used in this mode.

The
value for each label is determined
by \code{es1} and \code{es2} as described
in \code{\link[=ptable_pop]{ptable_pop()}}.
\itemize{
\item The value can also be
set to a numeric value, such as
\code{.30} or \code{-.30}.
}
}

This is another example:

\preformatted{.beta: s
y ~ m: l}

In this example, all regression
coefficients are \code{small}, while
the path from \code{m} to \code{y} is large.
}

\subsection{Multigroup Model}{

This is an example of the string
for a multigroup model:

\preformatted{y ~ m: l
m ~ x:
  - nil
  - s
y ~ x: nil}

The format is similar to that for
a single-group model. If a parameter
has the same value for all groups,
then the line can be specified
as in the case of a single-group
model: \code{tag: value}.

If a parameter has different
values across groups, then it must
be in this format:
\itemize{
\item A line starts with the tag, followed
by two or more lines. Each line
starts with a hyphen \code{-} and the
value for a group.
}

For example:

\preformatted{m ~ x:
  - nil
  - s}

This denotes that the model has
two groups. The values of the path
from \code{x} to \code{m} for the two
groups are 0 (\code{nil}) and
small (\code{s}), respectively.

Another equivalent way to specify
the values are using \verb{[]}, on
the same line of a tag.

For example:

\preformatted{m ~ x: [nil, s]}

The number of groups is inferred
from the number of values for
a parameter. Therefore, if a tag
has more than one value, each tag
must has the same number of value,
or only one value.

The tag \code{.beta.} and \code{.cov.} can
also be used for multigroup models.
}

\subsection{Which Approach To Use}{

Note that using named vectors or
named lists is more reliable. However,
using a multiline string is
more user-friendly. If this method
failed, please use named vectors or
named list instead.
}

\subsection{Technical Details}{

The multiline string is parsed by \code{\link[yaml:read_yaml]{yaml::read_yaml()}}.
Therefore, the format requirement
is actually that of YAML. Users
knowledgeable of YAML can use other
equivalent way to specify the string.
}
}

\examples{

model_simple_med <-
"
m ~ a * x
y ~ b * m + x
ab := a * b
"

model_simple_med_es <- c("y ~ m" = "l",
                         "m ~ x" = "m",
                         "y ~ x" = "n")

out <- power4test(nrep = 50,
                  model = model_simple_med,
                  pop_es = model_simple_med_es,
                  n = 100,
                  test_fun = test_parameters,
                  test_args = list(pars = "a"),
                  iseed = 1234,
                  parallel = FALSE,
                  progress = TRUE)

print(out,
      test_long = TRUE)

# Add one more test

out <- power4test(out,
                  test_fun = test_parameters,
                  test_args = list(op = ":="))
print(out,
      test_long = TRUE)

}
