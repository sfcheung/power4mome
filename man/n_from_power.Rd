% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/n_from_power.R
\name{n_from_power}
\alias{n_from_power}
\alias{plot.n_from_power}
\title{Sample Size Determination}
\usage{
n_from_power(
  object,
  target_power = 0.8,
  ns_per_trial = 3,
  ci_level = 0.95,
  power_min = 0.01,
  power_max = 0.9,
  n_interval = c(50, 2000),
  extendInt = c("upX", "no", "yes", "downX"),
  progress = TRUE,
  simulation_progress = TRUE,
  max_trials = 10,
  final_nrep = 500,
  final_R = 1000,
  nrep_steps = 1,
  seed = NULL,
  n_include_interval = FALSE,
  power_curve = power ~ I((n - c0)^e)/(b + I((n - c0)^e)),
  start = c(b = 2, c0 = 100, e = 1),
  lower_bound = c(b = 0, c0 = 0, e = 1),
  nls_control = list(),
  nls_args = list()
)

\method{plot}{n_from_power}(x, ...)
}
\arguments{
\item{object}{A \code{power4test} object,
which is the output of \code{\link[=power4test]{power4test()}}.}

\item{target_power}{The target power,
a value greater than 0 and less than
one.}

\item{ns_per_trial}{The initial number
of sample sizes to consider in each
trial. Should be an integer at least
\enumerate{
\item Rounded
up if not an integer.
}}

\item{ci_level}{The level of confidence
of the confidence intervals computed
for the estimated power. Default is
.95.}

\item{power_min, power_max}{The minimum
and maximum values, respectively,
of power
when determining the sample sizes to
try in each trail. Default is .01.}

\item{n_interval}{A vector of
two values, the minimum sample size
and the maximum sample size, in
the search for sample sizes.}

\item{extendInt}{Whether \code{n_interval}
can be expanded when estimating the
sample sizes to try. The value will
be passed to the argument of the
same name in \code{\link[stats:uniroot]{stats::uniroot()}},
but the default value is \code{"upX"}.
That is, sample size higher than
the maximum in \code{n_interval} is
allowed, if predicted by the tentative
model.}

\item{progress}{Logical. Whether
the searching progress is reported.}

\item{simulation_progress}{Logical.
Whether the progress in each call
to \code{\link[=power4test]{power4test()}} or \code{\link[=power4test_by_n]{power4test_by_n()}}
is shown. To be passed to
the \code{progress} argument of these two
functions.}

\item{max_trials}{The maximum number
of trials in searching the sample
size with the target power. Rounded
up if not an integer.}

\item{final_nrep}{The number of
replications in the final stage,
also the maximum number of replications
in each call to \code{\link[=power4test]{power4test()}} or
\code{\link[=power4test_by_n]{power4test_by_n()}}.}

\item{final_R}{The number of
Monte Carlo simulation or
bootstrapping samples in the final
stage. The \code{R} in calling
\code{\link[=power4test]{power4test()}} or \code{\link[=power4test_by_n]{power4test_by_n()}}
will be stepped up to this value
when approaching to the target
power. Do not need to be very large
because the goal is to estimate
power by replications, not for high
precision in one single replication.}

\item{nrep_steps}{How many steps
the number of replications will be
increased to \code{final_nrep}, if the
initial number of replications
(\code{nrep} in \code{\link[=power4test]{power4test()}}) is
less than \code{final_nrep}. The number
of replications will be successively
increased by this number of steps
to increase the precision in estimating
the power. Should be at least 1.
Increasing this number will result
in more trials and take longer to
run, but will try more sample sizes.
Rounded up if not an integer.}

\item{seed}{If not \code{NULL}, \code{\link[=set.seed]{set.seed()}}
will be used to make the process
reproducible. This is not always
possible if many stages of
parallel processing is involved.}

\item{n_include_interval}{Logical.
Whether \code{n_interval} is mandatory
to be included in the sample sizes
to be searched.}

\item{power_curve}{The nonlinear
model to be used when estimating
the relation between power and
sample size. Should be a formula
acceptable by \code{\link[stats:nls]{stats::nls()}},
with \code{power} on the left-hand side,
and \code{n} in the right-hand
side, with one or more parameters.
Users rarely need to change the
default value.}

\item{start}{A named numeric vector
of the starting values for \code{power_curve}
when fitted by \code{\link[stats:nls]{stats::nls()}}.
Users rarely need to change the
default values.}

\item{lower_bound}{A named numeric vector
of the lower bounds for parameters
in \code{power_curve}
when fitted by \code{\link[stats:nls]{stats::nls()}}.
Users rarely need to change the
default values.}

\item{nls_control}{A named list of
arguments to be passed the \code{control}
argument of \code{\link[stats:nls]{stats::nls()}} when
estimating the relation between
power and sample size. The values will
override internal default values,
and also override \code{nls_args}.}

\item{nls_args}{A named list of
arguments to be used when calling
\code{\link[stats:nls]{stats::nls()}}. Used to override
internal default, such as the
algorithm (default is \code{"port"}).
Used with cautions.}

\item{x}{A \code{n_from_power} object,
the output of \code{\link[=n_from_power]{n_from_power()}}.}

\item{...}{Optional arguments.
Not used for now.}
}
\value{
It returns a \code{n_from_power} object,
which is a list with the following
elements:
}
\description{
It searches by simulation
the sample size with power to
detect an effect close to a target
value.
}
\details{
Details
(Include subjects for verbs.)
(Use 3rd person forms for verbs.)
}
\examples{

# TO PREPARE
x <- 1
\donttest{
}

}
\seealso{
\code{\link[=power4test]{power4test()}}
}
