% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/n_from_power.R
\name{n_from_power}
\alias{n_from_power}
\alias{print.n_from_power}
\title{Sample Size Determination}
\usage{
n_from_power(
  object,
  target_power = 0.8,
  ns_per_trial = 3,
  ci_level = 0.95,
  power_min = 0.01,
  power_max = 0.9,
  n_interval = c(50, 2000),
  extendInt = c("upX", "no", "yes", "downX"),
  progress = TRUE,
  simulation_progress = TRUE,
  max_trials = 10,
  final_nrep = 500,
  final_R = 1000,
  nrep_steps = 1,
  seed = NULL,
  n_include_interval = FALSE,
  power_curve = power ~ I((n - c0)^e)/(b + I((n - c0)^e)),
  start = c(b = 2, c0 = 100, e = 1),
  lower_bound = c(b = 0, c0 = 0, e = 1),
  nls_control = list(),
  nls_args = list()
)

\method{print}{n_from_power}(x, digits = 3, ...)
}
\arguments{
\item{object}{A \code{power4test} object,
which is the output of \code{\link[=power4test]{power4test()}}.}

\item{target_power}{The target power,
a value greater than 0 and less than
one.}

\item{ns_per_trial}{The initial number
of sample sizes to consider in each
trial. Should be an integer at least
\enumerate{
\item Rounded
up if not an integer.
}}

\item{ci_level}{The level of confidence
of the confidence intervals computed
for the estimated power. Default is
.95.}

\item{power_min, power_max}{The minimum
and maximum values, respectively,
of power
when determining the sample sizes to
try in each trail. Default is .01.}

\item{n_interval}{A vector of
two values, the minimum sample size
and the maximum sample size, in
the search for sample sizes.}

\item{extendInt}{Whether \code{n_interval}
can be expanded when estimating the
sample sizes to try. The value will
be passed to the argument of the
same name in \code{\link[stats:uniroot]{stats::uniroot()}},
but the default value is \code{"upX"}.
That is, sample size higher than
the maximum in \code{n_interval} is
allowed, if predicted by the tentative
model.}

\item{progress}{Logical. Whether
the searching progress is reported.}

\item{simulation_progress}{Logical.
Whether the progress in each call
to \code{\link[=power4test]{power4test()}} or \code{\link[=power4test_by_n]{power4test_by_n()}}
is shown. To be passed to
the \code{progress} argument of these two
functions.}

\item{max_trials}{The maximum number
of trials in searching the sample
size with the target power. Rounded
up if not an integer.}

\item{final_nrep}{The number of
replications in the final stage,
also the maximum number of replications
in each call to \code{\link[=power4test]{power4test()}} or
\code{\link[=power4test_by_n]{power4test_by_n()}}.}

\item{final_R}{The number of
Monte Carlo simulation or
bootstrapping samples in the final
stage. The \code{R} in calling
\code{\link[=power4test]{power4test()}} or \code{\link[=power4test_by_n]{power4test_by_n()}}
will be stepped up to this value
when approaching to the target
power. Do not need to be very large
because the goal is to estimate
power by replications, not for high
precision in one single replication.}

\item{nrep_steps}{How many steps
the number of replications will be
increased to \code{final_nrep}, if the
initial number of replications
(\code{nrep} in \code{\link[=power4test]{power4test()}}) is
less than \code{final_nrep}. The number
of replications will be successively
increased by this number of steps
to increase the precision in estimating
the power. Should be at least 1.
Increasing this number will result
in more trials and take longer to
run, but will try more sample sizes.
Rounded up if not an integer.}

\item{seed}{If not \code{NULL}, \code{\link[=set.seed]{set.seed()}}
will be used to make the process
reproducible. This is not always
possible if many stages of
parallel processing is involved.}

\item{n_include_interval}{Logical.
Whether \code{n_interval} is mandatory
to be included in the sample sizes
to be searched.}

\item{power_curve}{The nonlinear
model to be used when estimating
the relation between power and
sample size. Should be a formula
acceptable by \code{\link[stats:nls]{stats::nls()}},
with \code{power} on the left-hand side,
and \code{n} in the right-hand
side, with one or more parameters.
Users rarely need to change the
default value.}

\item{start}{A named numeric vector
of the starting values for \code{power_curve}
when fitted by \code{\link[stats:nls]{stats::nls()}}.
Users rarely need to change the
default values.}

\item{lower_bound}{A named numeric vector
of the lower bounds for parameters
in \code{power_curve}
when fitted by \code{\link[stats:nls]{stats::nls()}}.
Users rarely need to change the
default values.}

\item{nls_control}{A named list of
arguments to be passed the \code{control}
argument of \code{\link[stats:nls]{stats::nls()}} when
estimating the relation between
power and sample size. The values will
override internal default values,
and also override \code{nls_args}.}

\item{nls_args}{A named list of
arguments to be used when calling
\code{\link[stats:nls]{stats::nls()}}. Used to override
internal default, such as the
algorithm (default is \code{"port"}).
Used with cautions.}

\item{x}{The output of
\code{\link[=n_from_power]{n_from_power()}}, the
\code{print} method of
an \code{n_from_power} object,
which is the output of
\code{\link[=n_from_power]{n_from_power()}}.}

\item{digits}{The number of digits
after the decimal when printing
the results.}

\item{...}{Optional arguments.
Not used for now.}
}
\value{
The function \code{\link[=n_from_power]{n_from_power()}}
returns a \code{n_from_power} object,
which is a list with the following
elements:
\itemize{
\item \code{power4test_trials}: The output of
\code{\link[=power4test_by_n]{power4test_by_n()}} for all sample
sizes examined.
\item \code{rejection_rates}: The output of
\code{\link[=get_rejection_rates_by_n]{get_rejection_rates_by_n()}} from
\code{power4test_trials}.
\item \code{n_tried}: The sample sizes
examined.
\item \code{power_tried}: The estimated
rejection rates for all the sample
sizes examined.
\item \code{n_final}: The sample size in the
solution. \code{NA} if solution not found.
\item \code{power_final}: The estimated power
of the sample size in the solution.
\code{NA} if solution not found.
\item \code{i_final}: The position of the
solution in \code{power4test_trials}.
\code{NA} if solution not found.
\item \code{ci_final}: The confidence interval
of the estimated power in the solution.
\code{NA} if solution not found.
\item \code{ci_level}: The level of confidence
of \code{ci_final}.
\item \code{nrep_final}: The number of
replications (\code{nrep}) when estimating
the power in the solution.
\item \code{power_curve}: The output of
\code{\link[stats:nls]{stats::nls()}}, \code{\link[stats:glm]{stats::glm()}}, or
\code{\link[stats:lm]{stats::lm()}} when estimating the
power curve.
\item \code{target_power}: The requested
target power.
\item \code{power_tolerance}: The allowed
difference between the solution's
estimated power and the target
power. Determined by the number
of replications and the level of
confidence of the confidence intervals.
\item \code{n_estimated}: The sample size
with the target power, estimated by
\code{power_curve}. This is used, when
solution not found, to determine the
range of sample sizes to search when
calling the function again.
\item \code{start}: The time and date when
the process started.
\item \code{end}: The time and date when the
process ended.
\item \code{time_spent}: The time spent in
doing the search.
\item \code{args}: A named list of the arguments
of \code{\link[=n_from_power]{n_from_power()}} used in the search.
\item \code{call}: The call when this function
is called.
}

The \code{print}-method of \code{n_from_power}
objects returns the object \code{x}
invisibly.
It is called for its side effect.
}
\description{
It searches by simulation
the sample size with power to
detect an effect close to a target
value.

The \code{print} method only print
basic information. Call
\code{\link[=summary.n_from_power]{summary.n_from_power()}} and its
\code{print} method for detailed output.
}
\details{
This is how to use this function:
\itemize{
\item Specify the model by \code{\link[=power4test]{power4test()}},
with \code{do_the_test = FALSE}, and set
the magnitude of the effect sizes
to the minimum levels to detect.
\item Add the test using \code{\link[=power4test]{power4test()}}
using \code{test_fun} and \code{test_args}
(see the help page of \code{\link[=power4test]{power4test()}}
for details). Run it on the
starting sample size.
\item Call \code{\link[=n_from_power]{n_from_power()}} on the output
of \code{\link[=power4test]{power4test()}} returned with
the starting sample size. This
function will iteratively repeat
the analysis on other sample sizes,
trying to find a sample size with
a power level close enough to the
target power.
}

Usually, the default values of the
arguments should be sufficient.

The results can be viewed using
\code{\link[=summary]{summary()}}, and the output has
a \code{\link[=plot.n_from_power]{plot.n_from_power()}} method to
plot the relation between power and
sample size for the sample sizes
examined.
\subsection{Technical Details}{

The detailed workflow of this function
can be found in the following webpage:

https://sfcheung.github.io/power4mome/articles/n_from_power_workflow.html
}
}
\examples{

mod <-
"
m ~ a*x
y ~ b*m + x
ab := a * b
"

mod_es <- c("y ~ m" = "l",
            "m ~ x" = "m",
            "y ~ x" = "n")

sim_only <- power4test(nrep = 10,
                       model = mod,
                       pop_es = mod_es,
                       n = 100,
                       do_the_test = FALSE,
                       iseed = 1234)

test_out <- power4test(object = sim_only,
                       test_fun = test_parameters,
                       test_args = list(pars = "ab"))

# In real analysis, to have more stable results:
# - Use a larger final_nrep (e.g., 500).
# - Use the default ns_per_trial of 3, or just remove it.

# If the default values are OK, this call is sufficient:
# power_vs_n <- n_from_power(test_out,
#                            target_power = .80,
#                            seed = 4567)
power_vs_n <- n_from_power(test_out,
                           progress = TRUE,
                           target_power = .80,
                           final_nrep = 10,
                           ns_per_trial = 1,
                           nrep_steps = 1,
                           max_trials = 1,
                           seed = 4567)
summary(power_vs_n)
plot(power_vs_n)

}
\seealso{
\code{\link[=power4test]{power4test()}}
}
