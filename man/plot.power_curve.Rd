% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_curve_plot.R
\name{plot.power_curve}
\alias{plot.power_curve}
\title{Plot a Power Curve}
\usage{
\method{plot}{power_curve}(
  x,
  what = c("ci", "power_curve"),
  main = paste0("Power Curve ", "(Predictor: ", switch(x$predictor, n = "Sample Size", es
    = "Effect Size"), ")"),
  xlab = switch(x$predictor, n = "Sample Size", es = "Effect Size"),
  ylab = "Estimated Power",
  pars_ci = list(),
  type = "l",
  ylim = c(0, 1),
  ci_level = 0.95,
  ...
)
}
\arguments{
\item{x}{A \code{n_from_power} object,
the output of \code{\link[=n_from_power]{n_from_power()}}.}

\item{what}{A character vector of
what to include in the
plot. Possible values are
\code{"ci"} (confidence intervals
for the estimated sample size) and
\code{"power_curve"} (the crude power
curve, if available).
By default, all these elements will
be plotted.}

\item{main}{The title of the plot.}

\item{xlab, ylab}{The labels for the
horizontal and vertical axes,
respectively.}

\item{pars_ci}{A named list of
arguments to be passed to \code{\link[=arrows]{arrows()}}
to customize the drawing of the
confidence intervals.}

\item{type}{An argument of the
default plot method \code{\link[=plot.default]{plot.default()}}.
Default is \code{"l"}. See \code{\link[=plot.default]{plot.default()}}
for other options.}

\item{ylim}{A two-element numeric
vector of the range of the vertical
axis.}

\item{ci_level}{The level of
confidence of the confidence intervals,
if requested. Default is \code{.95}, denoting
95\%.}

\item{...}{Optional arguments.
Passed to \code{\link[=plot]{plot()}} when drawing
the base plot.}
}
\value{
The \code{plot}-method of \code{power_curve}
objects
is called for its side effect.
}
\description{
It plots the results
in a 'power_curve' object, such as the
estimated power against sample size.
}
\details{
It currently plots the relation
between estimated power and
the predictor. Other elements
can be requested (see the argument
\code{what}), and they can be customized
individually.
}
\examples{

# TODO:
# - To revise

mod <-
"
m ~ a*x
y ~ b*m + x
ab := a * b
"

mod_es <- c("y ~ m" = "l",
            "m ~ x" = "m",
            "y ~ x" = "n")

sim_only <- power4test(nrep = 10,
                       model = mod,
                       pop_es = mod_es,
                       n = 100,
                       do_the_test = FALSE,
                       iseed = 1234)

test_out <- power4test(object = sim_only,
                       test_fun = test_parameters,
                       test_args = list(pars = "ab"))

# In real analysis, to have more stable results:
# - Use a larger final_nrep (e.g., 500).
# - Use the default ns_per_trial of 3, or just remove it.

# If the default values are OK, this call is sufficient:
# power_vs_n <- n_from_power(test_out,
#                            target_power = .80,
#                            seed = 4567)
power_vs_n <- n_from_power(test_out,
                           progress = TRUE,
                           target_power = .80,
                           final_nrep = 10,
                           ns_per_trial = 1,
                           nrep_steps = 1,
                           max_trials = 1,
                           seed = 4567)
summary(power_vs_n)
plot(power_vs_n)

}
\seealso{
\code{\link[=power_curve_x]{power_curve_x()}}
}
