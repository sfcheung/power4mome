% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_curve.R
\name{power_curve}
\alias{power_curve}
\alias{print.power_curve}
\alias{power_curve_by_n}
\alias{power_curve_by_es}
\title{Power Curve}
\usage{
power_curve(
  object,
  formula = NULL,
  start = NULL,
  lower_bound = NULL,
  upper_bound = NULL,
  nls_args = list(),
  nls_control = list(),
  verbose = FALSE
)

\method{print}{power_curve}(x, data_used = FALSE, digits = 3, right = FALSE, row.names = FALSE, ...)

power_curve_by_n(
  object,
  formula = reject ~ I((x - c0)^e)/(b + I((x - c0)^e)),
  start = c(b = 2, c0 = 100, e = 1),
  lower_bound = c(b = 0, c0 = 0, e = 1),
  upper_bound = c(b = Inf, c0 = Inf, e = Inf),
  nls_args = list(),
  nls_control = list(),
  verbose = TRUE
)

power_curve_by_es(
  object,
  formula = list(reject ~ 1 - 1/I((1 + (x/d)^a)^b), reject ~ 1 - exp(x/a)/I((1 +
    exp(x/a))^b), reject ~ 1 - 2/(exp(x/d) + exp(-x/d)), reject ~ 1/(1 + a * exp(-b *
    x))),
  start = list(c(a = 2, b = 4, d = 4), c(a = 1, b = 2), c(d = 1), c(a = 1, b = 1)),
  lower_bound = NULL,
  upper_bound = NULL,
  nls_args = list(),
  nls_control = list(),
  verbose = TRUE
)
}
\arguments{
\item{object}{An object of the class
\code{power4test_by_n} or \code{power4test_by_es},
which is the output of \code{\link[=power4test_by_n]{power4test_by_n()}}
or \code{\link[=power4test_by_es]{power4test_by_es()}}.}

\item{formula}{A formula of the model
for \code{\link[stats:nls]{stats::nls()}}. It can also be
a list of formulas, and the models
will be fitted successively by
\code{\link[stats:nls]{stats::nls()}}, with the first
model fitted successfully adopted.
The response variable must be named
\code{reject}, and the predictor named
\code{x}. Whether \code{x} represents \code{n} or
\code{es} depends on the class of \code{object}.
If \code{NULL}, the default, it will be
determined based on teh type of
\code{object}.}

\item{start}{Either a named vector
of the start value(s) of parameter(s)
in \code{formula}, or a list of named
vectors of the starting value(s)
of the list of formula(s).}

\item{lower_bound}{Either a named vector
of the lower bound(s) of parameter(s)
in \code{formula}, or a list of named
vectors of the lower bound(s)
for the list of formula(s). They will
be passed to \code{lower} of \code{\link[stats:nls]{stats::nls()}}.}

\item{upper_bound}{Either a named vector
of the upper bound(s) of parameter(s)
in \code{formula}, or a list of named
vectors of the upper bound(s)
for the list of formula(s). They will
be passed to \code{upper} of \code{\link[stats:nls]{stats::nls()}}.}

\item{nls_args}{A named list of
arguments to be used when calling
\code{\link[stats:nls]{stats::nls()}}. Used to override
internal default, such as the
algorithm (default is \code{"port"}).
Used with cautions.}

\item{nls_control}{A named list of
arguments to be passed the \code{control}
argument of \code{\link[stats:nls]{stats::nls()}} when
estimating the relation between
power and sample size. The values will
override internal default values,
and also override \code{nls_args}.}

\item{verbose}{Logical. Whether
the messages will be printed when
trying different models.}

\item{x}{A \code{power_curve} object.}

\item{data_used}{Logical. Whether
the rejection rates data frame
used to fit the model is printed.}

\item{digits, right, row.names}{Arguments of the same names used
by the \code{print} method of a
\code{data.frame} object. Used when \code{data_used}
is \code{TRUE} and the rejection rates
data frame is printed.}

\item{...}{For the \code{print} method of
\code{power_curve} objects, they are optional
arguments to be passed to
\code{\link[=print.data.frame]{print.data.frame()}} when printing
the rejection rates data frame.}
}
\value{
It returns a list which is a
\code{power_curve} object, with the
following elements:
\itemize{
\item \code{fit}: The model, which is the
output of \code{\link[stats:nls]{stats::nls()}},
\code{\link[stats:glm]{stats::glm()}}, or \code{\link[stats:lm]{stats::lm()}}.
\item \code{reject_df}: The table of reject
rates and other characteristics,
which is generated by
\code{\link[=rejection_rates_by_n]{rejection_rates_by_n()}} or
\code{\link[=rejection_rates_by_es]{rejection_rates_by_es()}}.
\item \code{predictor}: The predictor or the
power curve, ether \code{"n"} (sample
size) or \code{"es"} (population effect
size).
\item \code{call}: The call used to run this
function.
}

The \code{print} method of \code{power_curve}
object returns \code{x} invisibly. Called
for its sideeffect.
}
\description{
Estimate the relation
between power and a characteristic,
such as sample size or population
effect size.
}
\details{
It retrieve the information
from the output of
\code{\link[=power4test_by_n]{power4test_by_n()}} or
\code{\link[=power4test_by_es]{power4test_by_es()}}, and
estimate the power curve: the
relation between the characteristic
being varied, sample size for
\code{\link[=power4test_by_n]{power4test_by_n()}} and the
population effect size for
\code{\link[=power4test_by_es]{power4test_by_es()}}, and the
rejection rate of the test conducted
by \code{\link[=power4test_by_n]{power4test_by_n()}} or
\code{\link[=power4test_by_es]{power4test_by_es()}}. This
rejection rate is the power when the
population value of the effect size
being tested is nonzero.

The model fitted is \emph{not} intended to
be a precise model for the relation
across a wide range. It is only a
crude estimate based on the limited
number of values of the
characteristic (e.g., sample size)
examined. The model is intended to be
used for only for the range covered,
and for estimating the probable
sample size or effect size with a
desirable level of power. This value
will then be studied by simulation
using functions such as
\code{\link[=power4test]{power4test()}}.

These are the models to be tried,
in the following order:
\itemize{
\item One or nonlinear models, to be
fitted by \code{\link[stats:nls]{stats::nls()}}. If
several models are specified, all
will be fitted and the one with the
smallest deviance will be used.
\item If all the nonlinear models failed,
for whatever reason, a logistic
regression will be fitted by
\code{\link[stats:glm]{stats::glm()}} to predict the
binary significant test results.
\item If the logistic model also failed,
for whatever reason, a simple
linear regression model will be
fitted. Although the power curve is
nonlinear across a wide range of,
say, sample size, a linear model
can still be a good enough
approximation for a narrow range of
the predictor.
}

The output can then be plotted to
visualize the power curve.

This function can be used directly,
but is also used internally by
functions such as \code{\link[=x_from_power]{x_from_power()}}.
}
\examples{


model_simple_med <-
"
m ~ x
y ~ m + x
"

model_simple_med_es <- c("y ~ m" = "l",
                         "m ~ x" = "m",
                         "y ~ x" = "s")

sim_only <- power4test(nrep = 10,
                       model = model_simple_med,
                       pop_es = model_simple_med_es,
                       n = 50,
                       fit_model_args = list(fit_function = "lm"),
                       do_the_test = FALSE,
                       iseed = 1234,
                       parallel = FALSE,
                       progress = FALSE)

# By n

out1 <- power4test_by_n(sim_only,
                        nrep = 10,
                        test_fun = test_parameters,
                        test_args = list(par = "y~x"),
                        n = c(25, 100, 200, 1000),
                        by_seed = 1234,
                        parallel = FALSE,
                        progress = FALSE)

pout1 <- power_curve(out1)
pout1
plot(pout1)

# By pop_es

out2 <- power4test_by_es(sim_only,
                             nrep = 10,
                             test_fun = test_parameters,
                             test_args = list(par = "y~x"),
                             pop_es_name = "y ~ x",
                             pop_es_values = seq(0, .7, .15),
                             by_seed = 1234,
                             parallel = FALSE,
                             progress = FALSE)

pout2 <- power_curve(out2)
pout2
plot(pout2)

}
\seealso{
\code{\link[=power4test_by_n]{power4test_by_n()}} and \code{\link[=power4test_by_es]{power4test_by_es()}}
}
