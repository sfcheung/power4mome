% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim_data.R
\name{sim_data}
\alias{sim_data}
\alias{print.sim_data}
\title{Simulate Datasets Based on a Model}
\usage{
sim_data(
  nrep = 10,
  ptable = NULL,
  model = NULL,
  pop_es = NULL,
  ...,
  n = 100,
  iseed = NULL,
  number_of_indicators = NULL,
  reliability = NULL,
  x_fun = list(),
  parallel = FALSE,
  progress = FALSE,
  ncores = max(1, parallel::detectCores(logical = FALSE) - 1)
)

\method{print}{sim_data}(x, digits = 3, digits_descriptive = 2, ...)
}
\arguments{
\item{nrep}{The number of replications
to generate the simulated datasets.
Default is 10.}

\item{ptable}{The output of
\code{\link[=ptable_pop]{ptable_pop()}}, which is a
\code{ptable_pop} object, representing the
population model. If \code{NULL}, the
default, \code{\link[=ptable_pop]{ptable_pop()}} will be
called to generate the \code{ptable_pop}
object.}

\item{model}{The \code{lavaan} model
syntax of the population model.
Required. Ignored if \code{ptable} is
specified.}

\item{pop_es}{The character to
specify population effect sizes. See
'Details' of \code{\link[=ptable_pop]{ptable_pop()}} on how to
set the effect sizes for this
argument. Ignored if \code{ptable} is
specified.}

\item{...}{For \link{sim_data}, parameters
to be passed to \link{ptable_pop}. For
\code{\link[=print.sim_data]{print.sim_data()}}, these arguments
are ignored.}

\item{n}{The sample size for each
dataset. Default is 100.}

\item{iseed}{The seed for the random
number generator. Default is \code{NULL}
and the seed is not changed.}

\item{number_of_indicators}{A named
vector to specify the number of
indicators for each factors. See
'Details' on how to set this
argument. Default is \code{NULL} and all
variables in the model syntax are
observed variables.}

\item{reliability}{A named vector
to set the reliability coefficient
of each set of indicators. Default
is \code{NULL}.}

\item{x_fun}{The function(s) used to
generate the exogenous variables. If
not supplied, or set to \code{list()}, the
default, the variables are generated
from a multivariate normal
distribution. See 'Details' on how
to use this argument.}

\item{parallel}{If \code{TRUE}, parallel
processing will be used to simulate
the datasets. Default is \code{FALSE}.}

\item{progress}{If \code{TRUE}, the progress
of data simulation will be displayed.
Default is `FALSE.}

\item{ncores}{The number of CPU
cores to use if parallel processing
is used.}

\item{x}{The \code{sim_data} object
to be printed.}

\item{digits}{The numbers of digits
displayed after the decimal.}

\item{digits_descriptive}{The
number of digits displayed after
the decimal for the descriptive
statistics table.}
}
\value{
The function \code{\link[=sim_out]{sim_out()}} returns
a list of the class \code{sim_data},
with length \code{nrep}. Each element
is a \code{sim_data_i} object, with
the following major elements:
\itemize{
\item ptable: A \code{lavaan} parameter
table of the model, with population
values set in the column \code{start}.
(It is the output of the
function \code{ptable_pop()}.)
\item mm_out: The population model
represented by model matrices
as in \code{lavaan}. (It is the output
of the function
\code{model_matrices_pop()}.)
\item mm_lm_out: A list of regression
model formula, one for each
endogenous variable. (It is the
output of the internal function
\code{mm_lm()}.)
\item mm_lm_dat_out: A simulated dataset
generated from the population model.
(It is the output of the internal
function \code{mm_lm_data()}).
\item model_original: The original model
syntax (i.e., the argument \code{model}).
\item model_final: A modified model
syntax if the model is a latent
variable model. Indicators are added
to the syntax.
\item fit0: The output of \code{\link[lavaan:sem]{lavaan::sem()}}
with \code{ptable} as the model and
\code{do.fit} set to \code{FALSE}. Use for
easy retrieval of information
about the model.
}

The \code{print} method of \code{sim_data}
return \code{x} invisibly. Called for
its side effect.
}
\description{
Get a model matrix and
effect size specification and
simulate a number of datasets,
along with other information.
}
\details{
It does two tasks:
\itemize{
\item Determine the actual population
model with population values based
on:
\itemize{
\item A model syntax for the observed
variables (for a path model)
or the latent factors (for a
latent variable model).
\item A textual specification of the
effect sizes of parameters.
\item The number of indicators for
each latent factor if the model
is a latent variable model.
\item The reliability of each latent
factor as measured by the
indicators if the model is a
latent factor model.
}
\item Generate \emph{m} simulated datasets
from the population model.
}

The simulated datasets can then be
used to fit a model, test
parameters, and estimate power.

The output is usually used by
\code{\link[=fit_model]{fit_model()}} to fit a target model,
by default the population model, to each
of the dataset.
\subsection{Setting \code{model} and \code{pop_es}}{

Please refer to help page of
\code{\link[=ptable_pop]{ptable_pop()}} on how to specify
\code{model} and \code{pop_es}.
}

\subsection{Setting \code{number_of_indicators} and \code{reliability}}{

If a variable in the model is to be
replaced by indicators, set
\code{number_of_indicators} to a named
numeric vector. The names are the
variables of variables with
indicators, as appeared in the
\code{model} syntax. The value of each
name is the number of indicators. The
argument \code{reliability} should then be
set a named numeric vector (or list,
see the section on multigroup models)
to specify the population reliability
coefficients ("omega") of each set of
indicators. The population factor
loadings are then computed to ensure
that the population reliability
coefficient is of the target value.

These are examples for a single group
model:

\verb{number of indicator = c(m = 3, x = 4, y = 5)}

The numbers of indicators for \code{m},
\code{x}, and \code{y} are 3, 4, and 5,
respectively.

\code{reliability = c(m = .90, x = .80, y = .70)}

The population reliability
coefficients of \code{m}, \code{x}, and \code{y} are
.90, .80, and .70, respectively.
\subsection{Multigroup Models}{

Multigroup models are supported.
The number of groups is inferred
from \code{pop_es} (see the help page
of \code{\link[=ptable_pop]{ptable_pop()}}).

For a multigroup model, the number
of indicators for each variable
must be the same across groups.

However, the population reliability
coefficients can be different
across groups. For a multigroup model
of \emph{k} groups,
with one or more population reliability
coefficients differ across groups,
the argument \code{reliability} should be
set to a named list. The names are
the variables to which the population
reliability coefficients are to be
set. The element for each name is
either a single value for the common
reliability coefficient, or a
numeric vector of the reliability
coefficient of each group.

This is an example of \code{reliability}
for a model with 2 groups:

\code{reliability = list(x = .80, m = c(.70, .80))}

The reliability coefficients of \code{x} are
.80 in all groups, while the
reliability coefficients of \code{m} are
.70 in one group and .80 in another.
}

\subsection{Equal Numbers of Indicators and/or Reliability Coefficients}{

If all variables in the model has
the same number of indicators,
\code{number_of_indicators} can be set
to one single value.

Similarly, if all sets of indicators
have the same population reliability
in all groups, \code{reliability} can also
be set to one single value.
}

}

\subsection{Specify The Distributions of Exogenous Variables}{

By default, variables are generated
from a multivariate normal distribution.
If desired, users can supply the
function used to generate an exogenous
variables by setting \code{x_fun} to
a named list.

The names of the list are the variables
for which a user function will be used
to generate the data.

Each element of the list must also
be as list. The first element of this
list, can be unnamed, is the
function to be used. If other arguments
need to be supplied, they should be
included as named elements of this list.

For example:

\verb{x_fun = list(x = list(power4mome::rexp_rs),}

\verb{             w = list(power4mome::rbinary_rs,}

\verb{                      p1 = .70)))}

The variables \code{x} and \code{w} will be
generated by user-supplied functions.

For \code{x}, the function is
\code{power4mome::rexp_rs}. No additional
argument when calling this function.

For \code{w}, the function is
\code{power4mome::rbinary_rx}. The argument
\code{p1 = .70} will be pasded to this
function when generating the values
of \code{w}.

These are requirements for the
user-functions:
\itemize{
\item They must return a numeric vector.
\item They mush has an argument \code{n} for
the number of values.
\item The \emph{population} mean and standard
deviation of the generated values
must be 0 and 1, respectively.
}

The package \code{power4mom} has
helper functions for generating
values from some common nonnormal
distributions and then scaled them
to have population mean and standard
deviation equal to 0 and 1, respectively:
\itemize{
\item \code{\link[=rbinary_rs]{rbinary_rs()}}.
\item \code{\link[=rexp_rs]{rexp_rs()}}.
\item \code{\link[=rbeta_rs]{rbeta_rs()}}.
\item \code{\link[=rlnorm_rs]{rlnorm_rs()}}.
\item \code{\link[=rpgnorm_rs]{rpgnorm_rs()}}.
}

To use \code{x_fun}, the variables must
have zero covariances with other
variables in the population. It is
possible to generate nonnormal
multivariate data but we believe this
is rarely needed when estimating
power \emph{before} having the data.
}
}
\examples{
mod <-
"m ~ x
 y ~ m + x"
es <-
c("y ~ m" = "m",
  "m ~ x" = "m",
  "y ~ x" = "n")
data_all <- sim_data(nrep = 5,
                     model = mod,
                     pop_es = es,
                     n = 100,
                     iseed = 1234)

data_all

}
