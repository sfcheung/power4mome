[{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"article brief illustration use power4test() package power4mome power analysis mediation, moderation, moderated mediation model fitted structural equation modeling using lavaan.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"Basic knowledge fitting models lavaan required. Readers also expected basic knowledge mediation, moderation, /moderated mediation.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"brief illustration. complicated scenarios features power4mome described vignettes.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"introduction needs following package:","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"Two functions sufficient estimating power given model, population values, sample size, test used. workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified. Call rejection_rates() compute power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"Let’s consider simple mediation model. like estimate power testing mediation effect Monte Carlo confidence interval.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"model syntax Note , even going test mediation, moderation, moderated mediation effects, need add labels model. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"two approaches : Using named vectors lists. Using multiline string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome uses convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) product term moderation, convention: Small: .05 (-.05) Medium: .10 (-.10) Large: .15 (-.15) values standardized solution (correlations -called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : string denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified string, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size many replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large value unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown printing object: default, population model fitted dataset, hence section <fit>. Perfect fit expected population model saturated model. check section Population Values see whether values expected. example, population values regression paths specified. different expect, check string pop_es see whether set population values correctly. necessary, can check data generation adding data_long = TRUE printing output: section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. results show specified population model correctly. can proceed specify test estimate power.","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"can now simulation estimate power. large number datasets (e.g., 500) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence intervals test indirect effect x y m, sample size 50. call: new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. real studies, number 10000 even 20000 Monte Carlo confidence intervals. However, 2000 sufficient goal estimate power generating many intervals, rather one single stable interval. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo confidence intervals initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-functions common tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case tests done Monte Carlo nonparametric bootstrapping confidence intervals, advised enable parallel processing setting parallel TRUE.5 nrep = 400, 95% confidence limits power .80 .04 .80. precise enough determining whether sample size sufficient power. default printout: test_long = TRUE added printing output print(), summary test also printed. summary test: mean estimates across replications 0.152, close population value.","code":"out <- power4test(nrep = 400,                   model = mod,                   pop_es = mod_es,                   n = 50,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. print(out,       test_long = TRUE) #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power","dir":"Articles","previous_headings":"Mediation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"power estimate simply proportion significant results, rejection rate, null hypothesis false. addition using test_long = TRUE print(), rejection rate can also retrieved rejection_rates(). example , estimated power test indirect effect, conducted Monte Carlo confidence intervals, 0.468, column reject. p.v proportion valid results across replications. 1.000 means test conducted normally replications. default, 95% confidence interval rejection rate (power) based normal approximation also printed, column r.cilo r.cihi. example, 95% confidence interval [0.419; 0.516].","code":"out_power <- rejection_rates(out) out_power #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.152 1.000  0.468  0.419  0.516 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"moderation","dir":"Articles","previous_headings":"","what":"Moderation","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"Let’s consider moderation model, control variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"pop_es_xw","dir":"Articles","previous_headings":"Moderation","what":"Specify the Population Model and Values","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"model moderation, predictor x moderator w. product term included lavaan style, x:w. unrealistic specific population values control variables. Therefore, can just add proxy, control represent set control variables may included. syntax population values: example introduces one useful tag, .beta. model many paths, inconvenient specify manually. tag .beta. specifies default value regression paths specified explicitly, small (.10) example. path explicitly included (y ~ control y ~ x:w), manually specified value used instead .beta.. example also illustrates can set population values correlations (covariances standardized solution). Control variables included usually may correlate predictors. Therefore, example, hypothesized small correlation x proxy control variable (x ~~ control: s). Last, recall section convention product term values different: l denotes .15 product terms.","code":"mod2 <- \" y ~ x + w + x:w + control \" mod2_es <- \" .beta.: s x ~~ control: s y ~ control: s y ~ x:w: l \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model-1","dir":"Articles","previous_headings":"Moderation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"check model first: population values regression paths specified, estimates based 5 × 104 2 100000 support dataset generated correctly. NOTE: product term involved, component terms (x w example) correlated, population standard deviation product term may equal one (Bohrnstedt & Goldberger, 1969). Therefore, model can specified correctly even standard deviations product terms section Descriptive Statistics close one.","code":"out2 <- power4test(nrep = 2,                    model = mod2,                    pop_es = mod2_es,                    n = 50000,                    iseed = 1234) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> y ~ x + w + x:w + control #>  #> == Model on Variables/Indicators == #>  #> y ~ x + w + x:w + control #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   y ~                         #>     x                 0.100   #>     w                 0.100   #>     x:w               0.150   #>     control           0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>     control           0.100   #>   w ~~                        #>     x:w               0.000   #>     control           0.000   #>   x:w ~~                      #>     control           0.000   #>  #> Variances: #>                    Population #>    .y                 0.945   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>     control           1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Effect(s) == #>  #>                ind #> control -> y 0.100 #>  #>  - The 'ind' column shows the effect(s). #>   #> == Conditional effects == #>  #>  Path: x -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w)    ind #> 1 M+1.0SD   1  0.250 #> 2 Mean      0  0.100 #> 3 M-1.0SD  -1 -0.050 #>  #>  - The 'ind' column shows the conditional effects. #>   #>  #> == Conditional effects == #>  #>  Path: w -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)    ind #> 1 M+1.0SD   1  0.250 #> 2 Mean      0  0.100 #> 3 M-1.0SD  -1 -0.050 #>  #>  - The 'ind' column shows the conditional effects. #>   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>         vars     n mean sd  skew kurtosis se #> y          1 1e+05 0.00  1  0.02     0.01  0 #> x          2 1e+05 0.00  1  0.01     0.01  0 #> w          3 1e+05 0.00  1  0.00    -0.02  0 #> x:w        4 1e+05 0.00  1 -0.03     6.01  0 #> control    5 1e+05 0.01  1  0.00     0.00  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   y ~                       #>     x                 0.097 #>     w                 0.104 #>     x:w               0.152 #>     control           0.099 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                -0.003 #>     x:w               0.002 #>     control           0.101 #>   w ~~                      #>     x:w              -0.004 #>     control           0.001 #>   x:w ~~                    #>     control           0.004 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-test-the-moderation-effect","dir":"Articles","previous_headings":"Moderation","what":"Call power4test() to Test The Moderation Effect","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"can now simulation estimate power. simple model, test just test product term, x:w. model can fitted linear regression using lm(). Let’s estimate power sample size 50 model fitted lm(): new arguments used: fit_model_args: named list stores additional arguments fit_model(). default, lavaan::sem() used. fit model linear regression using lm(), add fit_function = \"lm\" list.6 test_fun: set test_moderation, provided power4mome. function automatically identifies product terms model test . test used depends method used fit model. lm() used, usual t test used.7","code":"out2 <- power4test(nrep = 400,                    model = mod2,                    pop_es = mod2_es,                    n = 100,                    fit_model_args = list(fit_function = \"lm\"),                    test_fun = test_moderation,                    iseed = 1234,                    parallel = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power-1","dir":"Articles","previous_headings":"Moderation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"can ues rejection_rates() estimate power: estimated power test product term, x:w, 0.347, 95% confidence interval [0.302; 0.395].","code":"out2_power <- rejection_rates(out2) out2_power #> [test]: test_moderation: CIs   #> [test_label]: y~x:w  #>     est   p.v reject r.cilo r.cihi #> 1 0.158 1.000  0.347  0.302  0.395 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"moderated-mediation","dir":"Articles","previous_headings":"","what":"Moderated mediation","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"Let’s consider moderated mediation model.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"specify-the-population-model-and-values","dir":"Articles","previous_headings":"Moderated mediation","what":"Specify the Population Model and Values","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"model mediation model -path, m ~ x, moderated w. explained , need use label define parameters. handled test function used. syntax population values: Please refer previous section setting syntax.","code":"mod3 <- \" m ~ x + w + x:w y ~ m + x \" mod3_es <- \" .beta.: s m ~ x: m y ~ m: m m ~ x:w: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model-2","dir":"Articles","previous_headings":"Moderated mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"check model first: population values estimates based 5 × 104 2 100000 expect.","code":"out3 <- power4test(nrep = 2,                    model = mod3,                    pop_es = mod3_es,                    n = 50000,                    iseed = 1234) print(out3,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.100   #>     x:w               0.050   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.898   #>    .y                 0.881   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Effect(s) == #>  #>          ind #> x -> y 0.100 #>  #>  - The 'ind' column shows the effect(s). #>   #> == Conditional indirect effects == #>  #>  Path: x -> m -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w)   ind   m~x   y~m #> 1 M+1.0SD   1 0.105 0.350 0.300 #> 2 Mean      0 0.090 0.300 0.300 #> 3 M-1.0SD  -1 0.075 0.250 0.300 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - 'm~x','y~m' is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> == Conditional indirect effects == #>  #>  Path: w -> m -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)   ind   m~w   y~m #> 1 M+1.0SD   1 0.045 0.150 0.300 #> 2 Mean      0 0.030 0.100 0.300 #> 3 M-1.0SD  -1 0.015 0.050 0.300 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - 'm~w','y~m' is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n mean sd skew kurtosis se #> m      1 1e+05    0  1 0.03     0.03  0 #> y      2 1e+05    0  1 0.01    -0.01  0 #> x      3 1e+05    0  1 0.00    -0.02  0 #> w      4 1e+05    0  1 0.00     0.01  0 #> x:w    5 1e+05    0  1 0.04     5.92  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.303 #>     w                 0.099 #>     x:w               0.052 #>   y ~                       #>     m                 0.299 #>     x                 0.098 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                 0.003 #>     x:w              -0.001 #>   w ~~                      #>     x:w               0.008 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.007 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.997"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-test-the-moderated-mediation-effect","dir":"Articles","previous_headings":"Moderated mediation","what":"Call power4test() to Test The Moderated Mediation Effect","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"estimate power moderated mediation effect, can test index moderated mediation (Hayes, 2015). example, product coefficient m ~ x:w coefficient y ~ m. can done test function test_index_of_mome(), provided power4mome. , Monte Carlo confidence interval used. Let’s estimate power sample size 100. call similar one used testing mediation. new argument used: test_fun: set test_index_of_mome() example. function similar test_indirect_effect(), one argument, w, moderator. Although example one mediator, support number mediators along path.8","code":"out3 <- power4test(nrep = 400,                    model = mod3,                    pop_es = mod3_es,                    n = 100,                    R = 2000,                    ci_type = \"mc\",                    test_fun = test_index_of_mome,                    test_args = list(x = \"x\",                                     m = \"m\",                                     y = \"y\",                                     w = \"w\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power-2","dir":"Articles","previous_headings":"Moderated mediation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"can ues rejection_rates() estimate power: estimated power test moderated mediation effect, conducted test index moderated mediation, 0.055, 95% confidence interval [0.037; 0.082]. Unlike previous example moderation tested regression, estimating power Monte Carlo confidence intervals substantially slower. However, necessary Monte Carlo nonparametric bootstrapping confidence interval test usually used moderated mediation (mediation).","code":"out3_power <- rejection_rates(out3) out3_power #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.016 1.000  0.055  0.037  0.082 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"new_n","dir":"Articles","previous_headings":"","what":"Repeating a Simulation With A Different Sample Size","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"function power4test() also supports redoing analysis using new value sample size (population effect sizes set pop_es). Simply set output power4test first argument, set new value n. example, can repeat simulation test moderation , sample size 200. simply call power4test() , set previous output (out2 example moderation) first argument, set n new value (200 example): estimated power sample size 200. estimated power 0.527, 95% confidence interval [0.479; 0.576], sample size 200. technique can repeated find required sample size target power, can used scenarios covered , mediation moderated mediation.","code":"out2_new_n <- power4test(out2,                          n = 200) out2_new_n out2_new_n_reject <- rejection_rates(out2_new_n) out2_new_n_reject #> [test]: test_moderation: CIs   #> [test_label]: y~x:w  #>     est   p.v reject r.cilo r.cihi #> 1 0.148 1.000  0.527  0.479  0.576 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"find-the-sample-size-with-the-desired-power","dir":"Articles","previous_headings":"","what":"Find the Sample Size With The Desired Power","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"several efficient ways find sample size desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"using-n_region_from_power","dir":"Articles","previous_headings":"Find the Sample Size With The Desired Power","what":"Using n_region_from_power()","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"function n_region_from_power() can used find region sample sizes likely desired power. default settings used, can called directly output power4test(): recommended way sample size planning, predetermined range sample sizes. See templates examples using n_region_from_power() common models.","code":"out2_region <- n_region_from_power(out2,                                    seed = 2345)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"using-power4test_by_n","dir":"Articles","previous_headings":"Find the Sample Size With The Desired Power","what":"Using power4test_by_n()","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"function power4test_by_n() can used estimate power sequence sample sizes. example, can estimate power moderation model sample sizes: 250, 300, 350, 400. first argument output power4test() arbitrary sample size. argument n numeric vector sample sizes examine. argument by_seed, set integer, try make results reproducible. call take times run equivalent calling power4test() sample size. rejection rates sample size can retrieved rejection_rates() : results show , power .800 detect moderation effect, sample size 350 needed. approach used range sample sizes already decided levels power needed determine final sample size. Please refer help page power4test_by_n() examples.","code":"out2_several_ns <- power4test_by_n(out2,                                    n = c(250, 300, 350, 400),                                    by_seed = 4567) rejection_rates(out2_several_ns) #> [test]: test_moderation: CIs   #> [test_label]: y~x:w  #>     n   est   p.v reject r.cilo r.cihi #> 1 250 0.149 1.000  0.660  0.612  0.705 #> 2 300 0.150 1.000  0.733  0.687  0.774 #> 3 350 0.151 1.000  0.810  0.769  0.845 #> 4 400 0.150 1.000  0.850  0.812  0.882 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"using-x_from_power","dir":"Articles","previous_headings":"Find the Sample Size With The Desired Power","what":"Using x_from_power()","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"function x_from_power() can used systematically search within interval sample size target power. takes longer run , instead manually trying different sample size, function search automatically. approach can used goal find probable minimum maximum sample size desired level power. first approach, using n_region_from_power(), simply uses approach twice find region sample sizes. See article illustration use x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"other-advanced-features","dir":"Articles","previous_headings":"","what":"Other Advanced Features","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"brief illustration covers basic features power4mome. advanced features covered articles: inherent restriction form model. Typical models can specified lavaan model syntax can population model, although may special models power4test yet support. population model can model latent factors indicators. Nevertheless, users can specify relation among factors. need include indicators model syntax, also need manually specify factor loadings. number indicators factor factor loadings set argument number_of_indicators reliability (see help page sim_data() set ). model syntax used fit data automatically include indicators. introduction can found vignette(\"power4test_latent_mediation\"). Examples can found templates models latent variables. Though illustrated , estimating power tests conducted nonparametric bootstrapping supported, although take longer run. Although package focuses moderation, mediation, moderated mediation, principle, power test can estimated, long test function test_fun available. functions provided power4mome (e.g., test_parameters() testing free model parameters). See help page do_test() write function test available power4mome. estimating power, usually population model fitted data. However, possible fit model generated data. can done using argument fit_model_args set argument model fit_model(). Preliminary support multigroup model available. See help pages ptable_pop() pop_es_yaml() specify population value syntax. Functions added tests relevant multigroup models (e.g., testing -group difference indirect effect). Although illustrated rerunning analysis new sample size (n), also possible rerun analysis using new population value parameter. can done using previous output power4test() first argument, setting pop_es named vector: Basic support generating nonnormal variables, including dichotomous variables available. See argument x_fun power4test() details.","code":"out2_new_xw <- power4test(out2,                           pop_es = c(\"y ~ x:w\" = \".30\"))"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Power Analysis for Moderation, Mediation, and Moderated Mediation","text":"Monte Carlo confidence interval supported models fitted lm() (regression). estimate power testing mediation moderated mediation effects models fitted lm(), ci_type = \"boot\" needed.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis for Latent Variable Mediation","text":"article brief illustration use power4test() package power4mome power analysis mediation effect among latent factors model fitted structural equation model modeling using lavaan.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Power Analysis for Latent Variable Mediation","text":"Basic knowledge fitting models lavaan required. Readers also expected basic knowledge mediation structural equation modeling.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Power Analysis for Latent Variable Mediation","text":"make vignette self-contained, sections vignette(\"power4mome\") repeated . power analysis mediation effect path model latent factors, please refer vignette(\"power4mome\").","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Power Analysis for Latent Variable Mediation","text":"introduction needs following package:","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Power Analysis for Latent Variable Mediation","text":"Two functions sufficient estimating power given model, population values, sample size, test used. workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified. Call rejection_rates() compute power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Power Analysis for Latent Variable Mediation","text":"Let’s consider simple mediation model three factors. like estimate power testing mediation effect Monte Carlo confidence interval.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Power Analysis for Latent Variable Mediation","text":"model latent factor, need specify model syntax factors. need include measurement part indicators. model syntax: latent variables fx, fm, fy. indirect path fx fy, fm. Note , even going test mediation effect, need add labels model. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" fm ~ fx fy ~ fm + fx \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Power Analysis for Latent Variable Mediation","text":"two approaches : Using named vectors lists. Using multiline string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path fx fm “large” strength. path fm fy “large” strength. path fx fm “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (correlations -called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : string denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified string, set zero.","code":"mod_es <- \" fm ~ fx: l fy ~ fm: l fy ~ fx: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"measurement","dir":"Articles","previous_headings":"Mediation","what":"Specify the Measurement Part","title":"Power Analysis for Latent Variable Mediation","text":"Power analysis usually conducted data collection. rarely know advance factor loadings items. purpose power analysis, intended conducted knowledge factor loadings, believe , instead specifying loadings, sufficient specify two values factor: number indicators. population reliability. approach used power4mome. factor, population standardized factor loadings indicator derived automatically hypothesized (expected) population reliability number indicators, assuming indicators equal loadings. Although equal-loading assumption unrealistic, priori power analysis, difficult, impossible, specify pattern factor loadings. level details also necessary power estimated merely used guide planning data collection, instead estimating “true” power data collected. Two arguments used set number indicators reliability. number_of_indicators: named vector number indicators factor. names names factors appeared model syntax, values number indicators. reliability: named vector reliability factor. names names factors appeared model syntax, values population reliability. example, suppose use following vectors: numbers indicators fx, fm, fy 4, 3, 5, respectively. population reliability coefficients fx, fm, fy .50, .60, .70, respectively. real research, reliability low .50 can problematic. chose values merely illustration orders intentionally arbitrary, demonstrate order matter. names used interpret numbers correctly.","code":"k <- c(fm = 3,        fx = 4,        fy = 5) mod_rel <- c(fy = .70,              fm = .60,              fx = .50)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Latent Variable Mediation","text":"set can call power4test() check model: arguments used: nrep: number replications. stage, small number can used. important large sample size many replications. model: model syntax. pop_es: string setting population values. number_of_indicators: named vector number indicators factor, described previous section. reliability: named vector population reliability factor, described previous section. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown printing object: default, population model fitted dataset, hence section <fit>. fit “perfect” model saturated model. However, p-value high significant (, population model fitted, chance significant close .05). Although specify structure latent factors, can see automatically generated measurement part syntax section Model Variables/Indicators: confirmed specified measurement part correctly. check section Population Values see whether values expected. example, population values regression paths specified. different expect, check string pop_es see whether set population values correctly. section Variances: shows variances error variances latent factors. fm fy endogenous factors, values presented, next .fm .fy, error variances, ’s 1, unlike fx. section Population Reliability shows population reliability coefficients: values set reliability. section Population Standardized Loadings shows standardized factor loadings factor. one value factor loadings assumed items: necessary, can check data generation adding data_long = TRUE printing output: Two new sections printed. first one: section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics indicators. expected, means close zero standard deviations close one, datasets generated using standardized model. second one: section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. results show specified population model correctly. can proceed specify test estimate power.","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   number_of_indicators = k,                   reliability = mod_rel,                   n = 50000,                   iseed = 1234) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> == Model on Variables/Indicators == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   fm ~                        #>     fx                0.500   #>   fy ~                        #>     fm                0.500   #>     fx                0.100   #>  #> Variances: #>                    Population #>    .fm                0.750   #>    .fy                0.690   #>     fx                1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                  ind #> fx -> fm -> fy 0.250 #> fx -> fy       0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #>  #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 44 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        27 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                38.042 #>   Degrees of freedom                                51 #>   P-value (Chi-square)                           0.910 #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 print(out,       data_long = TRUE) #> ==== Descriptive Statistics ==== #>  #>     vars     n mean   sd  skew kurtosis se #> fm1    1 1e+05 0.00 1.00  0.01     0.00  0 #> fm2    2 1e+05 0.01 1.00  0.01    -0.01  0 #> fm3    3 1e+05 0.00 1.01  0.00    -0.02  0 #> fx1    4 1e+05 0.00 1.00  0.00     0.00  0 #> fx2    5 1e+05 0.00 1.00 -0.01     0.00  0 #> fx3    6 1e+05 0.00 1.00 -0.01    -0.02  0 #> fx4    7 1e+05 0.00 1.00  0.00     0.00  0 #> fy1    8 1e+05 0.00 1.00  0.01     0.01  0 #> fy2    9 1e+05 0.00 1.00  0.01     0.00  0 #> fy3   10 1e+05 0.00 1.00  0.00     0.01  0 #> fy4   11 1e+05 0.01 1.00  0.01     0.00  0 #> fy5   12 1e+05 0.00 1.00  0.02    -0.01  0 #> fy5   12 1e+05 0.00 1.00  0.02    -0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Latent Variables: #>                     est.std #>   fm =~                     #>     fm1               0.578 #>     fm2               0.579 #>     fm3               0.578 #>   fx =~                     #>     fx1               0.445 #>     fx2               0.443 #>     fx3               0.445 #>     fx4               0.445 #>   fy =~                     #>     fy1               0.559 #>     fy2               0.560 #>     fy3               0.563 #>     fy4               0.565 #>     fy5               0.569 #>  #> Regressions: #>                     est.std #>   fm ~                      #>     fx                0.504 #>   fy ~                      #>     fm                0.505 #>     fx                0.097"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Power Analysis for Latent Variable Mediation","text":"can now simulation estimate power. large number datasets (e.g., 400) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect fx fy fm, sample size 150. call: new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. real studies, number 10000 even 20000 Monte Carlo confidence intervals. However, 2000 sufficient goal estimate power generating many intervals, rather one single stable interval. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-functions common tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case tests done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 nrep = 400, 95% confidence limits power .80 .04 .80. precise enough determining whether sample size sufficient power. default printout:","code":"out <- power4test(nrep = 400,                   model = mod,                   pop_es = mod_es,                   number_of_indicators = k,                   reliability = mod_rel,                   n = 150,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"fx\",                                    m = \"fm\",                                    y = \"fy\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> == Model on Variables/Indicators == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   fm ~                        #>     fx                0.500   #>   fy ~                        #>     fm                0.500   #>     fx                0.100   #>  #> Variances: #>                    Population #>    .fm                0.750   #>    .fy                0.690   #>     fx                1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                  ind #> fx -> fm -> fy 0.250 #> fx -> fy       0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #>  #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  150  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 38 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        27 #>  #>   Number of observations                           150 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                69.181 #>   Degrees of freedom                                51 #>   P-value (Chi-square)                           0.046 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: fx->fm->fy #>  #> Call print() and set 'test_long = TRUE' for a detailed report."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"compute-the-power","dir":"Articles","previous_headings":"Mediation","what":"Compute the Power","title":"Power Analysis for Latent Variable Mediation","text":"power estimate simply proportion significant results, rejection rate, null hypothesis false. rejection rate can retrieved rejection_rates(). example , estimated power test indirect effect, conducted Monte Carlo confidence interval, 0.492, column reject. p.v proportion valid results across replications. 1.000 means test conducted normally replications. default, 95% confidence interval rejection rate (power) based normal approximation also printed, column r.cilo r.cihi. example, 95% confidence interval [0.444; 0.541].","code":"out_power <- rejection_rates(out) out_power #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.336 1.000  0.492  0.444  0.541 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"new_n","dir":"Articles","previous_headings":"","what":"Repeat a Simulation With A Different Sample Size","title":"Power Analysis for Latent Variable Mediation","text":"function power4test() also supports redoing analysis using new value sample size (population effect sizes set pop_es). Simply set output power4test first argument, set new value n. example, can repeat simulation test indirect effect, smaller sample size 200. simply call power4test() , set previous output (example ) first argument, set n new value (200 example): estimated power sample size 200. estimated power 0.815, 95% confidence interval [0.774; 0.850], sample size 200. technique can repeated find required sample size target power.","code":"out_new_n <- power4test(out,                         n = 200) out_new_n out_new_n_reject <- rejection_rates(out_new_n) out_new_n_reject #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.352 1.000  0.815  0.774  0.850 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"repeat-a-simulation-with-different-numbers-of-indicators-or-reliability","dir":"Articles","previous_headings":"","what":"Repeat a Simulation With Different Numbers of Indicators or Reliability","title":"Power Analysis for Latent Variable Mediation","text":"can also redo analysis using new value reliability. example, may want see whether can higher power use reliable scales. previous example, just call power4test() one original output, set reliability new vector. Assume want know power scenario, scales population reliability .80: estimated power higher population reliability: estimated power 0.985, 95% confidence interval [0.968; 0.993], much higher original scenario.","code":"out_new_rel <- power4test(out,                           reliability = c(fx = .80,                                           fm = .80,                                           fy = .80)) out_new_rel out_new_rel_reject <- rejection_rates(out_new_rel) out_new_rel_reject #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.235 1.000  0.985  0.968  0.993 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"find-the-sample-size-with-desired-power","dir":"Articles","previous_headings":"","what":"Find the Sample Size With Desired Power","title":"Power Analysis for Latent Variable Mediation","text":"several efficient ways find sample size desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"using-n_region_from_power","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using n_region_from_power()","title":"Power Analysis for Latent Variable Mediation","text":"function n_region_from_power() can used find region sample sizes likely desired power. default settings used, can called directly output power4test(): recommended way sample size planning, predetermined range sample sizes. See templates examples using n_region_from_power() common models.","code":"out2_region <- n_region_from_power(out2,                                    seed = 2345)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"using-power4test_by_n","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using power4test_by_n()","title":"Power Analysis for Latent Variable Mediation","text":"First, function power4test_by_n() can used estimate power sequence sample sizes. example, suppose know power .80 sample size 200. can estimate power mediation model sample sizes: 175, 200, 225, 250. first argument output power4test() arbitrary sample size. argument n numeric vector sample sizes examine. n, nrep datasets generated. Although limit number sample sizes try, recommended restrict number sample sizes 5 less. argument by_seed, set integer, try make results reproducible. call take time run equivalent calling power4test() sample size. rejection rates sample size can retrieved rejection_rates() : results show , power .800 detect mediation effect, sample size 200 needed. approach used range sample sizes already decided levels power needed determine final sample size. Please refer help page power4test_by_n() examples.","code":"out_several_ns <- power4test_by_n(out,                                   n = c(175, 200, 225, 250),                                   by_seed = 4567) rejection_rates(out_several_ns) #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 175 0.327 1.000  0.703  0.656  0.745 #> 2 200 0.329 1.000  0.830  0.790  0.864 #> 3 225 0.340 1.000  0.892  0.858  0.919 #> 4 250 0.330 1.000  0.902  0.869  0.928 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"using-x_from_power","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using x_from_power()","title":"Power Analysis for Latent Variable Mediation","text":"function x_from_power() can used systematically search within interval sample size target power. takes longer run , instead manually trying different sample size, function search automatically. approach can used goal find probable minimum maximum sample size desired level power. first approach, using n_region_from_power(), simply uses approach twice find region sample sizes. See article illustration use x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"other-scenarios","dir":"Articles","previous_headings":"","what":"Other Scenarios","title":"Power Analysis for Latent Variable Mediation","text":"scenarios, moderation moderated mediation, please refer vignette(\"power4mome\").","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflow of `power4test()`","text":"technical appendix describes workflow power4test() power4mome.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_workflow.html","id":"from-population-to-power-power4test","dir":"Articles","previous_headings":"","what":"From Population to Power (power4test())","title":"Workflow of `power4test()`","text":"main function power4test() can tasks one call: Generate nrep datasets (nrep replications) based population model values population parameters (“effect sizes”) (conducted sim_data()). Fit one models datasets (conducted fit_model()). (Optional) Generate Monte Carlo bootstrap estimates based fitted model(s), tests methods Monte Carlo bootstrap confidence intervals (conducted gen_mc() gen_boot()). (Optional) one tests model fit results (conducted do_test()). Return power4test() object. Power can estimated conducted tests functions rejection_rates(). following workflow: Population Power","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/sim_data_i_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflows of `sim_data_i()","text":"technical appendix describes workflow internal function sim_data_i() power4mome.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/sim_data_i_workflow.html","id":"generate-simulated-data-sim_data_i","dir":"Articles","previous_headings":"","what":"Generate Simulated Data (sim_data_i())","title":"Workflows of `sim_data_i()","text":"internal function sim_data_i() called m times sim_data() generate m datasets. workflow sim_data_i(): Workflow sim_data_i() generating many datasets, steps need repeated. Therefore, required objects (e.g., parameter table) supplied sim_data(), sim_data_i() data generation.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Mediation with Observed Variables","text":"“Quick Template” vignettes examples R code power analysis determine sample size typical models using power4mome. Users can quickly adapt scenarios.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), power4test_by_n(), n_from_power(), refer Get-Started article, article finding sample size given desired power using n_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Mediation with Observed Variables","text":"file simple mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Mediation with Observed Variables","text":"Estimate power sample size. code: results:","code":"library(power4mome) # # ====== Model: Form ====== model <- \" m ~ x y ~ m + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) model_es <- \" m ~ x: s y ~ m: l y ~ x: m \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.100   #>   y ~                         #>     m                 0.500   #>     x                 0.300   #>  #> Variances: #>                    Population #>    .m                 0.990   #>    .y                 0.630   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.050 #> x -> y      0.300 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01    -0.01 0.01 #> y    2 40000 -0.01  1 -0.02    -0.03 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.099 #>   y ~                       #>     m                 0.499 #>     x                 0.305 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.049 1.000  0.195  0.156  0.234 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-another-n","dir":"Articles","previous_headings":"","what":"Try Another N","title":"Quick Template: Mediation with Observed Variables","text":"rerun simulation estimate power another sample size. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 150 # Set n to 150 out_new_n <- power4test(out,                         n = 150) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.053 1.000  0.290  0.246  0.334 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-several-ns","dir":"Articles","previous_headings":"","what":"Try Several N’s","title":"Quick Template: Mediation with Observed Variables","text":"Rerun simulation estimate power several sample sizes. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 200, 250, 300 # Use power4test_by_n() out_ns <- power4test_by_n(out,                           n = c(200, 250, 300),                           by_seed = 5789) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_ns) rejection_rates(out_ns) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 200 0.053 1.000  0.323  0.277  0.368 #> 2 250 0.047 1.000  0.323  0.277  0.368 #> 3 300 0.052 1.000  0.445  0.396  0.494 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"search-n-with-target-power","dir":"Articles","previous_headings":"","what":"Search N With Target Power","title":"Quick Template: Mediation with Observed Variables","text":"Search, simulation, sample size estimated either: Case 1: Sample size 95% confidence interval estimated power just target level (e.g., .80). , upper bound (ub) close target level. Sample sizes lower sample size power levels significantly lower target level. Case 2: Sample size 95% confidence interval estimated power just target level (e.g., .80). , lower bound (lb) close target level. Sample sizes higher sample size power levels significantly higher target level.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"use-the-output-of-power4test","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test()","title":"Quick Template: Mediation with Observed Variables","text":"step calling power4test() sample size. can take time run estimated power sample size different target power. consider Case 1 first: Sample sizes power significantly lower target level. code: results: Power Curve Case 2: Sample sizes power significantly higher target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ub <- n_from_power(out,                               what = \"ub\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ub) # # ===== Print the Summary ===== summary(n_power_80_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 654 #>  #> - Final Estimated Power: 0.738  #> - Confidence Interval: [0.694; 0.781] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 897  #> - Time spent in the search: 47.36 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.641485     0.003979   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       2178  #> Residual Deviance: 1756  AIC: 1760 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.049 1.000  0.195  0.156  0.234 #> 2 410 0.049 1.000  0.537  0.489  0.586 #> 3 654 0.050 1.000  0.738  0.694  0.781 #> 4 897 0.049 1.000  0.848  0.812  0.883 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ub) # # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_lb <- n_from_power(out,                               what = \"lb\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_lb) # # ===== Print the Summary ===== summary(n_power_80_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 891 #>  #> - Final Estimated Power: 0.840  #> - Confidence Interval: [0.804; 0.876] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 891  #> - Time spent in the search: 1.052 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.599650     0.003733   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2602  #> Residual Deviance: 2007  AIC: 2011 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1  100 0.049 1.000  0.195  0.156  0.234 #> 2  410 0.049 1.000  0.537  0.489  0.586 #> 3  731 0.049 1.000  0.745  0.702  0.788 #> 4  891 0.049 1.000  0.840  0.804  0.876 #> 5 1051 0.050 1.000  0.907  0.879  0.936 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"use-the-output-of-power4test_by_n","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test_by_n()","title":"Quick Template: Mediation with Observed Variables","text":"step calling power4test_by_n() sample size. Continue search using output several sample sizes calling n_from_power() output power4test_by_n(). can take time run estimated levels power sample sizes different target power. code Case 1: Sample sizes power significantly lower target level. results: Power Curve code Case 2: Sample sizes power significantly higher target level. results: Power Curve","code":"# # ===== Reuse the output of power4test_by_n() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ns_ub <- n_from_power(out_ns,                                  what = \"ub\",                                  seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ns_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_ub) # # ===== Print the Summary ===== summary(n_power_80_ns_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out_ns, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 750 #>  #> - Final Estimated Power: 0.740  #> - Confidence Interval: [0.697; 0.783] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 300 to 961  #> - Time spent in the search: 51.89 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.125137     0.003117   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       2003  #> Residual Deviance: 1821  AIC: 1825 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 300 0.052 1.000  0.445  0.396  0.494 #> 2 539 0.051 1.000  0.662  0.616  0.709 #> 3 750 0.049 1.000  0.740  0.697  0.783 #> 4 961 0.050 1.000  0.877  0.845  0.910 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_ub) # # ===== Reuse the output of power4test_by_n() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ns_lb <- n_from_power(out_ns,                                  what = \"lb\",                                  seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ns_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_lb) # # ===== Print the Summary ===== summary(n_power_80_ns_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out_ns, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 842 #>  #> - Final Estimated Power: 0.838  #> - Confidence Interval: [0.801; 0.874] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 1109 to 967  #> - Time spent in the search: 1.943 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.261561     0.003498   #>  #> Degrees of Freedom: 3199 Total (i.e. Null);  3198 Residual #> Null Deviance:       3289  #> Residual Deviance: 2894  AIC: 2898 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1  300 0.052 1.000  0.445  0.396  0.494 #> 2  539 0.051 1.000  0.662  0.616  0.709 #> 3  824 0.048 1.000  0.812  0.774  0.851 #> 4  842 0.050 1.000  0.838  0.801  0.874 #> 5  860 0.050 1.000  0.875  0.843  0.907 #> 6  896 0.051 1.000  0.865  0.832  0.898 #> 7  967 0.049 1.000  0.877  0.845  0.910 #> 8 1109 0.051 1.000  0.945  0.923  0.967 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, set m ~ x path y ~ m path medium (.30) (population indirect effect .09). code: results: illustration, go directly searching n_from_power(): code Case 1: Sample sizes power significantly lower target level. results: Power Curve code Case 2: Sample sizes power significantly higher target level. results: Power Curve","code":"model_es2 <- \" m ~ x: m y ~ m: m y ~ x: m \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effect,                    test_args = list(x = \"x\",                                     m = \"m\",                                     y = \"y\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.300   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.766   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.090 #> x -> y      0.300 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01     0.00 0.01 #> y    2 40000 -0.01  1 -0.01    -0.01 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.299 #>   y ~                       #>     m                 0.298 #>     x                 0.306 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.089 1.000  0.745  0.702  0.788 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Reuse the output of power4test() ===== n2_power_80_ub <- n_from_power(out2,                             what = \"ub\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_80_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_ub) # # ===== Print the Summary ===== summary(n2_power_80_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 100 #>  #> - Final Estimated Power: 0.745  #> - Confidence Interval: [0.702; 0.788] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 107  #> - Time spent in the search: 15.94 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    0.116390     0.009557   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       897.5  #> Residual Deviance: 897.4     AIC: 901.4 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.089 1.000  0.745  0.702  0.788 #> 2 107 0.088 1.000  0.757  0.715  0.800 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_ub) # # ===== Reuse the output of power4test() ===== n2_power_80_lb <- n_from_power(out2,                             what = \"lb\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_80_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_lb) # # ===== Print the Summary ===== summary(n2_power_80_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 115 #>  #> - Final Estimated Power: 0.848  #> - Confidence Interval: [0.812; 0.883] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 228  #> - Time spent in the search: 1.715 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.18323      0.03245   #>  #> Degrees of Freedom: 2799 Total (i.e. Null);  2798 Residual #> Null Deviance:       2183  #> Residual Deviance: 1967  AIC: 1971 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.089 1.000  0.745  0.702  0.788 #> 2 107 0.088 1.000  0.757  0.715  0.800 #> 3 115 0.090 1.000  0.848  0.812  0.883 #> 4 123 0.089 1.000  0.865  0.832  0.898 #> 5 138 0.091 1.000  0.905  0.876  0.934 #> 6 168 0.091 1.000  0.965  0.947  0.983 #> 7 228 0.089 1.000  0.993  0.984  1.001 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Serial Mediation with Observed Variables","text":"“Quick Template” vignettes examples R code power analysis determine sample size typical models using power4mome. Users can quickly adapt scenarios.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Serial Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), power4test_by_n(), n_from_power(), refer Get-Started article, article finding sample size given desired power using n_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Serial Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Serial Mediation with Observed Variables","text":"file serial mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Serial Mediation with Observed Variables","text":"Estimate power sample size. code: results:","code":"library(power4mome) # # ====== Model: Form ====== # Omit any paths hypothesized to be zero model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # -l, -m, and -s denote negative values # Can also set to a number directly # Set each path to the hypothesized magnitude model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 50,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.500   #>   m2 ~                        #>     m1                0.500   #>     x                 0.000   #>   m3 ~                        #>     m2                0.500   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.750   #>    .m2                0.750   #>    .m3                0.750   #>    .y                 0.893   #>     x                 1.000   #>  #> (Computing indirect effects for 8 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.037 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #> x -> y                   0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd skew kurtosis   se #> m1    1 20000 -0.01 1.00 0.03    -0.04 0.01 #> m2    2 20000  0.00 1.00 0.01     0.06 0.01 #> m3    3 20000 -0.01 1.00 0.01    -0.05 0.01 #> y     4 20000 -0.01 1.00 0.01    -0.03 0.01 #> x     5 20000  0.00 1.01 0.00    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 20000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.493 #>   m2 ~                      #>     m1                0.498 #>     x                 0.010 #>   m3 ~                      #>     m2                0.499 #>     m1               -0.001 #>     x                 0.011 #>   y ~                       #>     m3                0.296 #>     m2               -0.002 #>     m1                0.014 #>     x                 0.086 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        14 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.036 1.000  0.372  0.325  0.420 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"try-another-n","dir":"Articles","previous_headings":"","what":"Try Another N","title":"Quick Template: Serial Mediation with Observed Variables","text":"rerun simulation estimate power another sample size. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 60 # Set n to 60 out_new_n <- power4test(out,                         n = 60) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.037 1.000  0.507  0.459  0.556 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"try-several-ns","dir":"Articles","previous_headings":"","what":"Try Several N’s","title":"Quick Template: Serial Mediation with Observed Variables","text":"Rerun simulation estimate power several sample sizes. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 70, 80, 90 # Use power4test_by_n() out_ns <- power4test_by_n(out,                           n = c(70, 80, 90),                           by_seed = 5789) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_ns) rejection_rates(out_ns) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>    n   est   p.v reject r.cilo r.cihi #> 1 70 0.038 1.000  0.615  0.567  0.663 #> 2 80 0.038 1.000  0.688  0.642  0.733 #> 3 90 0.037 1.000  0.723  0.679  0.766 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"search-n-with-target-power","dir":"Articles","previous_headings":"","what":"Search N With Target Power","title":"Quick Template: Serial Mediation with Observed Variables","text":"Search, simulation, sample size estimated power close target level (e.g., .80).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"use-the-output-of-power4test","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test()","title":"Quick Template: Serial Mediation with Observed Variables","text":"step calling power4test() sample size. can take time run estimated power sample size different target power. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call x_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80 <- x_from_power(out,                            x = \"n\",                            seed = 1357) # # ===== Print the Summary ===== summary(n_power_80) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80) # # ===== Print the Summary ===== summary(n_power_80) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"n\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 107 #>  #> - Final Estimated Power: 0.767  #> - Confidence Interval: [0.726; 0.809] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 107 to 50  #> - Time spent in the search: 22.53 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -2.0266       0.0301   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       1093  #> Residual Deviance: 962   AIC: 966 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.036 1.000  0.372  0.325  0.420 #> 2 107 0.036 1.000  0.767  0.726  0.809 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"use-the-output-of-power4test_by_n","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test_by_n()","title":"Quick Template: Serial Mediation with Observed Variables","text":"step calling power4test_by_n() sample size. Continue search using output several sample sizes calling x_from_power() output power4test_by_n(). can take time run estimated levels power sample sizes different target power. code: results: Power Curve","code":"# # ===== Reuse the output of power4test_by_n() ===== # Call x_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ns <- x_from_power(out_ns,                               x = \"n\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ns) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns) # # ===== Print the Summary ===== summary(n_power_80_ns) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out_ns, x = \"n\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 119 #>  #> - Final Estimated Power: 0.835  #> - Confidence Interval: [0.799; 0.871] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 90  #> - Time spent in the search: 1.446 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -1.0876       0.0223   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       1861  #> Residual Deviance: 1763  AIC: 1767 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  90 0.037 1.000  0.723  0.679  0.766 #> 2 100 0.037 1.000  0.752  0.710  0.795 #> 3 119 0.037 1.000  0.835  0.799  0.871 #> 4 137 0.039 1.000  0.860  0.826  0.894 #> 5 174 0.038 1.000  0.950  0.929  0.971 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Serial Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, set paths along indirect effect medium (.30). code: results: illustration, go directly searching x_from_power(): code: results: Power Curve","code":"model_es2 <- \" m1 ~ x: m m2 ~ m1: m m3 ~ m2: m y ~ m3: m y ~ x: s \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effect,                    test_args = list(x = \"x\",                                     m = c(\"m1\", \"m2\", \"m3\"),                                     y = \"y\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     m1                0.300   #>     x                 0.000   #>   m3 ~                        #>     m2                0.300   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .m3                0.910   #>    .y                 0.898   #>     x                 1.000   #>  #> (Computing indirect effects for 8 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.008 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #> x -> y                   0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd  skew kurtosis   se #> m1    1 40000 -0.01 1.00  0.00     0.01 0.01 #> m2    2 40000  0.00 1.01 -0.01    -0.01 0.01 #> m3    3 40000  0.00 1.01  0.02     0.03 0.01 #> y     4 40000  0.00 1.00 -0.01    -0.01 0.00 #> x     5 40000 -0.01 1.00  0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.306 #>   m2 ~                      #>     m1                0.303 #>     x                -0.001 #>   m3 ~                      #>     m2                0.305 #>     m1                0.001 #>     x                -0.005 #>   y ~                       #>     m3                0.300 #>     m2               -0.005 #>     m1                0.006 #>     x                 0.105 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        14 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.009 1.000  0.460  0.411  0.509 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Reuse the output of power4test() ===== n2_power_80 <- x_from_power(out2,                             x = \"n\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_80) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80) # # ===== Print the Summary ===== summary(n2_power_80) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out2, x = \"n\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 147 #>  #> - Final Estimated Power: 0.810  #> - Confidence Interval: [0.772; 0.848] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 174  #> - Time spent in the search: 1.55 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -3.6239       0.0345   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2218  #> Residual Deviance: 1957  AIC: 1961 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.009 1.000  0.460  0.411  0.509 #> 2 137 0.008 1.000  0.745  0.702  0.788 #> 3 147 0.008 1.000  0.810  0.772  0.848 #> 4 156 0.008 1.000  0.850  0.815  0.885 #> 5 174 0.008 1.000  0.920  0.893  0.947 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Parallel Mediation with Latent Variables","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Parallel Mediation with Latent Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Parallel Mediation with Latent Variables","text":"file parallel mediation models latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Parallel Mediation with Latent Variables","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_k_indirect_effects() Test several indirect effects one test, using Monte Carlo bootstrap confidence intervals. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Parallel Mediation with Latent Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Parallel Mediation with Latent Variables","text":"Load package first: Estimate power sample size. parallel mediation model several parallel paths (three following example). test function test_k_indirect_effects() can used estimate power selected indirect paths significant omnibus set \"all_sig\". code: Model results: (est NaN test three paths single point estimate test.)","code":"library(power4mome) # ====== Model: Form ======  model <- \" m1 ~ x m2 ~ x y ~ m1 + m2 + x \"  # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  model_es <- \" m1 ~ x: m m2 ~ x: m y ~ m1: l y ~ m2: l y ~ x: s \" # ====== Test the Model Specification ======  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 150, # when testing all indirect effects by # Monte Carlo confidence intervals  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 150,                   R = 1000,                   number_of_indicators = c(x = 3,                                            m1 = 4,                                            m2 = 3,                                            y = 3),                   reliability = c(x = .80,                                   m1 = .70,                                   m2 = .70,                                   y = .80),                   ci_type = \"mc\",                   test_fun = test_k_indirect_effects,                   test_args = list(x = \"x\",                                    y = \"y\",                                    mc_ci = TRUE,                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> x =~ x1 + x2 + x3 #> m1 =~ m11 + m12 + m13 + m14 #> m2 =~ m21 + m22 + m23 #> y =~ y1 + y2 + y3 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.300   #>   y ~                         #>     m1                0.500   #>     m2                0.500   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .y                 0.385   #>     x                 1.000   #>  #> (Computing indirect effects for 3 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.150 #> x -> m2 -> y 0.150 #> x -> y       0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>    x  m1  m2   y #>  0.8 0.7 0.7 0.8 #>  #> == Population Standardized Loadings == #>  #>      x    m1    m2     y #>  0.756 0.607 0.661 0.756 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  150  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n  mean   sd  skew kurtosis se #> x1     1 60000  0.00 1.00 -0.01    -0.03  0 #> x2     2 60000  0.00 1.00  0.00     0.02  0 #> x3     3 60000  0.00 1.00  0.00    -0.01  0 #> m11    4 60000  0.00 1.00  0.01    -0.01  0 #> m12    5 60000  0.00 1.00  0.00    -0.02  0 #> m13    6 60000  0.00 1.00 -0.01    -0.01  0 #> m14    7 60000 -0.01 1.00  0.00     0.00  0 #> m21    8 60000  0.00 1.00  0.00    -0.02  0 #> m22    9 60000  0.00 1.00 -0.01    -0.01  0 #> m23   10 60000 -0.01 0.99 -0.02     0.03  0 #> y1    11 60000  0.00 1.00  0.00     0.00  0 #> y2    12 60000  0.00 1.00  0.01     0.03  0 #> y3    13 60000  0.00 1.00  0.00     0.02  0 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 60000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Latent Variables: #>                     est.std #>   x =~                      #>     x1                0.754 #>     x2                0.752 #>     x3                0.760 #>   m1 =~                     #>     m11               0.606 #>     m12               0.611 #>     m13               0.604 #>     m14               0.601 #>   m2 =~                     #>     m21               0.662 #>     m22               0.663 #>     m23               0.661 #>   y =~                      #>     y1                0.755 #>     y2                0.752 #>     y3                0.755 #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.302 #>   m2 ~                      #>     x                 0.301 #>   y ~                       #>     m1                0.507 #>     m2                0.488 #>     x                 0.104 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 33 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        31 #>  #>   Number of observations                           150 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                54.181 #>   Degrees of freedom                                60 #>   P-value (Chi-square)                           0.687 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirects: x-...->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.615  0.566  0.661 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Parallel Mediation with Latent Variables","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 190 power significantly lower .80, sample sizes higher 217 power significantly higher .80. words, sample sizes 190 217 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 190 to 217 #> - significantly lower than 0.800: 190 #> - significantly higher than 0.800: 217 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (190): [0.711, 0.795] #> - for the upper bound (217): [0.787, 0.861] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 190 #>  #> - Final Estimated Power: 0.755  #> - Confidence Interval: [0.711; 0.795] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 150 to 195  #> - Time spent in the search: 1.763 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.33752      0.01816   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2416  #> Residual Deviance: 2379  AIC: 2383 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 150  NaN 1.000  0.615  0.566  0.661 #> 2 173  NaN 1.000  0.647  0.599  0.693 #> 3 184  NaN 1.000  0.738  0.692  0.778 #> 4 190  NaN 1.000  0.755  0.711  0.795 #> 5 195  NaN 1.000  0.785  0.742  0.822 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 217 #>  #> - Final Estimated Power: 0.828  #> - Confidence Interval: [0.787; 0.861] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 195 to 308  #> - Time spent in the search: 3.495 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -1.9154       0.0165   #>  #> Degrees of Freedom: 3199 Total (i.e. Null);  3198 Residual #> Null Deviance:       2660  #> Residual Deviance: 2577  AIC: 2581 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 195  NaN 1.000  0.785  0.742  0.822 #> 2 199  NaN 1.000  0.807  0.766  0.843 #> 3 213  NaN 1.000  0.820  0.779  0.855 #> 4 217  NaN 1.000  0.828  0.787  0.861 #> 5 220  NaN 1.000  0.863  0.825  0.893 #> 6 227  NaN 1.000  0.877  0.842  0.906 #> 7 254  NaN 1.000  0.885  0.850  0.913 #> 8 308  NaN 1.000  0.968  0.945  0.981 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Parallel Mediation with Latent Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m1 ~ x m2 ~ x y ~ m1 + m2 + x \"  model_es <- \" m1 ~ x: m m2 ~ x: m y ~ m1: l y ~ m2: l y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   number_of_indicators = c(x = 3,                                            m1 = 4,                                            m2 = 3,                                            y = 3),                   reliability = c(x = .80,                                   m1 = .70,                                   m2 = .70,                                   y = .80),                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 200, # when testing all indirect effects by # Monte Carlo confidence intervals  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 200,                   number_of_indicators = c(x = 3,                                            m1 = 4,                                            m2 = 3,                                            y = 3),                   reliability = c(x = .80,                                   m1 = .70,                                   m2 = .70,                                   y = .80),                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_k_indirect_effects,                   test_args = list(x = \"x\",                                    y = \"y\",                                    mc_ci = TRUE,                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_parallel.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Parallel Mediation with Latent Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Serial Mediation with Latent Variables","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Serial Mediation with Latent Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Serial Mediation with Latent Variables","text":"file serial mediation models latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Serial Mediation with Latent Variables","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_indirect_effect() Test indirect effect using Monte Carlo bootstrap confidence intervals. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Serial Mediation with Latent Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Serial Mediation with Latent Variables","text":"Load package first: Estimate power sample size. code model: Model Refer article set number_of_indicators reliability calling power4test(). results:","code":"library(power4mome) # ====== Model: Form ======  # Omit any paths hypothesized to be zero  model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \"  # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \" # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   number_of_indicators = c(x = 3,                                            m1 = 4,                                            m2 = 3,                                            m3 = 4,                                            y = 3),                   reliability = c(x = .80,                                   m1 = .70,                                   m2 = .70,                                   m3 = .70,                                   y = .80),                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 150, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 150,                   R = 1000,                   number_of_indicators = c(x = 3,                                            m1 = 4,                                            m2 = 3,                                            m3 = 4,                                            y = 3),                   reliability = c(x = .80,                                   m1 = .70,                                   m2 = .70,                                   m3 = .70,                                   y = .80),                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> x =~ x1 + x2 + x3 #> m1 =~ m11 + m12 + m13 + m14 #> m2 =~ m21 + m22 + m23 #> m3 =~ m31 + m32 + m33 + m34 #> y =~ y1 + y2 + y3 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.500   #>   m2 ~                        #>     m1                0.500   #>     x                 0.000   #>   m3 ~                        #>     m2                0.500   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.750   #>    .m2                0.750   #>    .m3                0.750   #>    .y                 0.893   #>     x                 1.000   #>  #> (Computing indirect effects for 8 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.037 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #> x -> y                   0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>    x  m1  m2  m3   y #>  0.8 0.7 0.7 0.7 0.8 #>  #> == Population Standardized Loadings == #>  #>      x    m1    m2    m3     y #>  0.756 0.607 0.661 0.607 0.756 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  150  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n  mean   sd  skew kurtosis se #> x1     1 60000  0.00 1.00  0.02     0.01  0 #> x2     2 60000 -0.01 1.00 -0.01     0.00  0 #> x3     3 60000  0.00 1.00  0.02    -0.01  0 #> m11    4 60000  0.00 1.00  0.00    -0.01  0 #> m12    5 60000  0.00 1.00 -0.01    -0.01  0 #> m13    6 60000 -0.01 1.00  0.01    -0.01  0 #> m14    7 60000  0.00 1.00  0.00     0.03  0 #> m21    8 60000  0.00 1.00  0.00     0.01  0 #> m22    9 60000  0.00 1.00 -0.02     0.02  0 #> m23   10 60000  0.00 1.00 -0.02    -0.03  0 #> m31   11 60000  0.00 1.00  0.00     0.00  0 #> m32   12 60000  0.00 1.00 -0.02    -0.01  0 #> m33   13 60000  0.00 1.00 -0.01     0.00  0 #> m34   14 60000  0.00 1.00 -0.02    -0.01  0 #> y1    15 60000  0.00 1.00  0.00     0.00  0 #> y2    16 60000  0.00 1.00  0.00     0.01  0 #> y3    17 60000  0.00 0.99 -0.03    -0.01  0 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 60000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Latent Variables: #>                     est.std #>   x =~                      #>     x1                0.756 #>     x2                0.754 #>     x3                0.753 #>   m1 =~                     #>     m11               0.608 #>     m12               0.607 #>     m13               0.612 #>     m14               0.608 #>   m2 =~                     #>     m21               0.664 #>     m22               0.662 #>     m23               0.661 #>   m3 =~                     #>     m31               0.610 #>     m32               0.612 #>     m33               0.611 #>     m34               0.604 #>   y =~                      #>     y1                0.755 #>     y2                0.755 #>     y3                0.750 #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.504 #>   m2 ~                      #>     m1                0.496 #>     x                -0.001 #>   m3 ~                      #>     m2                0.492 #>     m1               -0.000 #>     x                 0.012 #>   y ~                       #>     m3                0.301 #>     m2                0.006 #>     m1                0.003 #>     x                 0.089 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 31 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        44 #>  #>   Number of observations                           150 #>  #> Model Test User Model: #>                                                        #>   Test statistic                               123.231 #>   Degrees of freedom                               109 #>   P-value (Chi-square)                           0.166 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.040 1.000  0.407  0.360  0.456 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Serial Mediation with Latent Variables","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 222 power significantly lower .80, sample sizes higher 283 power significantly higher .80. words, sample sizes 222 283 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 222 to 283 #> - significantly lower than 0.800: 222 #> - significantly higher than 0.800: 283 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (222): [0.705, 0.790] #> - for the upper bound (283): [0.817, 0.886] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 222 #>  #> - Final Estimated Power: 0.750  #> - Confidence Interval: [0.705; 0.790] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 150 to 294  #> - Time spent in the search: 59.16 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.74890      0.01639   #>  #> Degrees of Freedom: 1199 Total (i.e. Null);  1198 Residual #> Null Deviance:       1513  #> Residual Deviance: 1309  AIC: 1313 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 150 0.040 1.000  0.407  0.360  0.456 #> 2 222 0.043 1.000  0.750  0.705  0.790 #> 3 294 0.040 1.000  0.868  0.831  0.897 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 283 #>  #> - Final Estimated Power: 0.855  #> - Confidence Interval: [0.817; 0.886] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 271 to 294  #> - Time spent in the search: 51.52 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -4.59795      0.02221   #>  #> Degrees of Freedom: 1199 Total (i.e. Null);  1198 Residual #> Null Deviance:       1052  #> Residual Deviance: 1045  AIC: 1049 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 271 0.038 1.000  0.800  0.758  0.836 #> 2 283 0.039 1.000  0.855  0.817  0.886 #> 3 294 0.040 1.000  0.868  0.831  0.897 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Serial Mediation with Latent Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \"  model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   number_of_indicators = c(x = 3,                                            m1 = 4,                                            m2 = 3,                                            m3 = 4,                                            y = 3),                   reliability = c(x = .80,                                   m1 = .70,                                   m2 = .70,                                   m3 = .70,                                   y = .80),                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 150, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 150,                   R = 1000,                   number_of_indicators = c(x = 3,                                            m1 = 4,                                            m2 = 3,                                            m3 = 4,                                            y = 3),                   reliability = c(x = .80,                                   m1 = .70,                                   m2 = .70,                                   m3 = .70,                                   y = .80),                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_serial.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Serial Mediation with Latent Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Simple Mediation with Latent Variables","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Simple Mediation with Latent Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Simple Mediation with Latent Variables","text":"file simple mediation models latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Simple Mediation with Latent Variables","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_indirect_effect() Test indirect effect using Monte Carlo bootstrap confidence intervals. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Simple Mediation with Latent Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Simple Mediation with Latent Variables","text":"Load package first: Estimate power sample size. code model: Model Refer article set number_of_indicators reliability calling power4test(). results:","code":"library(power4mome) # ====== Model: Form ======  model <- \" m ~ x y ~ m + x \"  # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  model_es <- \" m ~ x: m y ~ m: l y ~ x: s \" # ====== Test the Model Specification ======  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   number_of_indicators = c(x = 4,                                            m = 3,                                            y = 3),                   reliability = c(x = .80,                                   m = .70,                                   y = .80),                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   number_of_indicators = c(x = 4,                                            m = 3,                                            y = 3),                   reliability = c(x = .80,                                   m = .70,                                   y = .80),                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> x =~ x1 + x2 + x3 + x4 #> m =~ m1 + m2 + m3 #> y =~ y1 + y2 + y3 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.710   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>    x   m   y #>  0.8 0.7 0.8 #>  #> == Population Standardized Loadings == #>  #>      x     m     y #>  0.707 0.661 0.756 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd  skew kurtosis   se #> x1    1 40000  0.00 1.00 -0.03     0.03 0.01 #> x2    2 40000 -0.01 1.00 -0.02     0.00 0.01 #> x3    3 40000  0.00 1.01  0.01     0.00 0.01 #> x4    4 40000  0.00 1.00  0.02    -0.03 0.00 #> m1    5 40000  0.00 1.00  0.00     0.04 0.01 #> m2    6 40000  0.00 1.00  0.00     0.02 0.00 #> m3    7 40000  0.00 1.00 -0.01     0.03 0.01 #> y1    8 40000  0.00 1.00  0.01    -0.01 0.00 #> y2    9 40000  0.00 1.00  0.00     0.03 0.01 #> y3   10 40000  0.00 1.00  0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Latent Variables: #>                     est.std #>   x =~                      #>     x1                0.708 #>     x2                0.705 #>     x3                0.706 #>     x4                0.705 #>   m =~                      #>     m1                0.659 #>     m2                0.661 #>     m3                0.669 #>   y =~                      #>     y1                0.762 #>     y2                0.751 #>     y3                0.758 #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.305 #>   y ~                       #>     m                 0.496 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 27 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        23 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                23.902 #>   Degrees of freedom                                32 #>   P-value (Chi-square)                           0.848 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.168 0.998  0.499  0.450  0.548 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Simple Mediation with Latent Variables","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 145 power significantly lower .80, sample sizes higher 182 power significantly higher .80. words, sample sizes 145 182 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 145 to 182 #> - significantly lower than 0.800: 145 #> - significantly higher than 0.800: 182 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (145): [0.724, 0.806] #> - for the upper bound (182): [0.804, 0.875] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 145 #>  #> - Final Estimated Power: 0.767  #> - Confidence Interval: [0.724; 0.806] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 160  #> - Time spent in the search: 1.136 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.45569      0.02493   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       1968  #> Residual Deviance: 1865  AIC: 1869 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.168 0.998  0.499  0.450  0.548 #> 2 130 0.167 1.000  0.708  0.661  0.750 #> 3 145 0.159 1.000  0.767  0.724  0.806 #> 4 160 0.164 1.000  0.807  0.766  0.843 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 182 #>  #> - Final Estimated Power: 0.843  #> - Confidence Interval: [0.804; 0.875] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 159 to 245  #> - Time spent in the search: 1.512 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.58318      0.01854   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       1616  #> Residual Deviance: 1553  AIC: 1557 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 159 0.157 1.000  0.797  0.755  0.834 #> 2 160 0.164 1.000  0.807  0.766  0.843 #> 3 182 0.157 1.000  0.843  0.804  0.875 #> 4 203 0.162 1.000  0.902  0.869  0.928 #> 5 245 0.156 1.000  0.953  0.927  0.969 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Simple Mediation with Latent Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m ~ x y ~ m + x \" model_es <- \" m ~ x: m y ~ m: l y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   number_of_indicators = c(x = 4,                                            m = 3,                                            y = 3),                   reliability = c(x = .80,                                   m = .70,                                   y = .80),                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   number_of_indicators = c(x = 4,                                            m = 3,                                            y = 3),                   reliability = c(x = .80,                                   m = .70,                                   y = .80),                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_lav_simple.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Simple Mediation with Latent Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Parallel Mediation with Observed Variables","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Parallel Mediation with Observed Variables","text":"file parallel mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Parallel Mediation with Observed Variables","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_k_indirect_effects() Test several indirect effects one test, using Monte Carlo bootstrap confidence intervals. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Parallel Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Load package first: Estimate power sample size. parallel mediation model several parallel paths (three following example). test function test_k_indirect_effects() can used estimate power selected indirect paths significant omnibus set \"all_sig\". code: Model results: (est NaN test three paths single point estimate test.)","code":"library(power4mome) # ====== Model: Form ======  model <- \" m1 ~ x m2 ~ x m3 ~ x y ~ m1 + m2 + m3 + x \"  # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  model_es <- \" m1 ~ x: m m2 ~ x: m m3 ~ x: m y ~ m1: s y ~ m2: m y ~ m3: l y ~ x: s \" # ====== Test the Model Specification ======  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 100, # when testing all indirect effects by # Monte Carlo confidence intervals  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_k_indirect_effects,                   test_args = list(x = \"x\",                                    y = \"y\",                                    mc_ci = TRUE,                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.300   #>   m3 ~                        #>     x                 0.300   #>   y ~                         #>     m1                0.100   #>     m2                0.300   #>     m3                0.500   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .m3                0.910   #>    .y                 0.545   #>     x                 1.000   #>  #> (Computing indirect effects for 4 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.030 #> x -> m2 -> y 0.090 #> x -> m3 -> y 0.150 #> x -> y       0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean sd  skew kurtosis   se #> m1    1 40000 -0.01  1  0.00     0.01 0.01 #> m2    2 40000  0.00  1 -0.01     0.01 0.01 #> m3    3 40000  0.00  1  0.02     0.03 0.01 #> y     4 40000  0.00  1  0.00     0.00 0.01 #> x     5 40000 -0.01  1  0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.306 #>   m2 ~                      #>     x                 0.300 #>   m3 ~                      #>     x                 0.295 #>   y ~                       #>     m1                0.103 #>     m2                0.296 #>     m3                0.500 #>     x                 0.106 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 2 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        11 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.950 #>   Degrees of freedom                                 3 #>   P-value (Chi-square)                           0.175 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirects: x-...->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.172  0.139  0.213 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 464 power significantly lower .80, sample sizes higher 516 power significantly higher .80. words, sample sizes 464 516 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 464 to 516 #> - significantly lower than 0.800: 464 #> - significantly higher than 0.800: 516 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (464): [0.724, 0.806] #> - for the upper bound (516): [0.806, 0.877] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 464 #>  #> - Final Estimated Power: 0.767  #> - Confidence Interval: [0.724; 0.806] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 464  #> - Time spent in the search: 33.31 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -2.326875     0.007589   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       1106  #> Residual Deviance: 801.7     AIC: 805.7 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 100  NaN 1.000  0.172  0.139  0.213 #> 2 464  NaN 1.000  0.767  0.724  0.806 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 516 #>  #> - Final Estimated Power: 0.845  #> - Confidence Interval: [0.806; 0.877] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 464 to 738  #> - Time spent in the search: 2.796 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.281835     0.005652   #>  #> Degrees of Freedom: 2399 Total (i.e. Null);  2398 Residual #> Null Deviance:       1965  #> Residual Deviance: 1906  AIC: 1910 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 464  NaN 1.000  0.767  0.724  0.806 #> 2 484  NaN 1.000  0.820  0.779  0.855 #> 3 516  NaN 1.000  0.845  0.806  0.877 #> 4 548  NaN 1.000  0.873  0.836  0.902 #> 5 611  NaN 1.000  0.900  0.867  0.926 #> 6 738  NaN 1.000  0.940  0.912  0.959 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Parallel Mediation with Observed Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m1 ~ x m2 ~ x m3 ~ x y ~ m1 + m2 + m3 + x \"  model_es <- \" m1 ~ x: m m2 ~ x: m m3 ~ x: m y ~ m1: s y ~ m2: m y ~ m3: l y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing all indirect effects by # Monte Carlo confidence intervals  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_k_indirect_effects,                   test_args = list(x = \"x\",                                    y = \"y\",                                    mc_ci = TRUE,                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Parallel Mediation with Observed Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Serial Mediation with Observed Variables","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Serial Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Serial Mediation with Observed Variables","text":"file serial mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Serial Mediation with Observed Variables","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_indirect_effect() Test indirect effect using Monte Carlo bootstrap confidence intervals. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Serial Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Serial Mediation with Observed Variables","text":"Load package first: Estimate power sample size. code model: Model results:","code":"library(power4mome) # ====== Model: Form ======  # Omit any paths hypothesized to be zero  model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \"  # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \" # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 50, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 50,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.500   #>   m2 ~                        #>     m1                0.500   #>     x                 0.000   #>   m3 ~                        #>     m2                0.500   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.750   #>    .m2                0.750   #>    .m3                0.750   #>    .y                 0.893   #>     x                 1.000   #>  #> (Computing indirect effects for 8 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.037 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #> x -> y                   0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd skew kurtosis   se #> m1    1 20000 -0.01 1.00 0.03    -0.04 0.01 #> m2    2 20000  0.00 1.00 0.01     0.06 0.01 #> m3    3 20000 -0.01 1.00 0.01    -0.05 0.01 #> y     4 20000 -0.01 1.00 0.01    -0.03 0.01 #> x     5 20000  0.00 1.01 0.00    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 20000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.493 #>   m2 ~                      #>     m1                0.498 #>     x                 0.010 #>   m3 ~                      #>     m2                0.499 #>     m1               -0.001 #>     x                 0.011 #>   y ~                       #>     m3                0.296 #>     m2               -0.002 #>     m1                0.014 #>     x                 0.086 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        14 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.036 1.000  0.372  0.327  0.421 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Serial Mediation with Observed Variables","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 107 power significantly lower .80, sample sizes higher 130 power significantly higher .80. words, sample sizes 107 130 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 107 to 130 #> - significantly lower than 0.800: 107 #> - significantly higher than 0.800: 130 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (107): [0.724, 0.806] #> - for the upper bound (130): [0.817, 0.886] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 107 #>  #> - Final Estimated Power: 0.767  #> - Confidence Interval: [0.724; 0.806] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 107 to 50  #> - Time spent in the search: 20.17 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -2.0266       0.0301   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       1093  #> Residual Deviance: 962   AIC: 966 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.036 1.000  0.372  0.327  0.421 #> 2 107 0.036 1.000  0.767  0.724  0.806 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 130 #>  #> - Final Estimated Power: 0.855  #> - Confidence Interval: [0.817; 0.886] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 107 to 181  #> - Time spent in the search: 1.359 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.61185      0.02615   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       1659  #> Residual Deviance: 1571  AIC: 1575 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 107 0.036 1.000  0.767  0.724  0.806 #> 2 112 0.038 1.000  0.795  0.753  0.832 #> 3 130 0.038 1.000  0.855  0.817  0.886 #> 4 147 0.039 1.000  0.890  0.856  0.917 #> 5 181 0.038 1.000  0.965  0.942  0.979 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Serial Mediation with Observed Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \"  model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 50, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 50,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Serial Mediation with Observed Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Simple Mediation with Observed Variables","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Simple Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Simple Mediation with Observed Variables","text":"file simple mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Simple Mediation with Observed Variables","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_indirect_effect() Test indirect effect using Monte Carlo bootstrap confidence intervals. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Simple Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Simple Mediation with Observed Variables","text":"Load package first: Estimate power sample size. code model: Model results:","code":"library(power4mome) # ====== Model: Form ======  model <- \" m ~ x y ~ m + x \"  # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  model_es <- \" m ~ x: s y ~ m: l y ~ x: m \" # ====== Test the Model Specification ======  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.100   #>   y ~                         #>     m                 0.500   #>     x                 0.300   #>  #> Variances: #>                    Population #>    .m                 0.990   #>    .y                 0.630   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.050 #> x -> y      0.300 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01    -0.01 0.01 #> y    2 40000 -0.01  1 -0.02    -0.03 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.099 #>   y ~                       #>     m                 0.499 #>     x                 0.305 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.049 1.000  0.195  0.159  0.237 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Simple Mediation with Observed Variables","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 718 power significantly lower .80, sample sizes higher 901 power significantly higher .80. words, sample sizes 718 901 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 718 to 901 #> - significantly lower than 0.800: 718 #> - significantly higher than 0.800: 901 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (718): [0.726, 0.809] #> - for the upper bound (901): [0.790, 0.864] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 718 #>  #> - Final Estimated Power: 0.770  #> - Confidence Interval: [0.726; 0.809] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 901  #> - Time spent in the search: 1.402 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.614470     0.003871   #>  #> Degrees of Freedom: 2399 Total (i.e. Null);  2398 Residual #> Null Deviance:       3124  #> Residual Deviance: 2610  AIC: 2614 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.049 1.000  0.195  0.159  0.237 #> 2 410 0.049 1.000  0.537  0.489  0.586 #> 3 656 0.050 1.000  0.718  0.671  0.759 #> 4 718 0.050 1.000  0.770  0.726  0.809 #> 5 779 0.051 1.000  0.818  0.777  0.852 #> 6 901 0.049 1.000  0.830  0.790  0.864 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 901 #>  #> - Final Estimated Power: 0.830  #> - Confidence Interval: [0.790; 0.864] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within  of 0.800  #> - The range of values explored: 100 to 901  #> - Time spent in the search: 0.07431 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_curve_args$power_model,  #>     start = power_curve_args$start, lower_bound = power_curve_args$lower_bound,  #>     upper_bound = power_curve_args$upper_bound, nls_args = power_curve_args$nls_args,  #>     nls_control = power_curve_args$nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.614470     0.003871   #>  #> Degrees of Freedom: 2399 Total (i.e. Null);  2398 Residual #> Null Deviance:       3124  #> Residual Deviance: 2610  AIC: 2614 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.049 1.000  0.195  0.159  0.237 #> 2 410 0.049 1.000  0.537  0.489  0.586 #> 3 656 0.050 1.000  0.718  0.671  0.759 #> 4 718 0.050 1.000  0.770  0.726  0.809 #> 5 779 0.051 1.000  0.818  0.777  0.852 #> 6 901 0.049 1.000  0.830  0.790  0.864 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Simple Mediation with Observed Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m ~ x y ~ m + x \" model_es <- \" m ~ x: s y ~ m: l y ~ x: m \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_simple.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Simple Mediation with Observed Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Simple Moderation with Observed Variables","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Simple Moderation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Simple Moderation with Observed Variables","text":"file moderation models one moderator.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Simple Moderation with Observed Variables","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_parameters() Test selected parameters. Used power4test() test selected product term (interaction term).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Simple Moderation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Simple Moderation with Observed Variables","text":"Load package first: Estimate power sample size. code model: Model results:","code":"library(power4mome) # ====== Model: Form ======  model <- \" y ~ x + w + x:w \"  # ====== Model: Population Values ======  # For a regression coefficient # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # For the product term: # l: large (.15 by default) # m: medium (.10 by default) # s: small (.05 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  # For a path moderated, the coefficient # of a predictor is its standardized # effect when the moderator equal to # its mean.  model_es <- \" y ~ x: m y ~ w: s y ~ x:w: l \" # ====== Test the Model Specification ======  # Fit the model by regression using lm() # Add: fit_model_args = list(fit_function = \"lm\")  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   fit_model_args = list(fit_function = \"lm\"),                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 50. # Test the coefficient of the product term # x:w in the regression results of lm(). # The test by CI is equivalent to the two-tailed t-test.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 50,                   fit_model_args = list(fit_function = \"lm\"),                   test_fun = test_parameters,                   test_args = list(pars = \"y~x:w\"),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> y ~ x + w + x:w #>  #> == Model on Variables/Indicators == #>  #> y ~ x + w + x:w #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   y ~                         #>     x                 0.300   #>     w                 0.100   #>     x:w               0.150   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .y                 0.877   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Conditional effects == #>  #>  Path: x -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w)   ind #> 1 M+1.0SD   1 0.450 #> 2 Mean      0 0.300 #> 3 M-1.0SD  -1 0.150 #>  #>  - The 'ind' column shows the conditional effects. #>   #>  #> == Conditional effects == #>  #>  Path: w -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)    ind #> 1 M+1.0SD   1  0.250 #> 2 Mean      0  0.100 #> 3 M-1.0SD  -1 -0.050 #>  #>  - The 'ind' column shows the conditional effects. #>   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n  mean   sd  skew kurtosis   se #> y      1 20000 -0.01 1.00  0.03     0.02 0.01 #> x      2 20000 -0.01 1.00  0.04    -0.01 0.01 #> w      3 20000  0.00 1.01 -0.02     0.02 0.01 #> x:w    4 20000 -0.01 1.01 -0.01     5.04 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 20000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   y ~                       #>     x                 0.296 #>     w                 0.091 #>     x:w               0.153 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                -0.011 #>     x:w               0.000 #>   w ~~                      #>     x:w              -0.014 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #>  #> The models: #> y ~ x + w + x:w #> <environment: 0x0000020858857e40> #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_parameters: CIs (pars: y~x:w) #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_parameters: CIs (pars: y~x:w)  #> [test_label]: y~x:w  #>     est   p.v reject r.cilo r.cihi #> 1 0.146 1.000  0.172  0.139  0.213 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Simple Moderation with Observed Variables","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 303 power significantly lower .80, sample sizes higher 336 power significantly higher .80. words, sample sizes 303 336 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 303 to 336 #> - significantly lower than 0.800: 303 #> - significantly higher than 0.800: 336 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (303): [0.716, 0.799] #> - for the upper bound (336): [0.809, 0.879] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 303 #>  #> - Final Estimated Power: 0.760  #> - Confidence Interval: [0.716; 0.799] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 232 to 50  #> - Time spent in the search: 21.68 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -1.9878       0.0111   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       2104  #> Residual Deviance: 1582  AIC: 1586 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: y~x:w)  #> [test_label]: y~x:w  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.146 1.000  0.172  0.139  0.213 #> 2 232 0.154 1.000  0.708  0.661  0.750 #> 3 303 0.148 1.000  0.760  0.716  0.799 #> 4 374 0.156 1.000  0.890  0.856  0.917 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 336 #>  #> - Final Estimated Power: 0.848  #> - Confidence Interval: [0.809; 0.879] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 336 to 374  #> - Time spent in the search: 6.833 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.606100     0.009885   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       622  #> Residual Deviance: 618.8     AIC: 622.8 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: y~x:w)  #> [test_label]: y~x:w  #>     n   est   p.v reject r.cilo r.cihi #> 1 336 0.154 1.000  0.848  0.809  0.879 #> 2 374 0.156 1.000  0.890  0.856  0.917 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Simple Moderation with Observed Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" y ~ x + w + x:w \" model_es <- \" y ~ x: m y ~ w: s y ~ x:w: l \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   fit_model_args = list(fit_function = \"lm\"),                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 50. # Test the coefficient of the product term # x:w in the regression results of lm(). # The test by CI is equivalent to the two-tailed t-test.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 50,                   fit_model_args = list(fit_function = \"lm\"),                   test_fun = test_parameters,                   test_args = list(pars = \"y~x:w\"),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_simple.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Simple Moderation with Observed Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"file moderation models two moderators, two-way interaction effects involved.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_parameters() Test selected parameters. Used power4test() test selected product term (interaction term).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"Load package first: Estimate power sample size. case two moderators illustrated code can easily extended number moderators. code model: Model results:","code":"library(power4mome) # ====== Model: Form ======  # Make sure all 1st order terms (w1, w2, w3, etc.) are included  model <- \" y ~ x + w1 + w2 + x:w1 + x:w2 \"  # ====== Model: Population Values ======  # For a regression coefficient # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # For the product term: # l: large (.15 by default) # m: medium (.10 by default) # s: small (.05 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  # For a path moderated, the coefficient # of a predictor is its standardized # effect when the moderator equal to # its mean.  model_es <- \" y ~ x: s y ~ w1: s y ~ w2: s y ~ x:w1: l y ~ x:w2: m \" # ====== Test the Model Specification ======  # Fit the model by regression using lm() # Add: fit_model_args = list(fit_function = \"lm\")  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   fit_model_args = list(fit_function = \"lm\"),                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 100. # Find the power with *both* x:w1 and x:w2 significant. # in the regression results of lm(). # The test by CI is equivalent to the two-tailed t-test. # Add omnibus = \"all_sig\" to find this power.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   fit_model_args = list(fit_function = \"lm\"),                   test_fun = test_parameters,                   test_args = list(pars = c(\"y~x:w1\",                                             \"y~x:w2\"),                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> y ~ x + w1 + w2 + x:w1 + x:w2 #>  #> == Model on Variables/Indicators == #>  #> y ~ x + w1 + w2 + x:w1 + x:w2 #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   y ~                         #>     x                 0.100   #>     w1                0.100   #>     w2                0.100   #>     x:w1              0.150   #>     x:w2              0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w1                0.000   #>     w2                0.000   #>     x:w1              0.000   #>     x:w2              0.000   #>   w1 ~~                       #>     w2                0.000   #>     x:w1              0.000   #>     x:w2              0.000   #>   w2 ~~                       #>     x:w1              0.000   #>     x:w2              0.000   #>   x:w1 ~~                     #>     x:w2              0.000   #>  #> Variances: #>                    Population #>    .y                 0.937   #>     x                 1.000   #>     w1                1.000   #>     w2                1.000   #>     x:w1              1.000   #>     x:w2              1.000   #>  #> (Computing conditional effects for 3 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Conditional effects == #>  #>  Path: x -> y #>  Conditional on moderator(s): w1, w2 #>  Moderator(s) represented by: w1, w2 #>  #>      [w1]    [w2] (w1) (w2)    ind #> 1 M+1.0SD M+1.0SD    1    1  0.350 #> 2 M+1.0SD M-1.0SD    1   -1  0.150 #> 3 M-1.0SD M+1.0SD   -1    1  0.050 #> 4 M-1.0SD M-1.0SD   -1   -1 -0.150 #>  #>  - The 'ind' column shows the conditional effects. #>   #>  #> == Conditional effects == #>  #>  Path: w1 -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)    ind #> 1 M+1.0SD   1  0.250 #> 2 Mean      0  0.100 #> 3 M-1.0SD  -1 -0.050 #>  #>  - The 'ind' column shows the conditional effects. #>   #>  #> == Conditional effects == #>  #>  Path: w2 -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)   ind #> 1 M+1.0SD   1 0.200 #> 2 Mean      0 0.100 #> 3 M-1.0SD  -1 0.000 #>  #>  - The 'ind' column shows the conditional effects. #>   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>      vars     n  mean sd skew kurtosis   se #> y       1 40000  0.00  1 0.03     0.04 0.01 #> x       2 40000 -0.01  1 0.00     0.02 0.01 #> w1      3 40000  0.01  1 0.01    -0.03 0.01 #> w2      4 40000  0.00  1 0.00     0.01 0.01 #> x:w1    5 40000  0.00  1 0.04     5.73 0.01 #> x:w2    6 40000  0.00  1 0.02     6.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   y ~                       #>     x                 0.094 #>     w1                0.095 #>     w2                0.106 #>     x:w1              0.149 #>     x:w2              0.099 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w1               -0.001 #>     w2                0.002 #>     x:w1              0.022 #>     x:w2              0.007 #>   w1 ~~                     #>     w2                0.004 #>     x:w1             -0.000 #>     x:w2              0.004 #>   w2 ~~                     #>     x:w1              0.004 #>     x:w2             -0.009 #>   x:w1 ~~                   #>     x:w2              0.002 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #>  #> The models: #> y ~ x + w1 + w2 + x:w1 + x:w2 #> <environment: 0x00000208641ac778> #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_parameters: CIs (pars: y~x:w1,y~x:w2) #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_parameters: CIs (pars: y~x:w1,y~x:w2)  #> [test_label]: All sig  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.062  0.043  0.091 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 709 power significantly lower .80, sample sizes higher 838 power significantly higher .80. words, sample sizes 709 838 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 709 to 838 #> - significantly lower than 0.800: 709 #> - significantly higher than 0.800: 838 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (709): [0.718, 0.802] #> - for the upper bound (838): [0.793, 0.866] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 709 #>  #> - Final Estimated Power: 0.762  #> - Confidence Interval: [0.718; 0.802] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 985  #> - Time spent in the search: 59.23 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -2.576927     0.005038   #>  #> Degrees of Freedom: 3199 Total (i.e. Null);  3198 Residual #> Null Deviance:       3753  #> Residual Deviance: 2765  AIC: 2769 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: y~x:w1,y~x:w2)  #> [test_label]: All sig  #>      n  est   p.v reject r.cilo r.cihi #> 1  100  NaN 1.000  0.062  0.043  0.091 #> 2  690  NaN 1.000  0.715  0.669  0.757 #> 3  709  NaN 1.000  0.762  0.718  0.802 #> 4  727  NaN 1.000  0.787  0.745  0.825 #> 5  764  NaN 1.000  0.830  0.790  0.864 #> 6  838  NaN 1.000  0.833  0.793  0.866 #> 7  985  NaN 1.000  0.890  0.856  0.917 #> 8 1280  NaN 1.000  0.935  0.906  0.955 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 838 #>  #> - Final Estimated Power: 0.833  #> - Confidence Interval: [0.793; 0.866] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within  of 0.800  #> - The range of values explored: 100 to 985  #> - Time spent in the search: 0.5908 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_curve_args$power_model,  #>     start = power_curve_args$start, lower_bound = power_curve_args$lower_bound,  #>     upper_bound = power_curve_args$upper_bound, nls_args = power_curve_args$nls_args,  #>     nls_control = power_curve_args$nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -2.576927     0.005038   #>  #> Degrees of Freedom: 3199 Total (i.e. Null);  3198 Residual #> Null Deviance:       3753  #> Residual Deviance: 2765  AIC: 2769 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: y~x:w1,y~x:w2)  #> [test_label]: All sig  #>      n  est   p.v reject r.cilo r.cihi #> 1  100  NaN 1.000  0.062  0.043  0.091 #> 2  690  NaN 1.000  0.715  0.669  0.757 #> 3  709  NaN 1.000  0.762  0.718  0.802 #> 4  727  NaN 1.000  0.787  0.745  0.825 #> 5  764  NaN 1.000  0.830  0.790  0.864 #> 6  838  NaN 1.000  0.833  0.793  0.866 #> 7  985  NaN 1.000  0.890  0.856  0.917 #> 8 1280  NaN 1.000  0.935  0.906  0.955 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" y ~ x + w1 + w2 + x:w1 + x:w2 \" model_es <- \" y ~ x: s y ~ w1: s y ~ w2: s y ~ x:w1: l y ~ x:w2: m \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   fit_model_args = list(fit_function = \"lm\"),                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100. # Find the power with *both* x:w1 and x:w2 significant. # in the regression results of lm(). # The test by CI is equivalent to the two-tailed t-test. # Add omnibus = \"all_sig\" to find this power.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   fit_model_args = list(fit_function = \"lm\"),                   test_fun = test_parameters,                   test_args = list(pars = c(\"y~x:w1\",                                             \"y~x:w2\"),                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_moderation_obs_two_ws.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Moderation with Observed Variables: Two Moderators","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"file moderated mediation model one mediator, path moderated.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_index_of_mome() Test moderated mediation index moderated mediation. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"Load package first: Estimate power sample size. code model: Model results:","code":"library(power4mome) # ====== Model: Form ======  model <- \" m ~ x + w + x:w y ~ m + x \"  # ====== Model: Population Values ======  # For a regression coefficient # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # For the product term: # l: large (.15 by default) # m: medium (.10 by default) # s: small (.05 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  # For a path moderated, the coefficient # of a predictor is its standardized # effect when the moderator equal to # its mean.  model_es <- \" m ~ x: m m ~ w: s m ~ x:w: l y ~ m: l y ~ x: s \" # ====== Test the Model Specification ======  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 100, # when testing the index of moderated mediation by # Monte Carlo confidence interval.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_index_of_mome,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    w = \"w\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.100   #>     x:w               0.150   #>   y ~                         #>     m                 0.500   #>     x                 0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.877   #>    .y                 0.710   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Effect(s) == #>  #>          ind #> x -> y 0.100 #>  #>  - The 'ind' column shows the effect(s). #>   #> == Conditional indirect effects == #>  #>  Path: x -> m -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w)   ind   m~x   y~m #> 1 M+1.0SD   1 0.225 0.450 0.500 #> 2 Mean      0 0.150 0.300 0.500 #> 3 M-1.0SD  -1 0.075 0.150 0.500 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - 'm~x','y~m' is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> == Conditional indirect effects == #>  #>  Path: w -> m -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)    ind    m~w   y~m #> 1 M+1.0SD   1  0.125  0.250 0.500 #> 2 Mean      0  0.050  0.100 0.500 #> 3 M-1.0SD  -1 -0.025 -0.050 0.500 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - 'm~w','y~m' is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n mean   sd  skew kurtosis   se #> m      1 40000    0 1.00  0.04     0.02 0.01 #> y      2 40000    0 1.01  0.00    -0.01 0.01 #> x      3 40000    0 1.01  0.03     0.04 0.01 #> w      4 40000    0 1.00  0.00     0.03 0.00 #> x:w    5 40000    0 1.00 -0.07     5.89 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.304 #>     w                 0.104 #>     x:w               0.156 #>   y ~                       #>     m                 0.500 #>     x                 0.104 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                -0.003 #>     x:w              -0.003 #>   w ~~                      #>     x:w              -0.008 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.128 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.938 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_index_of_mome: x->m->y, moderated by w #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.077 1.000  0.362  0.317  0.411 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 268 power significantly lower .80, sample sizes higher 360 power significantly higher .80. words, sample sizes 268 360 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 268 to 360 #> - significantly lower than 0.800: 268 #> - significantly higher than 0.800: 360 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (268): [0.700, 0.785] #> - for the upper bound (360): [0.812, 0.882] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 268 #>  #> - Final Estimated Power: 0.745  #> - Confidence Interval: [0.700; 0.785] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 408  #> - Time spent in the search: 2.131 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.472763     0.009248   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2473  #> Residual Deviance: 2148  AIC: 2152 #>  #> - Detailed Results: #>  #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.077 1.000  0.362  0.317  0.411 #> 2 221 0.074 1.000  0.640  0.592  0.686 #> 3 268 0.075 1.000  0.745  0.700  0.785 #> 4 315 0.076 1.000  0.800  0.758  0.836 #> 5 408 0.076 1.000  0.907  0.875  0.932 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 360 #>  #> - Final Estimated Power: 0.850  #> - Confidence Interval: [0.812; 0.882] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 360 to 408  #> - Time spent in the search: 31.87 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.38203      0.01144   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       591.1  #> Residual Deviance: 584.8     AIC: 588.8 #>  #> - Detailed Results: #>  #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 360 0.075 1.000  0.850  0.812  0.882 #> 2 408 0.076 1.000  0.907  0.875  0.932 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m ~ x + w + x:w y ~ m + x \" model_es <- \" m ~ x: m m ~ w: s m ~ x:w: l y ~ m: l y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   fit_model_args = list(fit_function = \"lm\"),                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing the index of moderated mediation by # Monte Carlo confidence interval.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_index_of_mome,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    w = \"w\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_a.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Simple Moderated Mediation with Observed Variables: a-Path Moderated","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"“Quick Template” articles examples R code determine range sample sizes target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), refer Get-Started article. Please also refer help page n_region_from_power(), article n_from_power(), called twice n_region_from_power() find regions described .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"file moderated mediation models one mediator, b path moderated.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"functions-used-in-this-template","dir":"Articles","previous_headings":"","what":"Functions Used in This Template","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"power4test() Set model population values, generate data, generate Monte Carlo simulated estimates Monte Carlo confidence interval. n_region_from_power() Find regions sample sizes based target power. test_index_of_mome() Test moderated mediation index moderated mediation. Used power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., region sample sizes power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"set-up-the-model-and-test","dir":"Articles","previous_headings":"","what":"Set Up The Model and Test","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"Load package first: Estimate power sample size. code model: Model results:","code":"library(power4mome) # ====== Model: Form ======  model <- \" m ~ x y ~ m + x + w + m:w \"  # ====== Model: Population Values ======  # For a regression coefficient # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # n: nil (.00 by default) # For the product term: # l: large (.15 by default) # m: medium (.10 by default) # s: small (.05 by default) # -l, -m, and -s denote negative values # Omitted paths are zero by default # Can also set to a number directly # Set each path to the hypothesized magnitude  # For a path moderated, the coefficient # of a predictor is its standardized # effect when the moderator equal to # its mean.  model_es <- \" m ~ x: m y ~ w: s y ~ m:w: l y ~ m: m y ~ x: s \" # ====== Test the Model Specification ======  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # ====== Check the Data Generated ======  print(out,       data_long = TRUE)  # ====== Estimate the Power ======  # For n = 100, # when testing the index of moderated mediation by # Monte Carlo confidence interval.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_index_of_mome,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    w = \"w\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  # ====== Compute the Rejection Rate ======  rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x + w + m:w #>  #> m ~~ m:w #> m:w ~~ w #> m ~~ w #> m:w ~~ x #> w ~~ x #>  #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x + w + m:w #>  #> m ~~ m:w #> m:w ~~ w #> m ~~ w #> m:w ~~ x #> w ~~ x #>  #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>     w                 0.100   #>     m:w               0.150   #>  #> Covariances: #>                    Population #>  .m ~~                        #>     m:w               0.000   #>   m:w ~~                      #>     w                 0.000   #>  .m ~~                        #>     w                 0.000   #>   m:w ~~                      #>     x                 0.000   #>   w ~~                        #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.849   #>     x                 1.000   #>     w                 1.000   #>     m:w               1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Effect(s) == #>  #>          ind #> x -> y 0.100 #>  #>  - The 'ind' column shows the effect(s). #>   #> == Conditional indirect effects == #>  #>  Path: x -> m -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w)   ind   m~x   y~m #> 1 M+1.0SD   1 0.135 0.300 0.450 #> 2 Mean      0 0.090 0.300 0.300 #> 3 M-1.0SD  -1 0.045 0.300 0.150 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - 'm~x','y~m' is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n  mean sd skew kurtosis   se #> m      1 40000  0.00  1 0.00     0.00 0.01 #> y      2 40000  0.00  1 0.02     0.03 0.01 #> m:w    3 40000  0.01  1 0.11     6.22 0.01 #> x      4 40000  0.00  1 0.00     0.03 0.00 #> w      5 40000 -0.01  1 0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.303 #>   y ~                       #>     m                 0.303 #>     x                 0.092 #>     w                 0.100 #>     m:w               0.152 #>  #> Covariances: #>                     est.std #>  .m ~~                      #>     m:w              -0.004 #>   m:w ~~                    #>     w                -0.005 #>  .m ~~                      #>     w                 0.006 #>   m:w ~~                    #>     x                -0.000 #>   x ~~                      #>     w                 0.006 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 16 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        15 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_index_of_mome: x->m->y, moderated by w #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.046 1.000  0.287  0.245  0.334 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"Search, simulation, following two regions sample sizes: Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). Sample sizes estimated levels power significantly target level (e.g., .80), tested confidence interval (95% default). practice, rarely need high precision regions sample size planning. Therefore, need find two sample sizes corresponding confidence bounds close enough target power, defined tolerance value. function , value .02 default. can take time run estimated power sample size different target power. can find two regions n_region_from_power(). code: results: Power Curve shown , approximately: sample sizes lower 317 power significantly lower .80, sample sizes higher 327 power significantly higher .80. words, sample sizes 317 327 power significantly different .80. necessary, detailed results can printed summary():","code":"# # ===== Reuse the output of power4test() ===== # # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357)  # ===== Basic Results =====  n_power_region  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Basic Results =====  n_power_region #> Call: #> n_region_from_power(object = out, seed = 1357) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 317 to 327 #> - significantly lower than 0.800: 317 #> - significantly higher than 0.800: 327 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (317): [0.737, 0.818] #> - for the upper bound (327): [0.812, 0.882] #>  #> Call `summary()` for detailed results.  # ===== Plot the (Crude) Power Curve and the Regions =====  plot(n_power_region) # ===== Detailed Results ===== summary(n_power_region) #>  #> ======<< Summary for the Lower Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 317 #>  #> - Final Estimated Power: 0.780  #> - Confidence Interval: [0.737; 0.818] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 431  #> - Time spent in the search: 2.373 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.89971      0.01025   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2383  #> Residual Deviance: 1915  AIC: 1919 #>  #> - Detailed Results: #>  #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.046 1.000  0.287  0.245  0.334 #> 2 278 0.045 1.000  0.738  0.692  0.778 #> 3 317 0.045 1.000  0.780  0.737  0.818 #> 4 355 0.045 1.000  0.868  0.831  0.897 #> 5 431 0.044 1.000  0.912  0.881  0.936 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #>  #>  #> ======<< Summary for the Upper Region >>====== #>  #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, seed = 1357, x = \"n\",  #>     what = \"lb\", goal = \"close_enough\") #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 327 #>  #> - Final Estimated Power: 0.850  #> - Confidence Interval: [0.812; 0.882] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 327 to 355  #> - Time spent in the search: 34.76 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    0.047844     0.005158   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       651.6  #> Residual Deviance: 651.1     AIC: 655.1 #>  #> - Detailed Results: #>  #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 327 0.046 1.000  0.850  0.812  0.882 #> 2 355 0.045 1.000  0.868  0.831  0.897 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m ~ x y ~ m + x + w + m:w \" model_es <- \" m ~ x: m y ~ w: s y ~ m:w: l y ~ m: m y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   fit_model_args = list(fit_function = \"lm\"),                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing the index of moderated mediation by # Monte Carlo confidence interval.  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_index_of_mome,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    w = \"w\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE)  rejection_rates(out)  # ====== Regions of Ns ======  # Call n_region_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_region <- n_region_from_power(out,                                       seed = 1357) n_power_region plot(n_power_region) summary(n_power_region)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mome_obs_b.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Simple Moderated Mediation with Observed Variables: b-Path Moderated","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Function: Parallel Mediation with Latent Variables","text":"“Quick Function” articles examples R code determine range sample sizes target level power estimate power specific scenario typical mediation models using power4mome. Users can quickly adapt scenarios. -guides cover technical details involved.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Function: Parallel Mediation with Latent Variables","text":"functions wrappers power4test() n_region_from_power(). simple scenarios, users need know use advanced functions, though knowledge can help customizing search region. information functions can found Final Remarks","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Function: Parallel Mediation with Latent Variables","text":"file parallel mediation models, use one function q_power_mediation_parallel() package power4mome.","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The Model","title":"Quick Function: Parallel Mediation with Latent Variables","text":"Suppose model: Model parallel mediation model, model latent variables, indicators. want power analysis indirect effects x y: x->m1->y x->m2->y. Suppose expected effects: x->m1: medium x->m2: large m1->y: large m2->y: medium x->y: small","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"convention","dir":"Articles","previous_headings":"The Model","what":"Convention for the Effect Sizes","title":"Quick Function: Parallel Mediation with Latent Variables","text":"make easy specify standardized population values parameters, power4mome adopted convention Pearson’s r, just convenience. \"nil\": Nil (.00). \"s\": Small (.10). \"m\": Medium (.30), \"l\": Large (.50). also two intermediate levels: \"sm\": Small--medium (.20). \"ml\": Medium--large (.40). effect negative, just add minus sign. example, use \"-m\" denote negative medium effect. path one variable another variable, standardized coefficient equal correlation predictor, predictor uncorrelated predictors. Therefore, though may perfect, believe convention Pearson’s r reasonable one. necessary, users can specify effect (standardized metric) directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"covariates-in-the-model-to-be-fitted","dir":"Articles","previous_headings":"The Model","what":"Covariates in the Model to be Fitted","title":"Quick Function: Parallel Mediation with Latent Variables","text":"applied research, model fitted usually control variables, educational level. may practical specify probable effects control variables (though possible power4mome). Therefore, conservative assessment power, users can first decide population effects, adjust slightly downward (e.g., medium, \"m\", small--medium, \"sm\") take account potential decrease effects due control variables included.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"model-with-hypothesized-path-coefficients","dir":"Articles","previous_headings":"The Model","what":"Model with Hypothesized Path Coefficients","title":"Quick Function: Parallel Mediation with Latent Variables","text":"model effect sizes, showing latent variables: Model (Effect Sizes)","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"test-to-be-used","dir":"Articles","previous_headings":"The Model","what":"Test to be Used","title":"Quick Function: Parallel Mediation with Latent Variables","text":"practice, nonparametric bootstrapping usually used test indirect effects. However, estimating power using simulation slow. good-enough proxy estimate power testing effect Monte Carlo confidence interval. default method power4mome tests indirect effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"setting-the-factor-loadings","dir":"Articles","previous_headings":"","what":"Setting the Factor Loadings","title":"Quick Function: Parallel Mediation with Latent Variables","text":"One difficulty power analysis latent variable model setting population values indicators. power4mome, instead setting factor loadings error variances, users can specify number indicators population reliability latent factor. corresponding factor loadings error variances computed specified automatically. Therefore, power analysis, users can just specify number indicators (items) factor, usually known exactly approximately advance. hypothesized population reliability coefficient may based previous studies set reasonable expectation (e.g., .70 minimal acceptable reliability).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"find-the-power","dir":"Articles","previous_headings":"","what":"Find the Power","title":"Quick Function: Parallel Mediation with Latent Variables","text":"estimate power sample size, code: : hypothesized standardized effects predictor x mediator. character vector elements equal number mediators path coefficients x->m1, x->m2, x->mk, k number mediators. Can one labels supported convention, numeric value. bs: hypothesized standardized effects mediator outcome variable y. character vector elements equal number mediators path coefficients m1->y, m2->y, mk->y, k number mediators. Can one labels supported convention, numeric value. cp: hypothesized standardized direct effect predictor x outcome variable y. Can one labels supported convention, numeric value. number_of_indicators: named numeric vector numbers indicators. names need x, m1, m2, … , y. one value, latent variables number indicators. reliability: named numeric vector population reliability. names need x, m1, m2, … , y. one value, latent variables value reliability. target_power: target level power. Default .80, can omitted desired level power nrep: number replications estimating power sample size. Default 400. Can omitted desired number replications. R: number random samples used forming Monte Carlo nonparametric bootstrapping confidence intervals. Although large testing effect one single sample, can smaller goal estimate power across replications, achieve high accuracy sample. Default 1000. Can omitted default acceptable. seed: seed random number generator. Note , parallel processing used (default), results reproducible configuration exactly identical. Moreover, changes algorithm also make results reproducible even seed. Nevertheless, still advised set seed integer, make results reproducible least machine. output: first set output default printout output power4test(). can used check model specified. also automatically computes population standardized indirect effect(s). second section output rejection_rates(), showing power column reject. example, power 0.89 sample size 300.","code":"out_power <- q_power_mediation_parallel(   as = c(\"m\", \"l\"),   bs = c(\"l\", \"m\"),   cp = \"s\",   number_of_indicators = c(x = 3,                            m1 = 4,                            m2 = 3,                            y = 3),   reliability = c(x = .70,                   m1 = .80,                   m2 = .70,                   y = .70),   target_power = .80,   nrep = 400,   n = 300,   R = 1000,   seed = 1234 ) out_power #>  #> ========== power4test Results ========== #>  #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #> == Model on Variables/Indicators == #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #> x =~ x1 + x2 + x3 #> m1 =~ m11 + m12 + m13 + m14 #> m2 =~ m21 + m22 + m23 #> y =~ y1 + y2 + y3 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.500   #>   y ~                         #>     m1                0.500   #>     m2                0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.750   #>    .y                 0.545   #>     x                 1.000   #>  #> (Computing indirect effects for 3 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.150 #> x -> m2 -> y 0.150 #> x -> y       0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>    x  m1  m2   y #>  0.7 0.8 0.7 0.7 #>  #> == Population Standardized Loadings == #>  #>      x    m1    m2     y #>  0.661 0.707 0.661 0.661 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  300  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 30 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        31 #>  #>   Number of observations                           300 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                98.780 #>   Degrees of freedom                                60 #>   P-value (Chi-square)                           0.001 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirects: x-...->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. #>  #> ========== power4test Power ========== #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.887  0.853  0.915 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> ========== n_region_from_power Results ========== #>  #>  #> 'mode' is not 'region' and results not available."},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"find-the-region-of-sample-sizes","dir":"Articles","previous_headings":"","what":"Find the Region of Sample Sizes","title":"Quick Function: Parallel Mediation with Latent Variables","text":"addition estimate power sample size, function can also used find approximate region sample sizes levels power significantly different target power. region useful determining range sample sizes likely sufficient power, greater necessary resources limited. Note process can slow. Nevertheless, power analysis usually conducted planning stage study, slow processing time acceptable stage. Finding region can done using code , argument mode = \"region\" added: printout, showing section output n_region_from_power(): example, range sample size 235 263. results can also visualized using plot() function: Plot Sample Sizes Searched region shaded areas approximate region sample sizes found.","code":"out_region <- q_power_mediation_parallel(   as = c(\"m\", \"l\"),   bs = c(\"l\", \"m\"),   cp = \"s\",   number_of_indicators = c(x = 3,                            m1 = 4,                            m2 = 3,                            y = 3),   reliability = c(x = .70,                   m1 = .80,                   m2 = .70,                   y = .70),   target_power = .80,   nrep = 400,   n = 300,   R = 1000,   seed = 1234,   mode = \"region\" ) #> ========== n_region_from_power Results ========== #>  #> Call: #> n_region_from_power(object = `<hidden>`, target_power = 0.8,  #>     progress = TRUE, simulation_progress = TRUE, max_trials = 10,  #>     seed = 1234) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 235 to 263 #> - significantly lower than 0.800: 235 #> - significantly higher than 0.800: 263 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (235): [0.708, 0.792] #> - for the upper bound (263): [0.790, 0.864] #>  #> Call `summary()` for detailed results."},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"other-models","dir":"Articles","previous_headings":"Final Remarks","what":"Other Models","title":"Quick Function: Parallel Mediation with Latent Variables","text":"Quick -articles common mediation models, including latent variables, can found list articles package power4mome supports arbitrary model specified lavaan syntax, including moderators. Interested users can refer articles .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_parallel.html","id":"technical-details","dir":"Articles","previous_headings":"Final Remarks","what":"Technical Details","title":"Quick Function: Parallel Mediation with Latent Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Function: Serial Mediation with Latent Variables","text":"“Quick Function” articles examples R code determine range sample sizes target level power estimate power specific scenario typical mediation models using power4mome. Users can quickly adapt scenarios. -guides cover technical details involved.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Function: Serial Mediation with Latent Variables","text":"functions wrappers power4test() n_region_from_power(). simple scenarios, users need know use advanced functions, though knowledge can help customizing search region. information functions can found Final Remarks","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Function: Serial Mediation with Latent Variables","text":"file serial mediation models, use one function q_power_mediation_serial() package power4mome.","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The Model","title":"Quick Function: Serial Mediation with Latent Variables","text":"Suppose model: Model serial mediation model, model latent variables, indicators. want power analysis indirect effect along path x->m1->m2->y. Suppose expected effects: x->m1: medium m1->m2: medium m2->y: large x->y: small paths involving mediators, x->m2 m1->y, assumed effect (nil).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"convention","dir":"Articles","previous_headings":"The Model","what":"Convention for the Effect Sizes","title":"Quick Function: Serial Mediation with Latent Variables","text":"make easy specify standardized population values parameters, power4mome adopted convention Pearson’s r, just convenience. \"nil\": Nil (.00). \"s\": Small (.10). \"m\": Medium (.30), \"l\": Large (.50). also two intermediate levels: \"sm\": Small--medium (.20). \"ml\": Medium--large (.40). effect negative, just add minus sign. example, use \"-m\" denote negative medium effect. path one variable another variable, standardized coefficient equal correlation predictor, predictor uncorrelated predictors. Therefore, though may perfect, believe convention Pearson’s r reasonable one. necessary, users can specify effect (standardized metric) directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"covariates-in-the-model-to-be-fitted","dir":"Articles","previous_headings":"The Model","what":"Covariates in the Model to be Fitted","title":"Quick Function: Serial Mediation with Latent Variables","text":"applied research, model fitted usually control variables, educational level. may practical specify probable effects control variables (though possible power4mome). Therefore, conservative assessment power, users can first decide population effects, adjust slightly downward (e.g., medium, \"m\", small--medium, \"sm\") take account potential decrease effects due control variables included.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"model-with-hypothesized-path-coefficients","dir":"Articles","previous_headings":"The Model","what":"Model with Hypothesized Path Coefficients","title":"Quick Function: Serial Mediation with Latent Variables","text":"model effect sizes: Model","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"test-to-be-used","dir":"Articles","previous_headings":"The Model","what":"Test to be Used","title":"Quick Function: Serial Mediation with Latent Variables","text":"practice, nonparametric bootstrapping usually used test indirect effects. However, estimating power using simulation slow. good-enough proxy estimate power testing effect Monte Carlo confidence interval. default method power4mome tests indirect effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"setting-the-factor-loadings","dir":"Articles","previous_headings":"","what":"Setting the Factor Loadings","title":"Quick Function: Serial Mediation with Latent Variables","text":"One difficulty power analysis latent variable model setting population values indicators. power4mome, instead setting factor loadings error variances, users can specify number indicators population reliability latent factor. corresponding factor loadings error variances computed specified automatically. Therefore, power analysis, users can just specify number indicators (items) factor, usually known exactly approximately advance. hypothesized population reliability coefficient may based previous studies set reasonable expectation (e.g., .70 minimal acceptable reliability).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"find-the-power","dir":"Articles","previous_headings":"","what":"Find the Power","title":"Quick Function: Serial Mediation with Latent Variables","text":"estimate power sample size, code: arguments: ab: hypothesized standardized effects along path predictor x outcome variable y. character vector elements equal number mediators path coefficients x->m1->m2->...->y. Can one labels supported convention, numeric value. ab_other: hypothesized standardized effect paths involving mediators. simplicity, support one value, value used paths. Can one labels supported convention, numeric value. cp: hypothesized standardized direct effect predictor x outcome variable y. Can one labels supported convention, numeric value. number_of_indicators: named numeric vector numbers indicators. names need x, m1, m2, … , y. one value, latent variables number indicators. reliability: named numeric vector population reliability. names need x, m1, m2, … , y. one value, latent variables value reliability. target_power: target level power. Default .80, can omitted desired level power nrep: number replications estimating power sample size. Default 400. Can omitted desired number replications. R: number random samples used forming Monte Carlo nonparametric bootstrapping confidence intervals. Although large testing effect one single sample, can smaller goal estimate power across replications, achieve high accuracy sample. Default 1000. Can omitted default acceptable. seed: seed random number generator. Note , parallel processing used (default), results reproducible configuration exactly identical. Moreover, changes algorithm also make results reproducible even seed. Nevertheless, still advised set seed integer, make results reproducible least machine. output: first set output default printout output power4test(). can used check model specified. also automatically computes population standardized indirect effect(s). second section output rejection_rates(), showing power column reject. example, power 0.44 sample size 150.","code":"out_power <- q_power_mediation_serial(   ab = c(\"m\", \"m\", \"l\"),   ab_other = \"nil\",   cp = \"s\",   number_of_indicators = c(x = 3,                            m1 = 4,                            m2 = 3,                            y = 3),   reliability = c(x = .70,                   m1 = .80,                   m2 = .70,                   y = .70),   target_power = .80,   nrep = 400,   n = 150,   R = 1000,   seed = 1234 ) out_power #>  #> ========== power4test Results ========== #>  #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m1 ~ x #> m2 ~ m1 + x #> y ~ m1 + m2 + x #> == Model on Variables/Indicators == #> m1 ~ x #> m2 ~ m1 + x #> y ~ m1 + m2 + x #> x =~ x1 + x2 + x3 #> m1 =~ m11 + m12 + m13 + m14 #> m2 =~ m21 + m22 + m23 #> y =~ y1 + y2 + y3 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     m1                0.300   #>     x                 0.000   #>   y ~                         #>     m1                0.000   #>     m2                0.500   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .y                 0.731   #>     x                 1.000   #>  #> (Computing indirect effects for 4 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                      ind #> x -> m1 -> m2 -> y 0.045 #> x -> m1 -> y       0.000 #> x -> m2 -> y       0.000 #> x -> y             0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>    x  m1  m2   y #>  0.7 0.8 0.7 0.7 #>  #> == Population Standardized Loadings == #>  #>      x    m1    m2     y #>  0.661 0.707 0.661 0.661 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  150  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 33 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        32 #>  #>   Number of observations                           150 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                55.395 #>   Degrees of freedom                                59 #>   P-value (Chi-square)                           0.609 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. #>  #> ========== power4test Power ========== #>  #> [test]: test_indirect: x->m1->m2->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.042 1.000  0.440  0.392  0.489 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> ========== n_region_from_power Results ========== #>  #>  #> 'mode' is not 'region' and results not available."},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"find-the-region-of-sample-sizes","dir":"Articles","previous_headings":"","what":"Find the Region of Sample Sizes","title":"Quick Function: Serial Mediation with Latent Variables","text":"addition estimate power sample size, function can also used find approximate region sample sizes levels power significantly different target power. region useful determining range sample sizes likely sufficient power, greater necessary resources limited. Note process can slow. Nevertheless, power analysis usually conducted planning stage study, slow processing time acceptable stage. Finding region can done using code , argument mode = \"region\" added: printout, showing section output n_region_from_power(): example, range sample size 212 243. results can also visualized using plot() function: Plot Sample Sizes Searched region shaded areas approximate region sample sizes found.","code":"out_region <- q_power_mediation_serial(   ab = c(\"m\", \"m\", \"l\"),   ab_other = \"nil\",   cp = \"s\",   number_of_indicators = c(x = 3,                            m1 = 4,                            m2 = 3,                            y = 3),   reliability = c(x = .70,                   m1 = .80,                   m2 = .70,                   y = .70),   target_power = .80,   nrep = 400,   n = 150,   R = 1000,   seed = 1234,   mode = \"region\" ) #> ========== n_region_from_power Results ========== #>  #> Call: #> n_region_from_power(object = `<hidden>`, target_power = 0.8,  #>     progress = TRUE, simulation_progress = TRUE, max_trials = 10,  #>     seed = 1234) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 212 to 243 #> - significantly lower than 0.800: 212 #> - significantly higher than 0.800: 243 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (212): [0.726, 0.809] #> - for the upper bound (243): [0.817, 0.886] #>  #> Call `summary()` for detailed results."},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"other-models","dir":"Articles","previous_headings":"Final Remarks","what":"Other Models","title":"Quick Function: Serial Mediation with Latent Variables","text":"Quick -articles common mediation models, including latent variables, can found list articles package power4mome supports arbitrary model specified lavaan syntax, including moderators. Interested users can refer articles .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_serial.html","id":"technical-details","dir":"Articles","previous_headings":"Final Remarks","what":"Technical Details","title":"Quick Function: Serial Mediation with Latent Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Function: Simple Mediation with Latent Variables","text":"“Quick Function” articles examples R code determine range sample sizes target level power estimate power specific scenario typical mediation models using power4mome. Users can quickly adapt scenarios. -guides cover technical details involved.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Function: Simple Mediation with Latent Variables","text":"functions wrappers power4test() n_region_from_power(). simple scenarios, users need know use advanced functions, though knowledge can help customizing search region. information functions can found Final Remarks","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Function: Simple Mediation with Latent Variables","text":"file simple mediation models, use one function q_power_mediation_simple() package power4mome.","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The Model","title":"Quick Function: Simple Mediation with Latent Variables","text":"Suppose model: Model want power analysis indirect effect along path x->m->y. Suppose expected effects: -path: medium b-path: medium c’-path: small","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"convention","dir":"Articles","previous_headings":"The Model","what":"Convention for the Effect Sizes","title":"Quick Function: Simple Mediation with Latent Variables","text":"make easy specify standardized population values parameters, power4mome adopted convention Pearson’s r, just convenience. \"nil\": Nil (.00). \"s\": Small (.10). \"m\": Medium (.30), \"l\": Large (.50). also two intermediate levels: \"sm\": Small--medium (.20). \"ml\": Medium--large (.40). effect negative, just add minus sign. example, use \"-m\" denote negative medium effect. path one variable another variable, standardized coefficient equal correlation predictor, predictor uncorrelated predictors. Therefore, though may perfect, believe convention Pearson’s r reasonable one. necessary, users can specify effect (standardized metric) directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"covariates-in-the-model-to-be-fitted","dir":"Articles","previous_headings":"The Model","what":"Covariates in the Model to be Fitted","title":"Quick Function: Simple Mediation with Latent Variables","text":"applied research, model fitted usually control variables, educational level. may practical specify probable effects control variables (though possible power4mome). Therefore, conservative assessment power, users can first decide population effects, adjust slightly downward (e.g., medium, \"m\", small--medium, \"sm\") take account potential decrease effects due control variables included.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"model-with-hypothesized-path-coefficients","dir":"Articles","previous_headings":"The Model","what":"Model with Hypothesized Path Coefficients","title":"Quick Function: Simple Mediation with Latent Variables","text":"model effect sizes, showing latent variables: Model Effect Sizes","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"test-to-be-used","dir":"Articles","previous_headings":"The Model","what":"Test to be Used","title":"Quick Function: Simple Mediation with Latent Variables","text":"practice, nonparametric bootstrapping usually used test indirect effects. However, estimating power using simulation slow. good-enough proxy estimate power testing effect Monte Carlo confidence interval. default method power4mome tests indirect effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"setting-the-factor-loadings","dir":"Articles","previous_headings":"","what":"Setting the Factor Loadings","title":"Quick Function: Simple Mediation with Latent Variables","text":"One difficulty power analysis latent variable model setting population values indicators. power4mome, instead setting factor loadings error variances, users can specify number indicators population reliability latent factor. corresponding factor loadings error variances computed specified automatically. Therefore, power analysis, users can just specify number indicators (items) factor, usually known exactly approximately advance. hypothesized population reliability coefficient may based previous studies set reasonable expectation (e.g., .70 minimal acceptable reliability).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"find-the-power","dir":"Articles","previous_headings":"","what":"Find the Power","title":"Quick Function: Simple Mediation with Latent Variables","text":"estimate power sample size, code: arguments: : hypothesized standardized effect predictor x mediator m. Can one labels supported convention, numeric value. b: hypothesized standardized effect mediator m outcome variable y. Can one labels supported convention, numeric value. cp: hypothesized standardized direct effect predictor x outcome variable y. Can one labels supported convention, numeric value. number_of_indicators: named numeric vector numbers indicators. names need x, m, y. one value, latent variables number indicators. reliability: named numeric vector population reliability. names need x, m, y. one value, latent variables value reliability. target_power: target level power. Default .80, can omitted desired level power nrep: number replications estimating power sample size. Default 400. Can omitted desired number replications. R: number random samples used forming Monte Carlo nonparametric bootstrapping confidence intervals. Although large testing effect one single sample, can smaller goal estimate power across replications, achieve high accuracy sample. Default 1000. Can omitted default acceptable. seed: seed random number generator. Note , parallel processing used (default), results reproducible configuration exactly identical. Moreover, changes algorithm also make results reproducible even seed. Nevertheless, still advised set seed integer, make results reproducible least machine. output: first set output default printout output power4test(). can used check model specified. also automatically computes population standardized indirect effect(s). second section output rejection_rates(), showing power column reject. example, power 0.50 sample size 150.","code":"out_power <- q_power_mediation_simple(   a = \"m\",   b = \"m\",   cp = \"s\",   number_of_indicators = c(x = 3,                            m = 4,                            y = 5),   reliability = c(x = .70,                   m = .75,                   y = .80),   target_power = .80,   nrep = 400,   n = 150,   R = 1000,   seed = 1234 ) out_power #>  #> ========== power4test Results ========== #>  #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #> m ~ x #> y ~ m + x #>  #> x =~ x1 + x2 + x3 #> m =~ m1 + m2 + m3 + m4 #> y =~ y1 + y2 + y3 + y4 + y5 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.882   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.090 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ==== Population Reliability ==== #>  #>    x    m   y #>  0.7 0.75 0.8 #>  #> == Population Standardized Loadings == #>  #>      x     m     y #>  0.661 0.655 0.667 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  150  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 28 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        27 #>  #>   Number of observations                           150 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                66.684 #>   Degrees of freedom                                51 #>   P-value (Chi-square)                           0.069 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. #>  #> ========== power4test Power ========== #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.092 1.000  0.500  0.451  0.549 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> ========== n_region_from_power Results ========== #>  #>  #> 'mode' is not 'region' and results not available."},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"find-the-region-of-sample-sizes","dir":"Articles","previous_headings":"","what":"Find the Region of Sample Sizes","title":"Quick Function: Simple Mediation with Latent Variables","text":"addition estimate power sample size, function can also used find approximate region sample sizes levels power significantly different target power. region useful determining range sample sizes likely sufficient power, greater necessary resources limited. Note process can slow. Nevertheless, power analysis usually conducted planning stage study, slow processing time acceptable stage. Finding region can done using code , argument mode = \"region\" added: printout, showing section output n_region_from_power(): example, range sample size 218 248. results can also visualized using plot() function: Plot Sample Sizes Searched region shaded areas approximate region sample sizes found.","code":"out_region <- q_power_mediation_simple(   a = \"m\",   b = \"m\",   cp = \"s\",   number_of_indicators = c(x = 3,                            m = 4,                            y = 5),   reliability = c(x = .70,                   m = .75,                   y = .80),   target_power = .80,   nrep = 400,   n = 150,   R = 1000,   seed = 1234,   mode = \"region\" ) #> ========== n_region_from_power Results ========== #>  #> Call: #> n_region_from_power(object = `<hidden>`, target_power = 0.8,  #>     progress = TRUE, simulation_progress = TRUE, max_trials = 10,  #>     seed = 1234) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 218 to 248 #> - significantly lower than 0.800: 218 #> - significantly higher than 0.800: 248 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (218): [0.729, 0.811] #> - for the upper bound (248): [0.812, 0.882] #>  #> Call `summary()` for detailed results."},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"other-models","dir":"Articles","previous_headings":"Final Remarks","what":"Other Models","title":"Quick Function: Simple Mediation with Latent Variables","text":"Quick -articles common mediation models, including latent variables, can found list articles package power4mome supports arbitrary model specified lavaan syntax, including moderators. Interested users can refer articles .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_lav_simple.html","id":"technical-details","dir":"Articles","previous_headings":"Final Remarks","what":"Technical Details","title":"Quick Function: Simple Mediation with Latent Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Function: Parallel Mediation with Observed Variables","text":"“Quick Function” articles examples R code determine range sample sizes target level power estimate power specific scenario typical mediation models using power4mome. Users can quickly adapt scenarios. -guides cover technical details involved.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Function: Parallel Mediation with Observed Variables","text":"functions wrappers power4test() n_region_from_power(). simple scenarios, users need know use advanced functions, though knowledge can help customizing search region. information functions can found Final Remarks","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Function: Parallel Mediation with Observed Variables","text":"file parallel mediation models, use one function q_power_mediation_parallel() package power4mome.","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The Model","title":"Quick Function: Parallel Mediation with Observed Variables","text":"Suppose model: Model want power analysis indirect effects x y: x->m1->y, x->m2->y, x->m2->y. Suppose expected effects: x->m1: small x->m2: medium x->m3: medium m1->y: large m2->y: medium m3->y: large x->y: nil (effect) power4mome, convention Pearson’s r used just convenience. necessary, users can specify effect (standardized metric) directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"convention","dir":"Articles","previous_headings":"The Model","what":"Convention for the Effect Sizes","title":"Quick Function: Parallel Mediation with Observed Variables","text":"make easy specify standardized population values parameters, power4mome adopted convention Pearson’s r, just convenience. \"nil\": Nil (.00). \"s\": Small (.10). \"m\": Medium (.30), \"l\": Large (.50). also two intermediate levels: \"sm\": Small--medium (.20). \"ml\": Medium--large (.40). effect negative, just add minus sign. example, use \"-m\" denote negative medium effect. path one variable another variable, standardized coefficient equal correlation predictor, predictor uncorrelated predictors. Therefore, though may perfect, believe convention Pearson’s r reasonable one. necessary, users can specify effect (standardized metric) directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"covariates-in-the-model-to-be-fitted","dir":"Articles","previous_headings":"The Model","what":"Covariates in the Model to be Fitted","title":"Quick Function: Parallel Mediation with Observed Variables","text":"applied research, model fitted usually control variables, educational level. may practical specify probable effects control variables (though possible power4mome). Therefore, conservative assessment power, users can first decide population effects, adjust slightly downward (e.g., medium, \"m\", small--medium, \"sm\") take account potential decrease effects due control variables included.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"model-with-hypothesized-path-coefficients","dir":"Articles","previous_headings":"The Model","what":"Model with Hypothesized Path Coefficients","title":"Quick Function: Parallel Mediation with Observed Variables","text":"model effect sizes: Model (Effect Sizes)","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"omnibus-power-for-all-indirect-paths","dir":"Articles","previous_headings":"The Model","what":"Omnibus Power for All Indirect Paths","title":"Quick Function: Parallel Mediation with Observed Variables","text":"one indirect path, one tests. function power4mome supports finding power detecting indirect paths, , probability tests indirect effects significant. call power omnibus power indirect paths.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"test-to-be-used","dir":"Articles","previous_headings":"The Model","what":"Test to be Used","title":"Quick Function: Parallel Mediation with Observed Variables","text":"practice, nonparametric bootstrapping usually used test indirect effects. However, estimating power using simulation slow. good-enough proxy estimate power testing effect Monte Carlo confidence interval. default method power4mome tests indirect effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"find-the-power","dir":"Articles","previous_headings":"","what":"Find the Power","title":"Quick Function: Parallel Mediation with Observed Variables","text":"estimate power sample size, code: arguments: : hypothesized standardized effects predictor x mediator. character vector elements equal number mediators path coefficients x->m1, x->m2, x->mk, k number mediators. Can one labels supported convention, numeric value. bs: hypothesized standardized effects mediator outcome variable y. character vector elements equal number mediators path coefficients m1->y, m2->y, mk->y, k number mediators. Can one labels supported convention, numeric value. cp: hypothesized standardized direct effect predictor x outcome variable y. Can one labels supported convention, numeric value. target_power: target level power. Default .80, can omitted desired level power nrep: number replications estimating power sample size. Default 400. Can omitted desired number replications. R: number random samples used forming Monte Carlo nonparametric bootstrapping confidence intervals. Although large testing effect one single sample, can smaller goal estimate power across replications, achieve high accuracy sample. Default 1000. Can omitted default acceptable. seed: seed random number generator. Note , parallel processing used (default), results reproducible configuration exactly identical. Moreover, changes algorithm also make results reproducible even seed. Nevertheless, still advised set seed integer, make results reproducible least machine. output: first set output default printout output power4test(). can used check model specified. also automatically computes population standardized indirect effect(s). second section output rejection_rates(), showing power column reject. example, power 0.40 sample size 300.","code":"out_power <- q_power_mediation_parallel(   as = c(\"s\", \"m\", \"m\"),   bs = c(\"l\", \"m\", \"l\"),   cp = \"nil\",   target_power = .80,   nrep = 400,   n = 300,   R = 1000,   seed = 1234 ) out_power #>  #> ========== power4test Results ========== #>  #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #> == Model on Variables/Indicators == #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.100   #>   m2 ~                        #>     x                 0.300   #>   m3 ~                        #>     x                 0.300   #>   y ~                         #>     m1                0.500   #>     m2                0.300   #>     m3                0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m1                0.990   #>    .m2                0.910   #>    .m3                0.910   #>    .y                 0.359   #>     x                 1.000   #>  #> (Computing indirect effects for 4 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.050 #> x -> m2 -> y 0.090 #> x -> m3 -> y 0.150 #> x -> y       0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  300  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        11 #>  #>   Number of observations                           300 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 6.125 #>   Degrees of freedom                                 3 #>   P-value (Chi-square)                           0.106 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirects: x-...->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. #>  #> ========== power4test Power ========== #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.403  0.356  0.451 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> ========== n_region_from_power Results ========== #>  #>  #> 'mode' is not 'region' and results not available."},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"find-the-region-of-sample-sizes","dir":"Articles","previous_headings":"","what":"Find the Region of Sample Sizes","title":"Quick Function: Parallel Mediation with Observed Variables","text":"addition estimate power sample size, function can also used find approximate region sample sizes levels power significantly different target power. region useful determining range sample sizes likely sufficient power, greater necessary resources limited. Note process can slow. Nevertheless, power analysis usually conducted planning stage study, slow processing time acceptable stage. Finding region can done using code , argument mode = \"region\" added: printout, showing section output n_region_from_power(): example, range sample size 728 947. results can also visualized using plot() function: Plot Sample Sizes Searched region shaded areas approximate region sample sizes found.","code":"out_region <- q_power_mediation_parallel(   as = c(\"s\", \"m\", \"m\"),   bs = c(\"l\", \"m\", \"l\"),   cp = \"nil\",   target_power = .80,   nrep = 400,   n = 300,   R = 1000,   seed = 1234,   mode = \"region\" ) #> ========== n_region_from_power Results ========== #>  #> Call: #> n_region_from_power(object = `<hidden>`, target_power = 0.8,  #>     progress = TRUE, simulation_progress = TRUE, max_trials = 10,  #>     seed = 1234) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 728 to 947 #> - significantly lower than 0.800: 728 #> - significantly higher than 0.800: 947 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (728): [0.734, 0.816] #> - for the upper bound (947): [0.817, 0.886] #>  #> Call `summary()` for detailed results."},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"other-models","dir":"Articles","previous_headings":"Final Remarks","what":"Other Models","title":"Quick Function: Parallel Mediation with Observed Variables","text":"Quick -articles common mediation models, including latent variables, can found list articles package power4mome supports arbitrary model specified lavaan syntax, including moderators. Interested users can refer articles .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_parallel.html","id":"technical-details","dir":"Articles","previous_headings":"Final Remarks","what":"Technical Details","title":"Quick Function: Parallel Mediation with Observed Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Function: Serial Mediation with Observed Variables","text":"“Quick Function” articles examples R code determine range sample sizes target level power estimate power specific scenario typical mediation models using power4mome. Users can quickly adapt scenarios. -guides cover technical details involved.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Function: Serial Mediation with Observed Variables","text":"functions wrappers power4test() n_region_from_power(). simple scenarios, users need know use advanced functions, though knowledge can help customizing search region. information functions can found Final Remarks","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Function: Serial Mediation with Observed Variables","text":"file serial mediation models, use one function q_power_mediation_serial() package power4mome.","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The Model","title":"Quick Function: Serial Mediation with Observed Variables","text":"Suppose model: Model want power analysis indirect effect along path x->m1->m2->y. Suppose expected effects: x->m1: medium m1->m2: medium m2->y: large x->y: small paths involving mediators, x->m2 m1->y, assumed effect (nil).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"convention","dir":"Articles","previous_headings":"The Model","what":"Convention for the Effect Sizes","title":"Quick Function: Serial Mediation with Observed Variables","text":"make easy specify standardized population values parameters, power4mome adopted convention Pearson’s r, just convenience. \"nil\": Nil (.00). \"s\": Small (.10). \"m\": Medium (.30), \"l\": Large (.50). also two intermediate levels: \"sm\": Small--medium (.20). \"ml\": Medium--large (.40). effect negative, just add minus sign. example, use \"-m\" denote negative medium effect. path one variable another variable, standardized coefficient equal correlation predictor, predictor uncorrelated predictors. Therefore, though may perfect, believe convention Pearson’s r reasonable one. necessary, users can specify effect (standardized metric) directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"covariates-in-the-model-to-be-fitted","dir":"Articles","previous_headings":"The Model","what":"Covariates in the Model to be Fitted","title":"Quick Function: Serial Mediation with Observed Variables","text":"applied research, model fitted usually control variables, educational level. may practical specify probable effects control variables (though possible power4mome). Therefore, conservative assessment power, users can first decide population effects, adjust slightly downward (e.g., medium, \"m\", small--medium, \"sm\") take account potential decrease effects due control variables included.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"model-with-hypothesized-path-coefficients","dir":"Articles","previous_headings":"The Model","what":"Model with Hypothesized Path Coefficients","title":"Quick Function: Serial Mediation with Observed Variables","text":"model effect sizes: Model","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"test-to-be-used","dir":"Articles","previous_headings":"The Model","what":"Test to be Used","title":"Quick Function: Serial Mediation with Observed Variables","text":"practice, nonparametric bootstrapping usually used test indirect effects. However, estimating power using simulation slow. good-enough proxy estimate power testing effect Monte Carlo confidence interval. default method power4mome tests indirect effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"find-the-power","dir":"Articles","previous_headings":"","what":"Find the Power","title":"Quick Function: Serial Mediation with Observed Variables","text":"estimate power sample size, code: arguments: ab: hypothesized standardized effects along path predictor x outcome variable y. character vector elements equal number mediators path coefficients x->m1->m2->...->y. Can one labels supported convention, numeric value. ab_other: hypothesized standardized effect paths involving mediators. simplicity, support one value, value used paths. Can one labels supported convention, numeric value. cp: hypothesized standardized direct effect predictor x outcome variable y. Can one labels supported convention, numeric value. target_power: target level power. Default .80, can omitted desired level power nrep: number replications estimating power sample size. Default 400. Can omitted desired number replications. R: number random samples used forming Monte Carlo nonparametric bootstrapping confidence intervals. Although large testing effect one single sample, can smaller goal estimate power across replications, achieve high accuracy sample. Default 1000. Can omitted default acceptable. seed: seed random number generator. Note , parallel processing used (default), results reproducible configuration exactly identical. Moreover, changes algorithm also make results reproducible even seed. Nevertheless, still advised set seed integer, make results reproducible least machine. output: first set output default printout output power4test(). can used check model specified. also automatically computes population standardized indirect effect(s). second section output rejection_rates(), showing power column reject. example, power 0.71 sample size 100.","code":"out_power <- q_power_mediation_serial(   ab = c(\"m\", \"m\", \"l\"),   ab_other = \"nil\",   cp = \"s\",   target_power = .80,   nrep = 400,   n = 100,   R = 1000,   seed = 1234 ) out_power #>  #> ========== power4test Results ========== #>  #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m1 ~ x #> m2 ~ m1 + x #> y ~ m1 + m2 + x #> == Model on Variables/Indicators == #> m1 ~ x #> m2 ~ m1 + x #> y ~ m1 + m2 + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     m1                0.300   #>     x                 0.000   #>   y ~                         #>     m1                0.000   #>     m2                0.500   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .y                 0.731   #>     x                 1.000   #>  #> (Computing indirect effects for 4 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                      ind #> x -> m1 -> m2 -> y 0.045 #> x -> m1 -> y       0.000 #> x -> m2 -> y       0.000 #> x -> y             0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         9 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. #>  #> ========== power4test Power ========== #>  #> [test]: test_indirect: x->m1->m2->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.046 1.000  0.710  0.664  0.752 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> ========== n_region_from_power Results ========== #>  #>  #> 'mode' is not 'region' and results not available."},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"find-the-region-of-sample-sizes","dir":"Articles","previous_headings":"","what":"Find the Region of Sample Sizes","title":"Quick Function: Serial Mediation with Observed Variables","text":"addition estimate power sample size, function can also used find approximate region sample sizes levels power significantly different target power. region useful determining range sample sizes likely sufficient power, greater necessary resources limited. Note process can slow. Nevertheless, power analysis usually conducted planning stage study, slow processing time acceptable stage. Finding region can done using code , argument mode = \"region\" added: printout, showing section output n_region_from_power(): example, range sample size 113 126. results can also visualized using plot() function: Plot Sample Sizes Searched region shaded areas approximate region sample sizes found.","code":"out_region <- q_power_mediation_serial(   ab = c(\"m\", \"m\", \"l\"),   ab_other = \"nil\",   cp = \"s\",   target_power = .80,   nrep = 400,   n = 100,   R = 1000,   seed = 1234,   mode = \"region\" ) #> ========== n_region_from_power Results ========== #>  #> Call: #> n_region_from_power(object = `<hidden>`, target_power = 0.8,  #>     progress = TRUE, simulation_progress = TRUE, max_trials = 10,  #>     seed = 1234) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 113 to 126 #> - significantly lower than 0.800: 113 #> - significantly higher than 0.800: 126 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (113): [0.718, 0.802] #> - for the upper bound (126): [0.812, 0.882] #>  #> Call `summary()` for detailed results."},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"other-models","dir":"Articles","previous_headings":"Final Remarks","what":"Other Models","title":"Quick Function: Serial Mediation with Observed Variables","text":"Quick -articles common mediation models, including latent variables, can found list articles package power4mome supports arbitrary model specified lavaan syntax, including moderators. Interested users can refer articles .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_serial.html","id":"technical-details","dir":"Articles","previous_headings":"Final Remarks","what":"Technical Details","title":"Quick Function: Serial Mediation with Observed Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Function: Simple Mediation with Observed Variables","text":"“Quick Function” articles examples R code determine range sample sizes target level power estimate power specific scenario typical mediation models using power4mome. Users can quickly adapt scenarios. -guides cover technical details involved.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Function: Simple Mediation with Observed Variables","text":"functions wrappers power4test() n_region_from_power(). simple scenarios, users need know use advanced functions, though knowledge can help customizing search region. information functions can found Final Remarks","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Function: Simple Mediation with Observed Variables","text":"file simple mediation models, use one function q_power_mediation_simple() package power4mome.","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The Model","title":"Quick Function: Simple Mediation with Observed Variables","text":"Suppose model: Model want power analysis indirect effect along path x->m->y. Suppose expected effects: -path: medium b-path: medium c’-path: small","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"convention","dir":"Articles","previous_headings":"The Model","what":"Convention for the Effect Sizes","title":"Quick Function: Simple Mediation with Observed Variables","text":"make easy specify standardized population values parameters, power4mome adopted convention Pearson’s r, just convenience. \"nil\": Nil (.00). \"s\": Small (.10). \"m\": Medium (.30), \"l\": Large (.50). also two intermediate levels: \"sm\": Small--medium (.20). \"ml\": Medium--large (.40). effect negative, just add minus sign. example, use \"-m\" denote negative medium effect. path one variable another variable, standardized coefficient equal correlation predictor, predictor uncorrelated predictors. Therefore, though may perfect, believe convention Pearson’s r reasonable one. necessary, users can specify effect (standardized metric) directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"covariates-in-the-model-to-be-fitted","dir":"Articles","previous_headings":"The Model","what":"Covariates in the Model to be Fitted","title":"Quick Function: Simple Mediation with Observed Variables","text":"applied research, model fitted usually control variables, educational level. may practical specify probable effects control variables (though possible power4mome). Therefore, conservative assessment power, users can first decide population effects, adjust slightly downward (e.g., medium, \"m\", small--medium, \"sm\") take account potential decrease effects due control variables included.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"model-with-hypothesized-path-coefficients","dir":"Articles","previous_headings":"The Model","what":"Model with Hypothesized Path Coefficients","title":"Quick Function: Simple Mediation with Observed Variables","text":"model effect sizes: Model Effect Sizes","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"test-to-be-used","dir":"Articles","previous_headings":"The Model","what":"Test to be Used","title":"Quick Function: Simple Mediation with Observed Variables","text":"practice, nonparametric bootstrapping usually used test indirect effects. However, estimating power using simulation slow. good-enough proxy estimate power testing effect Monte Carlo confidence interval. default method power4mome tests indirect effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"find-the-power","dir":"Articles","previous_headings":"","what":"Find the Power","title":"Quick Function: Simple Mediation with Observed Variables","text":"estimate power sample size, code: arguments: : hypothesized standardized effect predictor x mediator m. Can one labels supported convention, numeric value. b: hypothesized standardized effect mediator m outcome variable y. Can one labels supported convention, numeric value. cp: hypothesized standardized direct effect predictor x outcome variable y. Can one labels supported convention, numeric value. target_power: target level power. Default .80, can omitted desired level power nrep: number replications estimating power sample size. Default 400. Can omitted desired number replications. R: number random samples used forming Monte Carlo nonparametric bootstrapping confidence intervals. Although large testing effect one single sample, can smaller goal estimate power across replications, achieve high accuracy sample. Default 1000. Can omitted default acceptable. seed: seed random number generator. Note , parallel processing used (default), results reproducible configuration exactly identical. Moreover, changes algorithm also make results reproducible even seed. Nevertheless, still advised set seed integer, make results reproducible least machine. output: first set output default printout output power4test(). can used check model specified. also automatically computes population standardized indirect effect(s). second section output rejection_rates(), showing power column reject. example, power 0.54 sample size 80.","code":"out_power <- q_power_mediation_simple(   a = \"m\",   b = \"m\",   cp = \"s\",   target_power = .80,   nrep = 400,   n = 80,   R = 1000,   seed = 1234 ) out_power #>  #> ========== power4test Results ========== #>  #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.882   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.090 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  80  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            80 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. #>  #> ========== power4test Power ========== #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.088 1.000  0.537  0.489  0.586 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> ========== n_region_from_power Results ========== #>  #>  #> 'mode' is not 'region' and results not available."},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"find-the-region-of-sample-sizes","dir":"Articles","previous_headings":"","what":"Find the Region of Sample Sizes","title":"Quick Function: Simple Mediation with Observed Variables","text":"addition estimate power sample size, function can also used find approximate region sample sizes levels power significantly different target power. region useful determining range sample sizes likely sufficient power, greater necessary resources limited. Note process can slow. Nevertheless, power analysis usually conducted planning stage study, slow processing time acceptable stage. Finding region can done using code , argument mode = \"region\" added: printout, showing section output n_region_from_power(): example, range sample size 100 117. results can also visualized using plot() function: Plot Sample Sizes Searched region shaded areas approximate region sample sizes found.","code":"out_region <- q_power_mediation_simple(   a = \"m\",   b = \"m\",   cp = \"s\",   target_power = .80,   nrep = 400,   n = 80,   R = 1000,   seed = 1234,   mode = \"region\" ) #> ========== n_region_from_power Results ========== #>  #> Call: #> n_region_from_power(object = `<hidden>`, target_power = 0.8,  #>     progress = TRUE, simulation_progress = TRUE, max_trials = 10,  #>     seed = 1234) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 100 to 117 #> - significantly lower than 0.800: 100 #> - significantly higher than 0.800: 117 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (100): [0.708, 0.792] #> - for the upper bound (117): [0.804, 0.875] #>  #> Call `summary()` for detailed results."},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"other-models","dir":"Articles","previous_headings":"Final Remarks","what":"Other Models","title":"Quick Function: Simple Mediation with Observed Variables","text":"Quick -articles common mediation models, including latent variables, can found list articles package power4mome supports arbitrary model specified lavaan syntax, including moderators. Interested users can refer articles .","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_q_med_obs_simple.html","id":"technical-details","dir":"Articles","previous_headings":"Final Remarks","what":"Technical Details","title":"Quick Function: Simple Mediation with Observed Variables","text":"options power4test() n_region_from_power(), please refer help pages, well Get-Started article article n_from_power(), function find one regions, called twice n_region_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Effect Size Given Desired Power","text":"article brief illustration use x_from_power() power4test() package power4mome find simulation, given sample size, desired power, well factors, minimum effect size detected level power (see note “minimum”). illustration use indirect effect tested Monte Carlo confidence interval example, though procedure similar tests supported power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Effect Size Given Desired Power","text":"Basic knowledge fitting models lavaan required. Readers also expected know use power4test() (see get-started introduction).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Effect Size Given Desired Power","text":"brief illustration. complicated scenarios features x_from_power() described vignettes. sections repeated vignettes make vignette self-contained.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Effect Size Given Desired Power","text":"illustration needs following package(s):","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Effect Size Given Desired Power","text":"Three functions, along methods, sufficient estimating sample size, given desired power, along factors test, model, sample size. basic workflow: Specify model syntax population model, lavaan style, set initial population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified, using sample size examined. Call rejection_rates() compute power verify test setup correctly. Call x_from_power() estimated minimum effect size can detected, given factors, including sample size examined target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Effect Size Given Desired Power","text":"Let’s consider simple mediation model, effect concern indirect effect tested Monte Carlo confidence interval. special consideration regarding indirect effect: effect function two model parameters. example, simple mediation -path predictor mediator, b-path mediator outcome variable, indirect effect ab. found power detect particular value ab, say 0.25, combinations b. example, Kenny & Judd (2014) found required sample size power .80 detect ab .0225 can vary 450 large 5000, depending values b. Therefore, even like find minimum ab can detected power .80 given sample size, still manipulate one parameter (e.g., b) one time. Two additional notes notion “minimum”. First, simplicity, positive population values considered. However, may cases population values consideration negative. cases, “minimum” refers minimum magnitude. Second, may cases , even keeping values considered positive, relation power parameter varied U-shaped. cases, two values selected parameters may target power. plot relation (described lated) examined see whether solution likely minimum value range examined. illustrated vignette.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Effect Size Given Desired Power","text":"model syntax Note , even going test mediation, need add labels defined user-parameters. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Effect Size Given Desired Power","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (-called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : word denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Effect Size Given Desired Power","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown print object: argument data_long = TRUE used verify simulation. population values regression paths section Population Values specified. model specified correctly. section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. default, population model fitted dataset, hence section <fit>. section just verifies population can fitted results show population model desired one. can proceed next stage","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) print(out,       data_long = TRUE) #>  #> ============================== Model Information ============================== #>  #> ====== Model on Factors/Variables ====== #>  #> m ~ x #> y ~ m + x #>  #> ==== Model on Variables/Indicators ==== #>  #> m ~ x #> y ~ m + x #>  #> ========== Population Values ========== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> =============================== Data Information =============================== #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ======== Descriptive Statistics ======== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ============= Parameter Estimates Based on All 2 Samples Combined ============= #>  #> Total Sample Size: 100000  #>  #> ======== Standardized Estimates ======== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ============================ Extra Element(s) Found ============================ #>  #> - fit #>  #> ======== Element(s) of the First Dataset ======== #>  #> ================ <fit> ================ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Effect Size Given Desired Power","text":"can now simulation estimate power initial values (m ~ x) b (y ~ m), given target sample size verify test want . large number datasets (e.g., 500) target sample size initial population values model generated, target test conducted datasets. Suppose start hold b medium (.30) direct effect (y ~ x) small (.10), sample size 100, like estimate power using Monte Carlo confidence interval test indirect effect x y m, also medium. call, based previous one: goal find value parameter, case, specific level power sample size, sufficient precision, need large number replications (nrep) stage. can use 50. can set target number replications calling function x_from_power(). successively increase nrep search, accepts solution based target number replications. new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-function tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case test done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 Note simulation can take time run (3 4 minutes using 20 cores). Progress printed run interactive session. default printout: argument test_long = TRUE added verify test set . shown , setup correct. can now call x_from_power() search.","code":"out <- power4test(nrep = 50,                   model = mod,                   pop_es = mod_es,                   n = 100,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) print(out,       test_long = TRUE) #>  #> ============================== Model Information ============================== #>  #> ====== Model on Factors/Variables ====== #>  #> m ~ x #> y ~ m + x #>  #> ==== Model on Variables/Indicators ==== #>  #> m ~ x #> y ~ m + x #>  #> ========== Population Values ========== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> =============================== Data Information =============================== #>  #> Number of Replications:  50  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ============================ Extra Element(s) Found ============================ #>  #> - fit #> - mc_out #>  #> ======== Element(s) of the First Dataset ======== #>  #> ================ <fit> ================ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =============== <mc_out> =============== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== <test_indirect: x->m->y> ====================== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.145 0.036 0.273 0.820 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 50  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"call-x_from_power-to-estimate-the-minimum-value-of-a","dir":"Articles","previous_headings":"Mediation","what":"Call x_from_power() to Estimate the Minimum Value of a","title":"Effect Size Given Desired Power","text":"simplified description x_from_power() works: rerun simulation test output power4test() different values selected parameter, estimate power levels . try estimate relation power value selected parameter, select next value(s) try. adopt value solution () confidence interval estimated power includes target power (default level 95%), (b) number replications used estimation target one (ensure standard error desired level). argument used : x: want find, \"es\" stands effect sizes. pop_es_name: name parameter value varied. name one used lavaan using coef(). See power4test_by_es() setting name. target_power: target power. Default .80. final_nrep: number replications desired solution. using normal approximation form 95% confidence interval sample proportion (power case). nrep = 400, 95% confidence limits power .80 .04 .80. precise enough estimating sample size required. seed: make search reproducible, possible, set seed integer.","code":"out_es_a <- x_from_power(out,                          x = \"es\",                          pop_es_name = \"m~x\",                          target_power = .80,                          final_nrep = 400,                          seed = 4567)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"examine-the-output","dir":"Articles","previous_headings":"Mediation","what":"Examine the Output","title":"Effect Size Given Desired Power","text":"basic output: estimated value power close .80 power detect indirect effect (ab, b equal .30 population) Monte Carlo interval 0.494. estimated power based simulation 0.802. , given model sample size 100, population value b medium (.30), test approximate power .80 population value 0.494. corresponding indirect effect 0.148 obtain detailed results search, can use summary() method: reports 95% confidence interval estimated power, [0.761; 0.839]. also reports major technical information regarding search, range values tried, time spent, table values examined, along estimated power levels confidence intervals. also prints model, “power curve”, used estimate relation power value selected parameter. Note crude model intended values examined. intended estimate power values outside range studied. Even though model crude one, can still give rough idea relation. simple plot can requested plot(): Power Curve black line plot sample sizes studied, along estimated power levels 95% confidence intervals. intervals vary width different number replications. red line plot based model (logistic model case), along range sample sizes examined.","code":"out_es_a #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"m~x\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #>  #>                          Setting #> Predictor(x):        Effect Size #> Parameter:                   m~x #> goal:                     ci_hit #> what:                      point #> algorithm:           power_curve #> Level of confidence:      95.00% #> Target Power:              0.800 #>  #> - Final Value of'm~x': 0.494 #>  #> - Final Estimated Power (CI): 0.802 [0.761, 0.839] #>  #> Call `summary()` for detailed results. summary(out_es_a) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"m~x\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #>  #> Predictor (x): Effect Size  #> Parameter Name (pop_es_name): m~x  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power enclosing the target #>   power. #>  #> === Major Results === #>  #> - Final Value (m~x): 0.494 #>  #> - Final Estimated Power: 0.802  #> - Confidence Interval: [0.761; 0.839] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: power_curve  #> - The range of values explored: 0.488 to 0.519  #> - Time spent in the search: 1.235 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress, models = c(\"glm\",  #>         \"lm\")) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      -7.903       18.428   #>  #> Degrees of Freedom: 249 Total (i.e. Null);  248 Residual #> Null Deviance:       270.8  #> Residual Deviance: 270.6     AIC: 274.6 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>    par    es   est   p.v reject r.cilo r.cihi #> 1  m~x 0.488 0.151 1.000  0.760  0.626  0.857 #> 2  m~x 0.491 0.147 1.000  0.780  0.648  0.872 #> 3  m~x 0.492 0.150 1.000  0.790  0.700  0.858 #> 4  m~x 0.494 0.140 1.000  0.720  0.583  0.825 #> 5  m~x 0.494 0.148 1.000  0.802  0.761  0.839 #> 6  m~x 0.497 0.150 1.000  0.760  0.626  0.857 #> 7  m~x 0.500 0.145 1.000  0.820  0.692  0.902 #> 8  m~x 0.501 0.150 1.000  0.767  0.724  0.806 #> 9  m~x 0.504 0.150 1.000  0.772  0.716  0.820 #> 10 m~x 0.519 0.155 1.000  0.740  0.646  0.816 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the rejection rate. If #>   the null hypothesis is true, this is the Type I error rate. If the null hypothesis is #>   false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based on Wilson's (1927) #>   method. #> - Refer to the tests for the meanings of other columns. plot(out_es_a)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"finding-the-minimum-value-of-b-when-holding-a-to--30","dir":"Articles","previous_headings":"Mediation","what":"Finding the Minimum Value of b When Holding a to .30","title":"Effect Size Given Desired Power","text":"can also find minimum value b holding medium (.30). Just call x_from_power() , setting pop_es_name \"y~m\". estimated value b power close .80 power detect indirect effect (ab, equal .30 population) Monte Carlo interval 0.307. estimated power based simulation 0.823. , given model sample size 100, population value medium (.30), test approximate power .80 population value b 0.307. corresponding indirect effect 0.092, slightly lower indirect effect b hold .30. detailed results search b varied: reports 95% confidence interval estimated power, [0.782; 0.857]. Power Curve (b varied)","code":"out_es_b <- x_from_power(out,                          x = \"es\",                          pop_es_name = \"y~m\",                          target_power = .80,                          final_nrep = 400,                          seed = 4567) summary(out_es_b) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"y~m\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #>  #> Predictor (x): Effect Size  #> Parameter Name (pop_es_name): y~m  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power enclosing the target #>   power. #>  #> === Major Results === #>  #> - Final Value (y~m): 0.307 #>  #> - Final Estimated Power: 0.823  #> - Confidence Interval: [0.782; 0.857] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: power_curve  #> - The range of values explored: 0.293 to 0.343  #> - Time spent in the search: 1.243 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress, models = c(\"glm\",  #>         \"lm\")) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      -2.366       11.727   #>  #> Degrees of Freedom: 249 Total (i.e. Null);  248 Residual #> Null Deviance:       280.1  #> Residual Deviance: 280   AIC: 284 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>    par    es   est   p.v reject r.cilo r.cihi #> 1  y~m 0.293 0.151 1.000  0.780  0.648  0.872 #> 2  y~m 0.295 0.147 1.000  0.760  0.626  0.857 #> 3  y~m 0.296 0.140 1.000  0.680  0.542  0.792 #> 4  y~m 0.298 0.150 1.000  0.720  0.583  0.825 #> 5  y~m 0.300 0.145 1.000  0.820  0.692  0.902 #> 6  y~m 0.300 0.153 1.000  0.780  0.689  0.850 #> 7  y~m 0.307 0.153 1.000  0.823  0.782  0.857 #> 8  y~m 0.317 0.158 1.000  0.820  0.779  0.855 #> 9  y~m 0.320 0.158 1.000  0.836  0.785  0.877 #> 10 y~m 0.343 0.171 1.000  0.870  0.790  0.922 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the rejection rate. If #>   the null hypothesis is true, this is the Type I error rate. If the null hypothesis is #>   false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based on Wilson's (1927) #>   method. #> - Refer to the tests for the meanings of other columns. plot(out_es_b)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"advanced-features","dir":"Articles","previous_headings":"","what":"Advanced Features","title":"Effect Size Given Desired Power","text":"brief illustration covers basic features x_from_power(). ways customize search, range values parameter examine (default 0 0.7), level confidence confidence interval, number trials (10 default). Please refer help page x_from_power() options.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sample Size Given Desired Power","text":"article brief illustration use n_from_power() power4test() package power4mome find simulation sample size power close desired level detect effect, given level population effect size. illustration use indirect effect tested Monte Carlo confidence interval example, though procedure similar tests supported power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Sample Size Given Desired Power","text":"Basic knowledge fitting models lavaan required. Readers also expected know use power4test() (see get-started introduction).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Sample Size Given Desired Power","text":"brief illustration. complicated scenarios features x_from_power() described vignettes articles. sections repeated vignettes articles make vignette self-contained.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Sample Size Given Desired Power","text":"illustration needs following package(s):","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Sample Size Given Desired Power","text":"Three functions, along methods, sufficient estimating sample size, given desired power, along factors test, model, population values. workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified, using initial sample size. Call rejection_rates() compute power verify test specified correctly. Call n_from_power() estimate sample size required desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Sample Size Given Desired Power","text":"Let’s consider simple mediation model. like estimate sample size required detect mediation effect Monte Carlo confidence interval, 95% level significance. sampling (simulation) error involved analytic solution find sample size, instead estimating unknown sample size, can also estimate, approximately, region sample sizes levels power significantly lower target power, significantly higher target power. , find sample size confidence interval, 95% default, just (Case 1) just (Case 2) target power, approximately. consider Case 1 first.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Sample Size Given Desired Power","text":"model syntax Note , even going test mediation, need label parameters define indirect effect usual lavaan. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Sample Size Given Desired Power","text":"two approaches : using named vectors lists, using multiline string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (-called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : word denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Sample Size Given Desired Power","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown print object: argument data_long = TRUE used verify simulation. population values regression paths section Population Values specified. model specified correctly. section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. default, population model fitted dataset, hence section <fit>. section just verifies population can fitted results show population model desired one. can proceed next stage","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Sample Size Given Desired Power","text":"can now simulation estimate power initial sample size, verify test want . large number datasets (e.g., 500) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect x y m, sample size 50. call, based previous one: goal find sample size specific level power, sufficient precision, need large number replications (nrep) stage. can use 50. can set target number replications calling function n_from_power(), wrapper general function x_from_power(). new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-function tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case test done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 Note simulation can take time run. Progress printed run interactive session. default printout: argument test_long = TRUE added verify test set . shown , settings correct. can now call n_from_power() search.","code":"out <- power4test(nrep = 50,                   model = mod,                   pop_es = mod_es,                   n = 50,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 2345,                   parallel = TRUE) print(out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  50  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-20 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.167 0.003 0.367 0.520 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 50  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"call-n_from_power-to-estimate-the-sample-size","dir":"Articles","previous_headings":"Mediation","what":"Call n_from_power() to Estimate the Sample Size","title":"Sample Size Given Desired Power","text":"simplified description n_from_power() works goal find sample size 95% confidence interval power just target power. , sample size upper bound 95% confidence interval power just target power. practice, rarely need precise estimate goal sample size planning. Therefore, sample size upper bound 95% confidence interval power “close enough” target power sufficient. now, bisection method used. method slow. However, experience, goal approximation, “close enough” solution, method usually sufficient. Last, bisection method may fail find solution know form function simulation used. However, simple method usually good enough finding approximation. function call: argument used : target_power: target power. Default .80. final_nrep: number replications desired solution, using normal approximation form 95% confidence interval sample proportion (power case). nrep = 400, 95% confidence limits power .80 .04 .80. precise enough estimating sample size required. higher precision desired computation power available, number can increased , say, 500 1000. : goal find sample size upper bound confidence interval power close enough target power, set \"ub\". seed: make search reproducible, possible, set seed integer. goal: get “close enough” solution, set goal \"close_enough\" (goal = \"close_enough\"). However, goal lower upper bounds (= \"ub\" = \"lb\") \"close_enough\", argument can omitted. default, “close enough” defined “within .02 target power”. (can controlled argument tolerance).","code":"out_n <- n_from_power(out,                       target_power = .80,                       final_nrep = 400,                       what = \"ub\",                       seed = 4567)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"examine-the-output","dir":"Articles","previous_headings":"Mediation","what":"Examine the Output","title":"Sample Size Given Desired Power","text":"example needs attempts arrive approximation. basic output: estimated sample size 99. estimated power based simulation 0.765, confidence interval equal [0.721, 0.804]. upper bound, 0.804, .02 within target power (.80). words, 400 replications, estimated sample sizes less 99 power significantly less .80 used target power .80. obtain detailed results search, can use summary() method: also reports major technical information regarding search, range sample sizes tried, time spent, table sample sizes examined, along estimated power levels confidence intervals. also prints model, “power curve”, used estimate relation power sample size. Note crude model intended values sample size examined (6 example). intended estimate power sample sizes outside range studied. Even though model crude one, can still give rough idea relation. simple plot can requested plot(): Power Curve black line plot sample sizes studied, along estimated power levels 95% confidence intervals. intervals may vary width numbers replications sample sizes examined. red line plot based model (logistic model case), along range sample sizes examined. area left solution region power estimated significantly less target power.","code":"out_n #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"ub\", goal = \"close_enough\", final_nrep = 400, seed = 4567) #>  #>                           Setting #> Predictor(x):         Sample Size #> Parameter:                    N/A #> goal:                close_enough #> what:                          ub #> algorithm:              bisection #> Level of confidence:       95.00% #> Target Power:               0.800 #>  #> - Final Value of Sample Size (n): 99 #>  #> - Final Estimated Power (CI): 0.765 [0.721, 0.804] #>  #> Call `summary()` for detailed results. summary(out_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"ub\", goal = \"close_enough\", final_nrep = 400, seed = 4567) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 99 #>  #> - Final Estimated Power: 0.765  #> - Confidence Interval: [0.721; 0.804] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 106 to 99  #> - Time spent in the search: 2.198 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -0.94206      0.02155   #>  #> Degrees of Freedom: 2049 Total (i.e. Null);  2048 Residual #> Null Deviance:       2243  #> Residual Deviance: 2178  AIC: 2182 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.167 1.000  0.520  0.385  0.652 #> 2  77 0.147 1.000  0.685  0.638  0.729 #> 3  92 0.147 1.000  0.715  0.669  0.757 #> 4  99 0.148 1.000  0.765  0.721  0.804 #> 5 106 0.151 1.000  0.810  0.769  0.845 #> 6 134 0.149 1.000  0.873  0.836  0.902 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. plot(out_n)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"case-2","dir":"Articles","previous_headings":"Mediation","what":"Case 2","title":"Sample Size Given Desired Power","text":"Let’s consider Case 2, finding sample size 95% confidence interval power approximately target power. , lower bound confidence interval close enough target power. function call: change , set \"lb\" (lower bound). example needs attempts arrive approximation. output: estimated sample size 120. estimated power based simulation 0.840, confidence interval equal [0.801, 0.804]. upper bound, 0.801, .02 within target power (.80). 400 replications, estimated sample sizes greater 120 power significantly greater .80 can used target power .80. summary results: plot search: Power Curve","code":"out_n_lb <- n_from_power(out,                          target_power = .80,                          final_nrep = 400,                          what = \"lb\",                          seed = 2345) out_n_lb #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"lb\", goal = \"close_enough\", final_nrep = 400, seed = 2345) #>  #>                           Setting #> Predictor(x):         Sample Size #> Parameter:                    N/A #> goal:                close_enough #> what:                          lb #> algorithm:              bisection #> Level of confidence:       95.00% #> Target Power:               0.800 #>  #> - Final Value of Sample Size (n): 120 #>  #> - Final Estimated Power (CI): 0.840 [0.801, 0.873] #>  #> Call `summary()` for detailed results. summary(out_n_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"lb\", goal = \"close_enough\", final_nrep = 400, seed = 2345) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 120 #>  #> - Final Estimated Power: 0.840  #> - Confidence Interval: [0.801; 0.873] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 120 to 77  #> - Time spent in the search: 1.264 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.04017      0.02271   #>  #> Degrees of Freedom: 1249 Total (i.e. Null);  1248 Residual #> Null Deviance:       1237  #> Residual Deviance: 1119  AIC: 1123 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.167 1.000  0.520  0.385  0.652 #> 2  77 0.151 1.000  0.672  0.625  0.717 #> 3 120 0.149 1.000  0.840  0.801  0.873 #> 4 162 0.152 1.000  0.935  0.906  0.955 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. plot(out_n_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"case-1-case-2-or-both","dir":"Articles","previous_headings":"","what":"Case 1, Case 2, or Both?","title":"Sample Size Given Desired Power","text":"Similar Johnson-Neyman method moderation, two sample sizes found can used together estimate range sample sizes power significantly different form target power. , results , can conclude , 400 replications, sample sizes 99 120 power levels significantly different .80. However, believe researchers rarely need find “” sample exactly “” target power sample size planning. Therefore, resource concern important sample size power low, Case 1 sufficient knowing range sample sizes definitely used. sufficient power important associated resource available, Case 2 appropriate can find minimum sample size power significantly higher target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"advanced-features","dir":"Articles","previous_headings":"","what":"Advanced Features","title":"Sample Size Given Desired Power","text":"brief illustration covers basic features n_from_power(). ways customize search, range sample sizes examine, level confidence confidence interval, number trials (10 default). Please refer help page x_from_power(), n_from_power() calls, options.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n_test_printout.html","id":"note","dir":"Articles","previous_headings":"","what":"NOTE","title":"Sample Size Given Desired Power (Internal)","text":"article internal testing printout. Power Curve Power Curve Power Curve (Region) Power Curve (Region) Version 2","code":"library(power4mome) options(power4mome.bz = TRUE) mod <- \" m ~ x y ~ m + x \" mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \" out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 out <- power4test(nrep = 200,                   model = mod,                   pop_es = mod_es,                   n = 100,                   R = 199,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 2345,                   parallel = TRUE) print(out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.100 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  200  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21.2434 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 199  #>  #>  #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig pvalue #>  0.151 0.039 0.284 0.760  0.053 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 200  #> - Proportion of valid replications for rejection rate: 1.000 out_n <- n_from_power(out,                       what = \"ub\",                       seed = 4567) out_n #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", final_nrep = 200, final_R = 199, seed = 4567) #>  #>                           Setting #> Predictor(x):         Sample Size #> Parameter:                    N/A #> goal:                close_enough #> what:                          ub #> algorithm:              bisection #> Level of confidence:       95.00% #> Target Power:               0.800 #>  #> - Final Value of Sample Size (n): 100 #>  #> - Final Estimated Power (CI): 0.760 [0.696, 0.814] #>  #> Call `summary()` for detailed results. summary(out_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"n\", what = \"ub\", goal = \"close_enough\",  #>     final_nrep = 200, final_R = 199, seed = 4567) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 100 #>  #> - Final Estimated Power: 0.760  #> - Confidence Interval: [0.696; 0.814] #> - Level of confidence: 95.0% #> - Based on 200 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 105  #> - Time spent in the search: 8.463 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -4.15058      0.05303   #>  #> Degrees of Freedom: 399 Total (i.e. Null);  398 Residual #> Null Deviance:       419  #> Residual Deviance: 417.8     AIC: 421.8 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.151 1.000  0.760  0.696  0.814 #> 2 105 0.155 1.000  0.805  0.745  0.854 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. plot(out_n) out_n_lb <- n_from_power(out,                          what = \"lb\",                          seed = 2345) out_n_lb #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", final_nrep = 200, final_R = 199, seed = 2345) #>  #>                           Setting #> Predictor(x):         Sample Size #> Parameter:                    N/A #> goal:                close_enough #> what:                          lb #> algorithm:              bisection #> Level of confidence:       95.00% #> Target Power:               0.800 #>  #> - Final Value of Sample Size (n): 119 #>  #> - Final Estimated Power (CI): 0.865 [0.811, 0.906] #>  #> Call `summary()` for detailed results. summary(out_n_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"n\", what = \"lb\", goal = \"close_enough\",  #>     final_nrep = 200, final_R = 199, seed = 2345) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 119 #>  #> - Final Estimated Power: 0.865  #> - Confidence Interval: [0.811; 0.906] #> - Level of confidence: 95.0% #> - Based on 200 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 158  #> - Time spent in the search: 39.82 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Nonlinear Regression Model  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ I((x - c0)^e)/(b + I((x - c0)^e)) #>    data: \"(Omitted)\" #>      b     c0      e  #>  6.615 78.805  1.000  #>  residual sum-of-squares: 0.01498 #>  #> Algorithm \"port\", convergence message: both X-convergence and relative convergence (5) #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.151 1.000  0.760  0.696  0.814 #> 2 105 0.145 1.000  0.800  0.739  0.850 #> 3 119 0.154 1.000  0.865  0.811  0.906 #> 4 132 0.155 1.000  0.885  0.833  0.922 #> 5 158 0.153 1.000  0.920  0.874  0.950 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. plot(out_n_lb) n_power_region <- n_region_from_power(out,                                       seed = 2468) #>  #>  #> --- Phase 1 --- #>  #> Find the approximate region with power significantly below 0.8 ... #>  #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  close_enough  #> What:  ub   (Upper bound of the confidence interval)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [100, 105]  #>  #>  #> Do the simulation for the upper bound: #>  #> Try x = 105  #>  #> Updating the simulation for sample size: 105  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.805, 95.0% confidence interval: [0.745,0.854] #>  #> Initial interval: [100, 105]  #>  #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.151 1.000  0.760  0.696  0.814 #> 2 105 0.150 1.000  0.805  0.745  0.854 #>  #> One of the bounds in the interval is already a solution. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2026-02-01 22:22:10  #> - Rejection Rates: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.151 1.000  0.760  0.696  0.814 #> 2 105 0.150 1.000  0.805  0.745  0.854 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -4.15058      0.05303   #>  #> Degrees of Freedom: 399 Total (i.e. Null);  398 Residual #> Null Deviance:       419  #> Residual Deviance: 417.8     AIC: 421.8 #>  #>  #> - Final Value: 100  #>  #> - Final Estimated Power: 0.7600  #> - Confidence Interval: [0.6963; 0.8139] #> - CI Level: 95.00% #>  #>  #> --- Phase 2 --- #>  #> Find the approximate region with power significantly above 0.8 ... #>  #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  close_enough  #> What:  lb   (Lower bound of the confidence interval)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [105, 113]  #>  #>  #> Do the simulation for the upper bound: #>  #> Try x = 113  #>  #> Updating the simulation for sample size: 113  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.770, 95.0% confidence interval: [0.707,0.823] #>  #> Initial interval: [105, 113]  #>  #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.151 1.000  0.760  0.696  0.814 #> 2 105 0.150 1.000  0.805  0.745  0.854 #> 3 113 0.146 1.000  0.770  0.707  0.823 #>  #>  #>  #> == Enter extending interval ... #>  #> Current interval: [105, 113]  #> Interval above the solution. Extend the lower bound ... #>  #> Try x = 53  #>  #> Updating the simulation for sample size: 53  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.545, 95.0% confidence interval: [0.476,0.613] #>  #>  #> (Extending the interval) Iteration: 1  #>  #> New interval: [53, 105]  #>  #> Try x = 210  #>  #> Updating the simulation for sample size: 210  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.975, 95.0% confidence interval: [0.943,0.989] #>  #>  #> (Extending the interval) Iteration: 2  #>  #> New interval: [105, 210]  #> Interval OK. #> Final extended interval: [105, 210]  #>  #>  #> == Exit extending interval ... #>  #>  #> Iteration # 1  #>  #> Try x = 109  #>  #> Updating the simulation for sample size: 109  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.790, 95.0% confidence interval: [0.728,0.841] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  53 0.161 1.000  0.545  0.476  0.613 #> 2 100 0.151 1.000  0.760  0.696  0.814 #> 3 105 0.150 1.000  0.805  0.745  0.854 #> 4 109 0.147 1.000  0.790  0.728  0.841 #> 5 113 0.146 1.000  0.770  0.707  0.823 #> 6 210 0.147 1.000  0.975  0.943  0.989 #>  #> New interval: [109, 210]  #> Updated x: 160  #>  #> Iteration # 2  #>  #> Try x = 160  #>  #> Updating the simulation for sample size: 160  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.900, 95.0% confidence interval: [0.851,0.934] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  53 0.161 1.000  0.545  0.476  0.613 #> 2 100 0.151 1.000  0.760  0.696  0.814 #> 3 105 0.150 1.000  0.805  0.745  0.854 #> 4 109 0.147 1.000  0.790  0.728  0.841 #> 5 113 0.146 1.000  0.770  0.707  0.823 #> 6 160 0.151 1.000  0.900  0.851  0.934 #> 7 210 0.147 1.000  0.975  0.943  0.989 #>  #> New interval: [109, 160]  #> Updated x: 135  #>  #> Iteration # 3  #>  #> Try x = 135  #>  #> Updating the simulation for sample size: 135  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.835, 95.0% confidence interval: [0.777,0.880] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  53 0.161 1.000  0.545  0.476  0.613 #> 2 100 0.151 1.000  0.760  0.696  0.814 #> 3 105 0.150 1.000  0.805  0.745  0.854 #> 4 109 0.147 1.000  0.790  0.728  0.841 #> 5 113 0.146 1.000  0.770  0.707  0.823 #> 6 135 0.139 1.000  0.835  0.777  0.880 #> 7 160 0.151 1.000  0.900  0.851  0.934 #> 8 210 0.147 1.000  0.975  0.943  0.989 #>  #> New interval: [135, 160]  #> Updated x: 148  #>  #> Iteration # 4  #>  #> Try x = 148  #>  #> Updating the simulation for sample size: 148  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.885, 95.0% confidence interval: [0.833,0.922] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  53 0.161 1.000  0.545  0.476  0.613 #> 2 100 0.151 1.000  0.760  0.696  0.814 #> 3 105 0.150 1.000  0.805  0.745  0.854 #> 4 109 0.147 1.000  0.790  0.728  0.841 #> 5 113 0.146 1.000  0.770  0.707  0.823 #> 6 135 0.139 1.000  0.835  0.777  0.880 #> 7 148 0.151 1.000  0.885  0.833  0.922 #> 8 160 0.151 1.000  0.900  0.851  0.934 #> 9 210 0.147 1.000  0.975  0.943  0.989 #>  #> New interval: [135, 148]  #> Updated x: 142  #>  #> Iteration # 5  #>  #> Try x = 142  #>  #> Updating the simulation for sample size: 142  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.900, 95.0% confidence interval: [0.851,0.934] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1   53 0.161 1.000  0.545  0.476  0.613 #> 2  100 0.151 1.000  0.760  0.696  0.814 #> 3  105 0.150 1.000  0.805  0.745  0.854 #> 4  109 0.147 1.000  0.790  0.728  0.841 #> 5  113 0.146 1.000  0.770  0.707  0.823 #> 6  135 0.139 1.000  0.835  0.777  0.880 #> 7  142 0.152 1.000  0.900  0.851  0.934 #> 8  148 0.151 1.000  0.885  0.833  0.922 #> 9  160 0.151 1.000  0.900  0.851  0.934 #> 10 210 0.147 1.000  0.975  0.943  0.989 #>  #> New interval: [135, 142]  #> Updated x: 139  #>  #> Iteration # 6  #>  #> Try x = 139  #>  #> Updating the simulation for sample size: 139  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.880, 95.0% confidence interval: [0.828,0.918] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1   53 0.161 1.000  0.545  0.476  0.613 #> 2  100 0.151 1.000  0.760  0.696  0.814 #> 3  105 0.150 1.000  0.805  0.745  0.854 #> 4  109 0.147 1.000  0.790  0.728  0.841 #> 5  113 0.146 1.000  0.770  0.707  0.823 #> 6  135 0.139 1.000  0.835  0.777  0.880 #> 7  139 0.146 1.000  0.880  0.828  0.918 #> 8  142 0.152 1.000  0.900  0.851  0.934 #> 9  148 0.151 1.000  0.885  0.833  0.922 #> 10 160 0.151 1.000  0.900  0.851  0.934 #> 11 210 0.147 1.000  0.975  0.943  0.989 #>  #> New interval: [135, 139]  #> Updated x: 137  #>  #> Iteration # 7  #>  #> Try x = 137  #>  #> Updating the simulation for sample size: 137  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.910, 95.0% confidence interval: [0.862,0.942] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1   53 0.161 1.000  0.545  0.476  0.613 #> 2  100 0.151 1.000  0.760  0.696  0.814 #> 3  105 0.150 1.000  0.805  0.745  0.854 #> 4  109 0.147 1.000  0.790  0.728  0.841 #> 5  113 0.146 1.000  0.770  0.707  0.823 #> 6  135 0.139 1.000  0.835  0.777  0.880 #> 7  137 0.153 1.000  0.910  0.862  0.942 #> 8  139 0.146 1.000  0.880  0.828  0.918 #> 9  142 0.152 1.000  0.900  0.851  0.934 #> 10 148 0.151 1.000  0.885  0.833  0.922 #> 11 160 0.151 1.000  0.900  0.851  0.934 #> 12 210 0.147 1.000  0.975  0.943  0.989 #>  #> Current interval:  [135, 137]  #> - Interval too narrow. Extend it ...  #>  #>  #>  #> == Enter extending interval ... #>  #> Current interval: [135, 137]  #> Interval above the solution. Extend the lower bound ... #>  #> Try x = 122  #>  #> Updating the simulation for sample size: 122  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.870, 95.0% confidence interval: [0.816,0.910] #>  #>  #> (Extending the interval) Iteration: 1  #>  #> New interval: [122, 135]  #> Interval OK. #> Final extended interval: [122, 135]  #>  #>  #> == Exit extending interval ... #>  #> New interval: [122, 135]  #> Updated x: 129  #>  #> Iteration # 8  #>  #> Try x = 129  #>  #> Updating the simulation for sample size: 129  #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Estimated power at n: 0.840, 95.0% confidence interval: [0.783,0.884] #> - Rejection Rates: #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1   53 0.161 1.000  0.545  0.476  0.613 #> 2  100 0.151 1.000  0.760  0.696  0.814 #> 3  105 0.150 1.000  0.805  0.745  0.854 #> 4  109 0.147 1.000  0.790  0.728  0.841 #> 5  113 0.146 1.000  0.770  0.707  0.823 #> 6  122 0.154 1.000  0.870  0.816  0.910 #> 7  129 0.154 1.000  0.840  0.783  0.884 #> 8  135 0.139 1.000  0.835  0.777  0.880 #> 9  137 0.153 1.000  0.910  0.862  0.942 #> 10 139 0.146 1.000  0.880  0.828  0.918 #> 11 142 0.152 1.000  0.900  0.851  0.934 #> 12 148 0.151 1.000  0.885  0.833  0.922 #> 13 160 0.151 1.000  0.900  0.851  0.934 #> 14 210 0.147 1.000  0.975  0.943  0.989 #>  #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2026-02-01 22:24:10  #> - Rejection Rates: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1   53 0.161 1.000  0.545  0.476  0.613 #> 2  100 0.151 1.000  0.760  0.696  0.814 #> 3  105 0.150 1.000  0.805  0.745  0.854 #> 4  109 0.147 1.000  0.790  0.728  0.841 #> 5  113 0.146 1.000  0.770  0.707  0.823 #> 6  122 0.154 1.000  0.870  0.816  0.910 #> 7  129 0.154 1.000  0.840  0.783  0.884 #> 8  135 0.139 1.000  0.835  0.777  0.880 #> 9  137 0.153 1.000  0.910  0.862  0.942 #> 10 139 0.146 1.000  0.880  0.828  0.918 #> 11 142 0.152 1.000  0.900  0.851  0.934 #> 12 148 0.151 1.000  0.885  0.833  0.922 #> 13 160 0.151 1.000  0.900  0.851  0.934 #> 14 210 0.147 1.000  0.975  0.943  0.989 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ 1 - I(exp((a - x)/b)) #>    data: \"(Omitted)\" #>      a      b  #>  1.796 66.235  #>  residual sum-of-squares: 1.435 #>  #> Algorithm \"port\", convergence message: relative convergence (4) #>  #>  #> - Final Value: 129  #>  #> - Final Estimated Power: 0.8400  #> - Confidence Interval: [0.7829; 0.8843] #> - CI Level: 95.00% n_power_region #> Call: #> n_region_from_power(object = out, seed = 2468) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 100 to 129 #> - significantly lower than 0.800: 100 #> - significantly higher than 0.800: 129 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (100): [0.696, 0.814] #> - for the upper bound (129): [0.783, 0.884] #>  #> Call `summary()` for detailed results. plot(n_power_region) n_power_region2 <- n_region_from_power(out_n_lb,                                       seed = 24680) #>  #>  #> --- Phase 1 --- #>  #> Find the approximate region with power significantly below 0.8 ... #>  #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  close_enough  #> What:  ub   (Upper bound of the confidence interval)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> --- Solution Already Found --- #>  #> Solution already found in the object. Search will be skipped. #>  #>  #> --- Final Stage --- #>  #> - Start at 2026-02-01 22:24:10  #> - Rejection Rates: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.151 1.000  0.760  0.696  0.814 #> 2 105 0.145 1.000  0.800  0.739  0.850 #> 3 119 0.154 1.000  0.865  0.811  0.906 #> 4 132 0.155 1.000  0.885  0.833  0.922 #> 5 158 0.153 1.000  0.920  0.874  0.950 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_curve_args$power_model,  #>     start = power_curve_args$start, lower_bound = power_curve_args$lower_bound,  #>     upper_bound = power_curve_args$upper_bound, nls_args = power_curve_args$nls_args,  #>     nls_control = power_curve_args$nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ I((x - c0)^e)/(b + I((x - c0)^e)) #>    data: \"(Omitted)\" #>      b     c0      e  #>  6.615 78.805  1.000  #>  residual sum-of-squares: 0.01498 #>  #> Algorithm \"port\", convergence message: both X-convergence and relative convergence (5) #>  #>  #> - Final Value: 100  #>  #> - Final Estimated Power: 0.7600  #> - Confidence Interval: [0.6963; 0.8139] #> - CI Level: 95.00% #>  #>  #> --- Phase 2 --- #>  #> Find the approximate region with power significantly above 0.8 ... #>  #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  close_enough  #> What:  lb   (Lower bound of the confidence interval)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> --- Solution Already Found --- #>  #> Solution already found in the object. Search will be skipped. #>  #>  #> --- Final Stage --- #>  #> - Start at 2026-02-01 22:24:10  #> - Rejection Rates: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.151 1.000  0.760  0.696  0.814 #> 2 105 0.145 1.000  0.800  0.739  0.850 #> 3 119 0.154 1.000  0.865  0.811  0.906 #> 4 132 0.155 1.000  0.885  0.833  0.922 #> 5 158 0.153 1.000  0.920  0.874  0.950 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_curve_args$power_model,  #>     start = power_curve_args$start, lower_bound = power_curve_args$lower_bound,  #>     upper_bound = power_curve_args$upper_bound, nls_args = power_curve_args$nls_args,  #>     nls_control = power_curve_args$nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ I((x - c0)^e)/(b + I((x - c0)^e)) #>    data: \"(Omitted)\" #>      b     c0      e  #>  6.615 78.805  1.000  #>  residual sum-of-squares: 0.01498 #>  #> Algorithm \"port\", convergence message: both X-convergence and relative convergence (5) #>  #>  #> - Final Value: 119  #>  #> - Final Estimated Power: 0.8650  #> - Confidence Interval: [0.8107; 0.9055] #> - CI Level: 95.00% n_power_region2 #> Call: #> n_region_from_power(object = out_n_lb, seed = 24680) #>  #>                      Setting                                       #> Predictor(x)         Sample Size                                   #> Goal:                Power significantly below or above the target #> algorithm:           bisection                                     #> Level of confidence: 95.00%                                        #> Target Power:        0.800                                         #>  #> Solution:  #>  #> Approximate region of sample sizes with power: #> - not significantly different from 0.800: 100 to 119 #> - significantly lower than 0.800: 100 #> - significantly higher than 0.800: 119 #>  #> Confidence intervals of the estimated power: #> - for the lower bound (100): [0.696, 0.814] #> - for the upper bound (119): [0.811, 0.906] #>  #> Call `summary()` for detailed results. plot(n_power_region2)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflow of 'x_from_power()' Using the 'power_curve' Algorithm","text":"technical appendix describes workflow x_from_power() power4mome using \"power_curve\" algorithm.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"x_from_power","dir":"Articles","previous_headings":"","what":"x_from_power()","title":"Workflow of 'x_from_power()' Using the 'power_curve' Algorithm","text":"following workflow x_from_power(), algorithm \"power_curve\" used. Simulation done value x, can slow Monte Carlo bootstrapping confidence intervals involved test. feasible, also necessary, accurately estimate levels power along many values across range x, goal find value x target power. Therefore, steps taken balance speed precision finding solution. Power x (Sample Size Effect Size [Parameter Value]) x_from_power, x can sample size (n) population value (es, “effect size”) selected model parameter.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"annotation","dir":"Articles","previous_headings":"","what":"Annotation","title":"Workflow of 'x_from_power()' Using the 'power_curve' Algorithm","text":"by_x_1 collection values tried results. updated whenever new value(s) /tried. fit_1 latest power curve estimated power_curve, using values tried, stored by_x_1. updated whenever by_x_1 updated. x_j value(s) power levels estimated trial. nrep_j number replications used estimate power level value x. trial, numbers replications can different different values, efficiency. by_x_j results power4test_by_n() power4test_by_es() given x_j trial. x_out value x candidate solution (e.g., estimated power closest target value). power_out, nrep_out, ci_out, by_x_out Results based x_out. ci_hit Logical. Set TRUE least one value x confidence interval estimated power including target power. final_nrep desired number replications solution. value determines desired level precision (width confidence interval) solution. sequences values nrep, R, number x trial. initial number replications (nrep) can smaller final_nrep, initial trials, though lower precision (wider confidence intervals), faster run. solution likely found (values x estimated power close target value found), nrep increased successively final_nrep, trial slower run higher precision. values affect speed, number values x (xs_per_trial) number iterations (R) Monte Carlo confidence intervals bootstrapping, also increased successively. x_final value x solution (e.g., estimated power closest target value), found. power_final, nrep_final, ci_final, by_x_final Results based x_final. Main functions used power4test_by_n() power4test_by_es(), estimating power levels set values x. power_curve(), estimating relation power value x, based values x examined. internal function estimate_x_range(), determining value(s) x examined trial, given value(s) examined far tentative power curve.","code":""},{"path":"https://sfcheung.github.io/power4mome/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Shu Fai Cheung. Author, maintainer. Sing-Hang Cheung. Author. Wendie Yang. Author.","code":""},{"path":"https://sfcheung.github.io/power4mome/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cheung S, Cheung S, Yang W (2026). power4mome: Power Analysis Moderation Mediation. R package version 0.1.1.35, https://sfcheung.github.io/power4mome/.","code":"@Manual{,   title = {power4mome: Power Analysis for Moderation and Mediation},   author = {Shu Fai Cheung and Sing-Hang Cheung and Wendie Yang},   year = {2026},   note = {R package version 0.1.1.35},   url = {https://sfcheung.github.io/power4mome/}, }"},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"power4mome-","dir":"","previous_headings":"","what":"Power Analysis for Moderation and Mediation","title":"Power Analysis for Moderation and Mediation","text":"package power analysis sample size determination moderation, mediation, moderated mediation. includes functions power analysis sample size determination moderation, mediation, moderated mediation effects models fitted structural equation modeling (SEM) multiple linear regression. SEM, latent variable models path models observed variables supported. information package, please visit GitHub page: https://sfcheung.github.io/power4mome/ get-started guide illustrates use package: https://sfcheung.github.io/power4mome/articles/power4mome.html Code templates also available common mediation, moderation, moderated mediation models: https://sfcheung.github.io/power4mome/articles/","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"philosophy","dir":"","previous_headings":"","what":"Philosophy","title":"Power Analysis for Moderation and Mediation","text":"package developed philosophy: Easy specify population models, even latent variables. manually-set numbers possible specifying population models, convenient default values. restrictions possible form models, even models latent factors. automatic possible finding sample size target power. achieve comes costs, goals conflict goals: flexible usually means less user-friendly, easy specify model usually means supporting models. Therefore, also try balance goals, allow functions used different ways, accommodate scenarios prioritize goals differently.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Power Analysis for Moderation and Mediation","text":"stable version CRAN can installed install.packages(): latest developmental version package can installed remotes::install_github:","code":"install.packages(\"power4mome\") remotes::install_github(\"sfcheung/power4mome\")"},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"background","dir":"","previous_headings":"","what":"Background","title":"Power Analysis for Moderation and Mediation","text":"us developers developed package manymome (Cheung & Cheung, 2024) computing testing effects models mediation, mediation, moderated mediation. tests usually done simulation-based methods Monte Carlo bootstrap confidence intervals, due complicated sampling distributions effects. Therefore, simple ways determine power test analytically accurately. computation becomes complicated latent variables involved, necessitating simulation-based method estimate sample size. already many excellent packages estimating power structural equation modeling general, also specifically mediation moderated mediation. intended replace reinvent wheel. just want tool meet needs: leverages flexibility manymome testing indirect effect conditional effect little limitations model. allows users (us collaborators) specify population model easy (quickly) typical power analysis programs. know power estimation simulation, necessary. However, time usually concern, like tool , though specifically designed mediation, moderation, moderated mediation mind may limited scope (though “big” scope), easy daily use estimating power. , power4mome, developed users, believe also useful others need power analysis mediation, moderation, moderated mediation.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"not-just-that-","dir":"","previous_headings":"","what":"Not Just That …","title":"Power Analysis for Moderation and Mediation","text":"power4mome just mediation, moderation, moderated mediation. avoided wrote functions just effects, left room testing effects, hinted examples help pages. may introduced later. now, supporting effects can tested manymome priority.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Power Analysis for Moderation and Mediation","text":"suggestions found bugs, please feel free open GitHub issue: https://github.com/sfcheung/power4mome/issues Thanks.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"Power Analysis for Moderation and Mediation","text":"Cheung, S. F., & Cheung, S.-H. (2024). manymome: R package computing indirect effects, conditional effects, conditional indirect effects, standardized unstandardized, bootstrap confidence intervals, many (though ) models. Behavior Research Methods, 56(5), 4862–4882. https://doi.org/10.3758/s13428-023-02224-z","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Do a Test on Each Replication — do_test","title":"Do a Test on Each Replication — do_test","text":"test replication output sim_out().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do a Test on Each Replication — do_test","text":"","code":"do_test(   sim_all,   test_fun,   test_args = list(),   map_names = c(fit = \"fit\"),   results_fun = NULL,   results_args = list(),   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )"},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do a Test on Each Replication — do_test","text":"sim_all output sim_out(). test_fun function test. See 'Details' requirement function. built-test functions power4mome, described 'Details'. test_args list arguments passed test_fun function. Default list(). map_names named character vector specifying content element extra replication sim_all map argument test_fun. Default c(fit = \"fit\"), indicating element fit element extra set argument fit test_fun. , first replication, fit = sim_out[[1]]$extra$fit calling test_fun. results_fun function used extract test results. See Details requirements function. Default NULL, assuming output test_fun can used directly. results_args list arguments passed results_fun function. Default list(). parallel TRUE, parallel processing used tests. Default FALSE. progress TRUE, progress tests displayed. Default `FALSE. ncores number CPU cores use parallel processing used.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do a Test on Each Replication — do_test","text":"object class test_out, list length equal sim_all, one element replication. element list two elements: test: output function set test_fun. test_results: output function set results_fun.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Do a Test on Each Replication — do_test","text":"function do_test() arbitrary test replication using function set test_fun.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-role-of-do-test-","dir":"Reference","previous_headings":"","what":"The role of do_test()","title":"Do a Test on Each Replication — do_test","text":"function do_test() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-test-function-test-fun-","dir":"Reference","previous_headings":"","what":"The test function (test_fun)","title":"Do a Test on Each Replication — do_test","text":"function set test_fun, test function, usually work output lavaan::sem(), lmhelprs::many_lm(), stats::lm(), can also function works output function set fit_function calling fit_model() power4test() (see fit_model_args). function two default requirements. First, argument fit, set output lavaan::sem() another output stored element extra$fit replication sim_all object. (requirement can relaxed; see section map_names.) , function definition : FUN(fit, ...). form test_* functions power4mome. arguments passed test function, can set test_args named list. Second, test function must returns output () can processed results function (see ), (b) required format output results function (see next section). already returns output required format, need set results function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-results-function-results-fun-","dir":"Reference","previous_headings":"","what":"The results function (results_fun)","title":"Do a Test on Each Replication — do_test","text":"test results extracted output test_fun function set results_fun, results function. test_fun already returns output expected format (see ), set results_fun NULL, default. output test_fun used estimating power. function set results_fun must accept output test_fun, first argument, return named list (can data frame) named vector following elements: est: Optional. estimate parameter, applicable. se: Optional. standard error estimate, applicable. cilo: Optional. lower limit confidence interval, applicable. cihi: Optional. upper limit confidence interval, applicable. sig: Required. 1, test significant. 0, test significant. test done reason, NA. results can used estimate power Type error test. example, null hypothesis false, proportion significant, , mean values sig across replications, power.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"built-in-test-functions","dir":"Reference","previous_headings":"","what":"Built-in test functions","title":"Do a Test on Each Replication — do_test","text":"package power4mome ready--use test functions: test_indirect_effect() test_cond_indirect() test_cond_indirect_effects() test_moderation() test_index_of_mome() test_parameters() Please refer help pages examples.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-argument-map-names","dir":"Reference","previous_headings":"","what":"The argument map_names","title":"Do a Test on Each Replication — do_test","text":"argument developers using test function different name argument fit object (\"fit\", default). test_fun set function works output , say, lavaan::sem() argument name output fit, mapping can changed map_names. example, lavaan::parameterEstimates() receives output lavaan::sem() reports test results model parameters. However, argument name lavaan output object. instruct do_test() test correctly setting test_fun lavaan::parameterEstimates, add map_names = c(object = \"fit\"). element fit replication set argument object lavaan::parameterEstimates().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-background-for-having-the-results-fun-argument","dir":"Reference","previous_headings":"","what":"The background for having the results_fun argument","title":"Do a Test on Each Replication — do_test","text":"early development power4mome, test_fun designed accept existing functions packages, manymome::indirect_effect(). outputs required format power analysis, results functions needed process outputs. current version power4mome, ready--use test functions, usually wrappers existing functions packages, developed, longer need results functions process output. argument results_fun kept backward compatibility advanced users use test functions packages.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do a Test on Each Replication — do_test","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate Monte Carlo estimates for forming Monte Carlo confidence intervals  mc_all <- gen_mc(fit_all,                  R = 50,                  iseed = 4567)  # Combine the results to a 'sim_all' object sim_all <- sim_out(data_all = data_all,                    fit = fit_all,                    mc_out = mc_all)  # Test the indirect effect in each replication # Set `parallel` to TRUE for faster, usually much faster, analysis # Set `progress` to TRUE to display the progress of the analysis  test_all <- do_test(sim_all,                     test_fun = test_indirect_effect,                     test_args = list(x = \"x\",                                      m = \"m\",                                      y = \"y\",                                      mc_ci = TRUE),                     parallel = FALSE,                     progress = FALSE)  # The result for each dataset lapply(test_all, function(x) x$test_results) #> [[1]] #>        est       cilo       cihi        sig     pvalue  #> 0.10147276 0.02144103 0.18035550 1.00000000 0.00000000  #>  #> [[2]] #>          est         cilo         cihi          sig       pvalue  #>  0.079776696 -0.002117072  0.194482289  0.000000000  0.040000000  #>  #> [[3]] #>          est         cilo         cihi          sig       pvalue  #>  0.052746533 -0.001695808  0.117672020  0.000000000  0.040000000  #>  #> [[4]] #>        est       cilo       cihi        sig     pvalue  #> 0.10461042 0.02975369 0.23184723 1.00000000 0.00000000  #>  #> [[5]] #>         est        cilo        cihi         sig      pvalue  #> 0.116902305 0.003271956 0.251780798 1.000000000 0.040000000  #>"},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Model to a List of Datasets — fit_model","title":"Fit a Model to a List of Datasets — fit_model","text":"Get output sim_data() fit model stored datasets.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Model to a List of Datasets — fit_model","text":"","code":"fit_model(   data_all = NULL,   model = NULL,   fit_function = \"lavaan\",   arg_data_name = \"data\",   arg_model_name = \"model\",   arg_group_name = \"group\",   ...,   fit_out = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )"},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Model to a List of Datasets — fit_model","text":"data_all output sim_data(), sim_data class object. model model fitted. NULL, default, model stored data_all, data generation model, used. fit_function function used fit model. Can also string: \"lavaan\" (default) lavaan::sem(), \"lm\" many_lm lmhelprs::many_lm(). functions can also used necessary. arg_data_name name argument fit_function expecting dataset. Default \"data\". arg_model_name name argument fit_function expecting model definition. Default \"model\". arg_group_name name argument fit_function expecting name group variable. Used multigroup models. Default \"group\". ... Optional arguments passed fit_function fitting model. fit_out set fit_out object (output fit_model()), missing arguments retrieved fit_out. , users can use fit_model(data_all = new_data, fit_out = old_out) re-fit model originally fitted old_out new list dataset (new_data). need include arguments. parallel TRUE, parallel processing used fit models. Default FALSE. progress TRUE, progress model fitting displayed. Default `FALSE. ncores number CPU cores use parallel processing used.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Model to a List of Datasets — fit_model","text":"object class fit_out, list output fit_function (lavaan::sem() default). error occurred fitting model dataset, element error message fit function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a Model to a List of Datasets — fit_model","text":"default, function fit_model() extracts model stored output sim_data(), fits model dataset simulated using fit_function, default \"lavaan\" lavaan::sem() called, returns results. datasets generated multigroup model calling sim_data(), multigroup model fitted.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"the-role-of-fit-model-","dir":"Reference","previous_headings":"","what":"The role of fit_model()","title":"Fit a Model to a List of Datasets — fit_model","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize model fitting step power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Model to a List of Datasets — fit_model","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all) fit_all[[1]] #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0  # Fit the population model using the MLR estimator  fit_all_mlr <- fit_model(data_all,                          estimator = \"MLR\") fit_all_mlr[[1]] #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                               Standard      Scaled #>   Test Statistic                                 0.000       0.000 #>   Degrees of freedom                                 0           0  # Fit a model different from the population model, # with the MLR estimator  mod2 <- \"m ~ x  y ~ m\"  fit_all_mlr2 <- fit_model(data_all,                           mod2,                           estimator = \"MLR\") fit_all_mlr2[[1]] #> lavaan 0.6-21 ended normally after 2 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         4 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                               Standard      Scaled #>   Test Statistic                                 0.975       1.128 #>   Degrees of freedom                                 1           1 #>   P-value (Chi-square)                           0.323       0.288 #>   Scaling correction factor                                  0.864 #>     Yuan-Bentler correction (Mplus variant)"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Bootstrap Estimates — gen_boot","title":"Generate Bootstrap Estimates — gen_boot","text":"Get list output lavaan::sem() lmhelprs::many_lm() generate bootstrap estimates model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Bootstrap Estimates — gen_boot","text":"","code":"gen_boot(   fit_all,   R = 100,   ...,   iseed = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   compute_implied_stats = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Bootstrap Estimates — gen_boot","text":"fit_all output fit_model() object class fit_out. R number replications generate bootstrap estimates fit output. ... Optional arguments passed manymome::do_boot() generating bootstrap estimates. iseed seed random number generator. Default NULL seed changed. parallel TRUE, parallel processing used generate bootstrap estimates fit outputs. Default FALSE. progress TRUE, progress displayed. Default `FALSE. ncores number CPU cores use parallel processing used. compute_implied_stats Whether implied statistics computed bootstrap samples. Usually needed default FALSE","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Bootstrap Estimates — gen_boot","text":"boot_list object, list output manymome::do_boot().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Bootstrap Estimates — gen_boot","text":"function gen_boot() simply calls manymome::do_boot() output lavaan::sem() lmhelprs::many_lm() fit_all. simulated estimates can used test effects indirect effects, usually functions manymome package, manymome::indirect_effect().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"the-role-of-gen-boot-","dir":"Reference","previous_headings":"","what":"The role of gen_boot()","title":"Generate Bootstrap Estimates — gen_boot","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize workflow power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Bootstrap Estimates — gen_boot","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 2,                      model = mod,                      pop_es = es,                      n = 50,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate bootstrap estimates for each replication  boot_all <- gen_boot(fit_all,                      R = 10,                      iseed = 4567) boot_all #> [[1]] #>  #> == A 'boot_out' class object == #>  #> Number of bootstrap samples: 10  #>  #>  #> [[2]] #>  #> == A 'boot_out' class object == #>  #> Number of bootstrap samples: 10  #>  #>  #> attr(,\"class\") #> [1] \"boot_list\" \"list\""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Monte Carlo Estimates — gen_mc","title":"Generate Monte Carlo Estimates — gen_mc","text":"Get list output lavaan::sem() generate Monte Carlo estimates model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Monte Carlo Estimates — gen_mc","text":"","code":"gen_mc(   fit_all,   R = 100,   ...,   iseed = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   compute_implied_stats = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Monte Carlo Estimates — gen_mc","text":"fit_all output fit_model() object class fit_out. R number replications generate Monte Carlo estimates fit output. ... Optional arguments passed manymome::do_mc() generating Monte Carlo estimates. iseed seed random number generator. Default NULL seed changed. parallel TRUE, parallel processing used generate Monte Carlo estimates fit outputs. Default FALSE. progress TRUE, progress displayed. Default `FALSE. ncores number CPU cores use parallel processing used. compute_implied_stats Whether implied statistics computed Monte Carlo replication. Usually needed default FALSE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Monte Carlo Estimates — gen_mc","text":"mc_list object, list output manymome::do_mc().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Monte Carlo Estimates — gen_mc","text":"function gen_mc() simply calls manymome::do_mc() output lavaan::sem() fit_all. simulated estimates can used test effects indirect effects, usually functions manymome package, manymome::indirect_effect().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"the-role-of-gen-mc-","dir":"Reference","previous_headings":"","what":"The role of gen_mc()","title":"Generate Monte Carlo Estimates — gen_mc","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize workflow power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Monte Carlo Estimates — gen_mc","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate Monte Carlo estimates for each replication  mc_all <- gen_mc(fit_all,                  R = 100,                  iseed = 4567)  mc_all #> [[1]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[2]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[3]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[4]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[5]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> attr(,\"class\") #> [1] \"mc_list\" \"list\""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Power Curve — plot.power_curve","title":"Plot a Power Curve — plot.power_curve","text":"Plotting results 'power_curve' object, estimated power sample size, results power4test_by_n() power4test_by_es().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Power Curve — plot.power_curve","text":"","code":"# S3 method for class 'power_curve' plot(   x,   what = c(\"ci\", \"power_curve\"),   main = paste0(\"Power Curve \", \"(Predictor: \", switch(x$predictor, n = \"Sample Size\", es     = \"Effect Size\"), \")\"),   xlab = switch(x$predictor, n = \"Sample Size\", es = \"Effect Size\"),   ylab = \"Estimated Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )  # S3 method for class 'power4test_by_n' plot(   x,   what = c(\"ci\", \"power_curve\"),   main = \"Estimated Power vs. Sample Size\",   xlab = \"Sample Size\",   ylab = \"Estimated Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )  # S3 method for class 'power4test_by_es' plot(   x,   what = c(\"ci\", \"power_curve\"),   main = paste0(\"Estimated Power vs. Effect Size / Parameter (\", attr(x[[1]],     \"pop_es_name\"), \")\"),   xlab = paste0(\"Effect Size / Parameter (\", attr(x[[1]], \"pop_es_name\"), \")\"),   ylab = \"Estiamted Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Power Curve — plot.power_curve","text":"x object plotted. can power_curve object, output power_curve(). can also output power4test_by_n() power4test_by_es(). character vector include plot. Possible values \"ci\" (confidence intervals estimated sample size) \"power_curve\" (crude power curve, available). default values depend type x. main title plot. xlab, ylab labels horizontal vertical axes, respectively. pars_ci named list arguments passed arrows() customize drawing confidence intervals. type argument default plot method plot.default(). Default \"l\". See plot.default() options. ylim two-element numeric vector range vertical axis. ci_level level confidence confidence intervals, requested. Default .95, denoting 95%. ... Optional arguments. Passed plot() drawing base plot.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Power Curve — plot.power_curve","text":"plot-methods return x invisibly. called side effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a Power Curve — plot.power_curve","text":"plot method power_curve objects currently plots relation estimated power predictor. elements can requested (see argument ), can customized individually.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a Power Curve — plot.power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes # Set `parallel` to TRUE for faster, usually much faster, analysis # Set `progress` to TRUE to display the progress of the analysis  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 50, 100),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -4.28606      0.02986   #>  #> Degrees of Freedom: 29 Total (i.e. Null);  28 Residual #> Null Deviance:\t    19.5  #> Residual Deviance: 17.37 \tAIC: 21.37 plot(pout1)   # By pop_es: Do a test for different population values of a model parameter # Set `parallel` to TRUE for faster, usually much faster, analysis # Set `progress` to TRUE to display the progress of the analysis  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = c(0, .3, .5),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) plot(pout2)"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot The Results of 'x_from_power' — plot.x_from_power","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"plots results 'x_from_power', estimated power sample size.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"","code":"# S3 method for class 'x_from_power' plot(   x,   what = c(\"ci\", \"power_curve\", \"final_x\", \"final_power\", \"target_power\", switch(x$x, n =     \"sig_area\", es = NULL)),   text_what = c(\"final_x\", \"final_power\", switch(x$x, n = \"sig_area\", es = NULL)),   digits = 3,   main = paste0(\"Power Curve \", \"(Target Power: \", formatC(x$target_power, digits =     digits, format = \"f\"), \")\"),   xlab = NULL,   ylab = \"Estimated Power\",   ci_level = 0.95,   pars_ci = list(),   pars_power_curve = list(),   pars_ci_final_x = list(lwd = 2, length = 0.2, col = \"blue\"),   pars_target_power = list(lty = \"dashed\", lwd = 2, col = \"black\"),   pars_final_x = list(lty = \"dotted\"),   pars_final_power = list(lty = \"dotted\", col = \"blue\"),   pars_text_final_x = list(y = 0, pos = 3, cex = 1),   pars_text_final_power = list(pos = 3, cex = 1),   pars_sig_area = list(col = adjustcolor(\"lightblue\", alpha.f = 0.1)),   pars_text_sig_area = list(cex = 1),   ... )  # S3 method for class 'n_region_from_power' plot(   x,   what = c(\"ci\", \"power_curve\", \"final_x\", \"final_power\", \"target_power\", \"sig_area\"),   text_what = c(\"final_x\", \"final_power\", \"sig_area\"),   digits = 3,   main = paste0(\"Power Curve \", \"(Target Power: \", formatC(x$below$target_power, digits =     digits, format = \"f\"), \")\"),   xlab = NULL,   ylab = \"Estimated Power\",   ci_level = 0.95,   pars_ci = list(),   pars_power_curve = list(),   pars_ci_final_x = list(lwd = 2, length = 0.2, col = \"blue\"),   pars_target_power = list(lty = \"dashed\", lwd = 2, col = \"black\"),   pars_final_x = list(lty = \"dotted\"),   pars_final_power = list(lty = \"dotted\", col = \"blue\"),   pars_text_final_x = list(pos = 3, cex = 1),   pars_text_final_x_lower = pars_text_final_x,   pars_text_final_x_upper = pars_text_final_x,   pars_text_final_power = list(cex = 1),   pars_sig_area = list(col = adjustcolor(\"lightblue\", alpha.f = 0.1)),   pars_text_sig_area = list(cex = 1),   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"x x_from_power object, output x_from_power(). character vector include plot. Possible values \"ci\" (confidence intervals estimated value predictor), \"power_curve\" (crude power curve, available), \"final_x\" (vertical line value predictor estimated power close enough target power confidence interval), \"final_power\" (horizontal line estimated power final value predictor), \"target_power\" (horizontal line target power), \"sig_area\" (area significantly higher lower target power, goal \"close_enough\" \"lb\" \"ub\"). default, elements plotted. text_what character vector numbers added labels. Possible values \"final_x\" (value predictor estimated power close enough target power confidence interval) \"final_power\" (estimated power final value predictor), \"sig_area\" (labeling area significantly higher lower target power, goal \"close_enough\" \"lb\" \"ub\"). default, labels added. digits number digits decimal used adding numbers. main title plot. xlab, ylab labels horizontal vertical axes, respectively. ci_level level confidence confidence intervals, requested. Default .95, denoting 95%. pars_ci named list arguments passed arrows() customize drawing confidence intervals. pars_power_curve named list arguments passed points() customize drawing power curve. pars_ci_final_x named list arguments passed arrows() customize drawing confidence interval final value predictor. pars_target_power named list arguments passed abline() drawing horizontal line target power. pars_final_x named list arguments passed abline() drawing vertical line final value predictor. pars_final_power named list arguments passed abline() drawing horizontal line estimated power final value predictor. pars_text_final_x named list arguments passed text() adding label final value predictor. pars_text_final_power named list arguments passed text() adding label estimated power final value predictor. pars_sig_area named list arguments passed rect() shading area significantly higher lower target power. pars_text_sig_area named list arguments passed text() labelling area significantly higher lower target power. ... Optional arguments. Passed plot() drawing estimated power predictor. pars_text_final_x_lower, pars_text_final_x_upper two values predictor printed, named list arguments passed text() adding labels two values.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"plot-method x_from_power returns x invisibly. called side effect. plot-method n_region_from_power returns x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"plot method x_from_power objects currently plots relation estimated power values examined x_from_power(). elements can requested (see argument ), can customized individually. plot-method n_region_from_power objects modified version plot-method x_from_power. plots results two runs n_from_power() one plot. otherwise similar plot-method x_from_power.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 10,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 10,                            max_trials = 1,                            seed = 2345) #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  ci_hit  #> What:  point   (Estimated Power)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [50, 100]  #>  #>  #> Do the simulation for the lower bound: #>  #> Try x = 50  #>  #> Updating the simulation for sample size: 50  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 0.700, 95.0% confidence interval: [0.397,0.892] #>  #> Initial interval: [50, 100]  #>  #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.307 1.000  0.700  0.397  0.892 #> 2 100 0.320 1.000  0.800  0.490  0.943 #>  #> One of the bounds in the interval is already a solution. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2026-02-01 15:17:24  #> - Rejection Rates: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.307 1.000  0.700  0.397  0.892 #> 2 100 0.320 1.000  0.800  0.490  0.943 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     0.30830      0.01078   #>  #> Degrees of Freedom: 19 Total (i.e. Null);  18 Residual #> Null Deviance:\t    22.49  #> Residual Deviance: 22.23 \tAIC: 26.23 #>  #>  #> - Final Value: 50  #>  #> - Final Estimated Power: 0.7000  #> - Confidence Interval: [0.3968; 0.8922] #> - CI Level: 95.00% plot(power_vs_n)"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Convert YAML string vector list pop_es specification.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"","code":"pop_es_yaml(text)"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"text multiline string parsed specification population values.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Either named vector (single-group model) list named vector (multigroup model) population values parameters (effect sizes).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"function pop_es_yaml() allows users specify population values model using one single string, 'lavaan' model syntax.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"","code":"mod_es <- c(\"y ~ m\" = \"l\",             \"m ~ x\" = \"m\",             \"y ~ x\" = \"nil\")  mod_es_yaml <- \" y ~ m: l m ~ x: m y ~ x: nil \"  pop_es_yaml(mod_es_yaml) #> y ~ m m ~ x y ~ x  #>   \"l\"   \"m\" \"nil\""},{"path":"https://sfcheung.github.io/power4mome/reference/power4mome-package.html","id":null,"dir":"Reference","previous_headings":"","what":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","title":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","text":"Power analysis sample size determination moderation, mediation, moderated mediation models fitted structural equation modelling using 'lavaan' package Rosseel (2012) doi:10.18637/jss.v048.i02  multiple regression. package 'manymome' Cheung Cheung (2024) doi:10.3758/s13428-023-02224-z  used specify indirect paths conditional indirect paths tested.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4mome-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","text":"Maintainer: Shu Fai Cheung shufai.cheung@gmail.com (ORCID) Authors: Sing-Hang Cheung (ORCID) Wendie Yang (ORCID)","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the Power of a Test — power4test","title":"Estimate the Power of a Test — power4test","text":"--one function receives model specification, generates datasets, fits model, target test, returns test results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the Power of a Test — power4test","text":"","code":"power4test(   object = NULL,   nrep = NULL,   ptable = NULL,   model = NULL,   pop_es = NULL,   standardized = TRUE,   n = NULL,   number_of_indicators = NULL,   reliability = NULL,   x_fun = list(),   e_fun = list(),   process_data = NULL,   fit_model_args = list(),   R = NULL,   ci_type = \"mc\",   gen_mc_args = list(),   gen_boot_args = list(),   test_fun = NULL,   test_args = list(),   map_names = c(fit = \"fit\"),   results_fun = NULL,   results_args = list(),   test_name = NULL,   test_note = NULL,   do_the_test = TRUE,   sim_all = NULL,   iseed = NULL,   parallel = FALSE,   progress = TRUE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5, si = 0.141, mi = 0.361, li = 0.51,     sm = 0.2, ml = 0.4),   es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15, sm = 0.075, ml = 0.125),   es_ind = c(\"si\", \"mi\", \"li\"),   n_std = 1e+05,   std_force_monte_carlo = FALSE )  # S3 method for class 'power4test' print(   x,   what = c(\"data\", \"test\"),   digits = 3,   digits_descriptive = 2,   data_long = FALSE,   test_long = FALSE,   fit_to_all_args = list(),   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the Power of a Test — power4test","text":"object Optional. set power4test object, updated using value(s) n, pop_es, /nrep changed, new test conducted added objet. See help page details. Default NULL. nrep number replications generate simulated datasets. Default NULL. Must set called create power4test object. ptable output ptable_pop(), ptable_pop object, representing population model. NULL, default, ptable_pop() called generate ptable_pop object using model pop_es. model lavaan model syntax population model, used ptable_pop(). See 'Details' specify model. Ignored ptable specified. pop_es character vector multiline string specify population effect sizes (population values parameters). See help page specify argument. Ignored ptable specified. standardized Logical. TRUE, default, variances error variances scaled ensure population variances endogenous variables close one, hence effect sizes (population values) standardized effect sizes variances continuous exogenous variables also equal one. n sample size dataset. Default 100. number_of_indicators named vector specify number indicators factors. See help page set argument. Default NULL variables model syntax observed variables. See help page use argument. reliability named vector (single-group model) named list named vectors (multigroup model) set reliability coefficient set indicators. Default NULL. See help page use argument. x_fun function(s) used generate exogenous variables error terms. supplied, set list(), default, variables generated multivariate normal distribution. See help page use argument. e_fun function(s) used generate error terms indicators, . supplied, set list(), default, error terms indicators generated multivariate normal distribution. Specify way x_fun. Refer help page x_fun use argument. process_data NULL, must named list elements: fun (required), function processing simulated data, generating missing data using functions mice::ampute(); args (optional), named list arguments passed fun, except one source data; sim_data_name (required) name argument receive simulated data (e.g., data mice::ampute()); processed_data_name (optional), name data frame processed fun, data frame missing data output fun (e.g., \"amp\" mice::ampute()), omitted, output fun data frame missing data. fit_model_args list arguments passed fit_model() fitting model. named list names names arguments. R number replications generate Monte Carlo bootstrapping estimates fit output. Monte Carlo bootstrapping estimates generated R set NULL. ci_type type simulation-based confidence intervals use. Can either \"mc\" Monte Carlo method (default) \"boot\" nonparametric bootstrapping method. Relevant test functions make use estimates generate gen_boot() gen_mc(), test_indirect_effect(). gen_mc_args list arguments passed manymome::do_mc() generating Monte Carlo estimates. named argument names names arguments. Used ci_type \"mc\". gen_boot_args list arguments passed manymome::do_boot() generating bootstrap estimates. named argument names names arguments. Used ci_type `\"boot\". test_fun function test. See 'Details' requirement function. built-test functions power4mome, described 'Details'. test_args list arguments passed test_fun function. Default list(). map_names named character vector specifying content element extra replication sim_all map argument test_fun. Default c(fit = \"fit\"), indicating element fit element extra set argument fit test_fun. , first replication, fit = sim_out[[1]]$extra$fit calling test_fun. results_fun function used extract test results. See Details requirements function. Default NULL, assuming output test_fun can used directly. results_args list arguments passed results_fun function. Default list(). test_name String. name test. Default NULL, name created test_fun. Note sim_out power4test object already test name stored, replaced new results. test_note String. optional note test, stored attribute test_note output do_test(). Default NULL. do_the_test TRUE, do_test() called test specified test_fun fit output dataset. sim_all set either sim_out object (output sim_out() power4test object (output power4test()), stored datasets fit outputs used test. Setting object output power4test() now preferred method, argument kept backward compatibility. iseed seed random number generator. Default NULL seed changed. seed set , calling sim_data(). parallel TRUE, parallel processing used calling functions, appropriate. Default FALSE. progress TRUE, progress step displayed. Default TRUE. ncores number CPU cores use parallel processing used. es1 Set values label effect size (population value) correlations regression paths. Used pop_es named vector multiline string. See help page specify argument. es2 Set values label effect size (population value) product term. Used pop_es named vector multiline string. See help page specify argument. es_ind names labels denoting effect size indirect effect. used determine population values component paths along indirect path. n_std sample size used determine error variances simulation std_force_monte_carlo TRUE. std_force_monte_carlo Logical. FALSE, default, standardization done analytically model product terms, simulation model product terms. , error variances required ensure implied variances equal one determined simulation. TRUE, simulation used whether model product terms . Always fall back simulation analytical standardization failed. x object printed. string vector print, \"data\" simulated data \"test\" stored test(s). Default c(\"data\", \"test\"). digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. data_long TRUE, detailed results printed printing simulated data. test_long TRUE, detailed results printed printing test(s). fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined samples stored. ... Optional arguments passed print methods","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the Power of a Test — power4test","text":"object class power4test, list two elements: sim_all: output sim_out(). test_all: named list output do_test(). names values test_name. list can one test call power4test() can add new tests power4test object. print method power4test returns x invisibly. Called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate the Power of a Test — power4test","text":"function power4test() --one function estimating power test model, given sample size effect sizes (population values model parameters).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"workflow","dir":"Reference","previous_headings":"","what":"Workflow","title":"Estimate the Power of a Test — power4test","text":"workflow: object output output previous call power4test() do_the_test set FALSE model simulated data, following steps skipped go directly test. Call sim_data() determine population model generate datasets, using arguments model pop_es. Call fit_model() fit model datasets, population model default. R NULL ci_type = \"mc\", call gen_mc() generate Monte Carlo estimates using manymome::do_mc(). estimates can used supported functions test_indirect_effect(). R NULL ci_type = \"boot\", call gen_boot() generate bootstrap estimates using manymome::do_boot(). estimates can used supported functions test_indirect_effect(). Merge results sim_out object calling sim_out(). do_the_test FALSE, skip remaining steps return power4test object, contains data generated optionally Monte Carlo bootstrap estimates. do_the_test TRUE, test. do_test() called test fit output dataset. Return power4test object include output sim_out , do_the_test TRUE, output do_test(). function used users interested power one several tests particular aspect model, parameter, given specific effect sizes sample sizes. Detailed description major arguments can found sections . NOTE: technical internal workflow power4test() can found page: https://sfcheung.github.io/power4mome/articles/power4test_workflow.html.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"updating-a-condition","dir":"Reference","previous_headings":"","what":"Updating a Condition","title":"Estimate the Power of a Test — power4test","text":"function power4test() can also used update condition selected aspects changed. example, instead calling function arguments set just change sample size, can called supplying existing power4test object set n new sample size. data tests updated automatically. See examples illustration.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"adding-another-test","dir":"Reference","previous_headings":"","what":"Adding Another Test","title":"Estimate the Power of a Test — power4test","text":"function power4test() can also used add test output previous call power4test(). example, simulating datasets one test, output can set object power4test(), set test_fun , optionally, test_fun_args one test generated datasets. output original object results new test added. See examples illustration.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"model-fitting-arguments-fit-model-args-","dir":"Reference","previous_headings":"","what":"Model Fitting Arguments ('fit_model_args')","title":"Estimate the Power of a Test — power4test","text":"power analysis, usually, population model (model) fitted, need set fit_model_args. power analysis conducted fitting model population model, non-default settings desired fitting model, argument fit_model_args needed set customize call fit_model(). example, users may want examine power test misspecified model fitted, power test MLR used estimator calling lavaan::sem(). See help page fit_model() examples.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Estimate the Power of a Test — power4test","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Estimate the Power of a Test — power4test","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Estimate the Power of a Test — power4test","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Estimate the Power of a Test — power4test","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Estimate the Power of a Test — power4test","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Estimate the Power of a Test — power4test","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"set-number-of-indicators-and-reliability-","dir":"Reference","previous_headings":"","what":"Set 'number_of_indicators' and 'reliability'","title":"Estimate the Power of a Test — power4test","text":"arguments number_of_indicators reliability used specify number indicators (e.g., items) factor, population reliability coefficient factor, variables model syntax latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-3","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"variable model replaced indicators generated data, set number_of_indicators named numeric vector. names variables variables indicators, appeared model syntax. value name number indicators. argument reliability set named numeric vector (list, see section multigroup models) specify population reliability coefficient (\"omega\") set indicators. population standardized factor loadings computed ensure population reliability coefficient target value. examples single group model: numbers indicators m, x, y 3, 4, 5, respectively. population reliability coefficients m, x, y .90, .80, .70, respectively.","code":"number of indicator = c(m = 3, x = 4, y = 5) reliability = c(m = .90, x = .80, y = .70)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-models","dir":"Reference","previous_headings":"","what":"Multigroup Models","title":"Estimate the Power of a Test — power4test","text":"Multigroup models supported. number groups inferred pop_es (see help page ptable_pop()), directly ptable. multigroup model, number indicators variable must across groups. However, population reliability coefficients can different across groups. multigroup model k groups, one population reliability coefficients differ across groups, argument reliability set named list. names variables population reliability coefficients set. element name either single value common reliability coefficient, numeric vector reliability coefficient group. example reliability model 2 groups: reliability coefficients x .80 groups, reliability coefficients m .70 one group .80 another.","code":"reliability = list(x = .80, m = c(.70, .80))"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"equal-numbers-of-indicators-and-or-reliability-coefficients","dir":"Reference","previous_headings":"","what":"Equal Numbers of Indicators and/or Reliability Coefficients","title":"Estimate the Power of a Test — power4test","text":"variables model number indicators, number_of_indicators can set one single value. Similarly, sets indicators population reliability groups, reliability can also set one single value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-the-distributions-of-exogenous-variables-or-error-terms-using-x-fun-","dir":"Reference","previous_headings":"","what":"Specify The Distributions of Exogenous Variables Or Error Terms Using 'x_fun'","title":"Estimate the Power of a Test — power4test","text":"default, variables error terms generated multivariate normal distribution. desired, users can supply function used generate exogenous variable error term setting x_fun named list. names list variables user function used generate data. element list must also list. first element list, can unnamed, function used. arguments need supplied, included named elements list. example: variables x w generated user-supplied functions. x, function power4mome::rexp_rs. additional argument calling function. w, function power4mome::rbinary_rx. argument p1 = .70 passed function generating values w. variable endogenous variable (e.g., predicted another variable model), x_fun used generate error term. implied population distribution may still different generate x_fun distribution also depends distribution variables predicting . requirements user-functions: must return numeric vector. mush argument n number values. population mean standard deviation generated values must 0 1, respectively. package power4mome helper functions generating values common nonnormal distributions scaling population mean standard deviation equal 0 1 (default), respectively. : rbinary_rs(). rexp_rs(). rbeta_rs(). rlnorm_rs(). rpgnorm_rs(). use x_fun, variables must zero covariances variables population. possible generate nonnormal multivariate data believe rarely needed estimating power data.","code":"x_fun = list(x = list(power4mome::rexp_rs),              w = list(power4mome::rbinary_rs,                       p1 = .70)))"},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-test-function-test-fun-","dir":"Reference","previous_headings":"","what":"The test function (test_fun)","title":"Estimate the Power of a Test — power4test","text":"function set test_fun, test function, usually work output lavaan::sem(), lmhelprs::many_lm(), stats::lm(), can also function works output function set fit_function calling fit_model() power4test() (see fit_model_args). function two default requirements. First, argument fit, set output lavaan::sem() another output stored element extra$fit replication sim_all object. (requirement can relaxed; see section map_names.) , function definition : FUN(fit, ...). form test_* functions power4mome. arguments passed test function, can set test_args named list. Second, test function must returns output () can processed results function (see ), (b) required format output results function (see next section). already returns output required format, need set results function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-results-function-results-fun-","dir":"Reference","previous_headings":"","what":"The results function (results_fun)","title":"Estimate the Power of a Test — power4test","text":"test results extracted output test_fun function set results_fun, results function. test_fun already returns output expected format (see ), set results_fun NULL, default. output test_fun used estimating power. function set results_fun must accept output test_fun, first argument, return named list (can data frame) named vector following elements: est: Optional. estimate parameter, applicable. se: Optional. standard error estimate, applicable. cilo: Optional. lower limit confidence interval, applicable. cihi: Optional. upper limit confidence interval, applicable. sig: Required. 1, test significant. 0, test significant. test done reason, NA. results can used estimate power Type error test. example, null hypothesis false, proportion significant, , mean values sig across replications, power.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"built-in-test-functions","dir":"Reference","previous_headings":"","what":"Built-in test functions","title":"Estimate the Power of a Test — power4test","text":"package power4mome ready--use test functions: test_indirect_effect() test_cond_indirect() test_cond_indirect_effects() test_moderation() test_index_of_mome() test_parameters() Please refer help pages examples.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-argument-map-names","dir":"Reference","previous_headings":"","what":"The argument map_names","title":"Estimate the Power of a Test — power4test","text":"argument developers using test function different name argument fit object (\"fit\", default). test_fun set function works output , say, lavaan::sem() argument name output fit, mapping can changed map_names. example, lavaan::parameterEstimates() receives output lavaan::sem() reports test results model parameters. However, argument name lavaan output object. instruct do_test() test correctly setting test_fun lavaan::parameterEstimates, add map_names = c(object = \"fit\"). element fit replication set argument object lavaan::parameterEstimates().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the Power of a Test — power4test","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Set nrep to a large number in real analysis, such as 400 # Set `parallel` to TRUE for faster, usually much faster, analysis # Set `progress` to TRUE to display the progress of the analysis  out <- power4test(nrep = 10,                   model = model_simple_med,                   pop_es = model_simple_med_es,                   n = 100,                   test_fun = test_parameters,                   test_args = list(pars = \"m~x\"),                   iseed = 1234,                   parallel = FALSE,                   progress = TRUE) #> Simulate the data: #> Fit the model(s): #> Do the test: test_parameters: CIs (pars: m~x)   print(out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  10  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.320 0.098 3.234  0.092 0.128 0.512 0.800 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 10  #> - Proportion of valid replications for rejection rate(s): 1.000   # Change the sample size  out1 <- power4test(out,                    n = 200,                    iseed = 1234,                    parallel = FALSE,                    progress = TRUE) #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) :  print(out1,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  10  #> Sample Sizes:  200  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           200 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.305 0.067 4.571  0.000 0.174 0.436 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 10  #> - Proportion of valid replications for rejection rate(s): 1.000   # Add one more test  out2 <- power4test(out,                    test_fun = test_parameters,                    test_args = list(pars = \"y~x\"),                    parallel = FALSE,                    progress = TRUE) #> Do the test: test_parameters: CIs (pars: y~x)   print(out2,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  10  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.320 0.098 3.234  0.092 0.128 0.512 0.800 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 10  #> - Proportion of valid replications for rejection rate(s): 1.000  #>  #> ========== <test_parameters: CIs (pars: y~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        y~x   y  ~   x -0.069 0.093 -0.729  0.389 -0.252 0.113 0.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 10  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":null,"dir":"Reference","previous_headings":"","what":"Power By Effect Sizes — power4test_by_es","title":"Power By Effect Sizes — power4test_by_es","text":"Estimate power set effect sizes (population values model parameter).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power By Effect Sizes — power4test_by_es","text":"","code":"power4test_by_es(   object,   pop_es_name = NULL,   pop_es_values = NULL,   progress = TRUE,   ...,   by_seed = NULL,   by_nrep = NULL,   save_sim_all = TRUE )  # S3 method for class 'power4test_by_es' c(..., sort = TRUE, skip_checking_models = FALSE)  as.power4test_by_es(original_object, pop_es_name)  # S3 method for class 'power4test_by_es' print(x, print_all = FALSE, digits = 3, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power By Effect Sizes — power4test_by_es","text":"object power4test object, power4test_by_es object. power4test_by_es object, first element, power4test object, used value argument. pop_es_name name parameter. See help page ptable_pop() names argument pop_es. pop_es_values numeric vector population values parameter specified pop_es_names. progress Logical. Whether progress simulation displayed. ... power4test_by_es(), arguments passed power4test(). c.power4test_by_es(), power4test_by_es() outputs combined together. print method output power4test_by_es(), arguments passed print method output power4test() (print.power4test()). by_seed set number, used generate seeds call power4test(). NULL, default, seeds still randomly generated results easily reproduced. by_nrep set number, used generate number replications (nrep) call power4test(). set numeric vector length pop_es_values, nrep values calls, allowing different numbers replications population values. NULL, default, original nrep used. argument used x_from_power() efficiency, rarely used calling function directly. save_sim_all FALSE, dataset power4test objects saved, reduce size output. Default TRUE. sort combining objects, whether sorted population values. Default TRUE. skip_checking_models Whether check data generation model checked. Default TRUE. set FALSE users certain based model, model saved (e.g., save_sim_all set FALSE objects generated). argument used x_from_power() efficiency, rarely used calling c method directly. original_object object converted power4test_by_es object. x object printed. print_all TRUE, elements x, , results sample sizes examined, printed. FALSE, first value parameter printed. digits numbers digits displayed decimal.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power By Effect Sizes — power4test_by_es","text":"function power4test_by_es() returns power4test_by_es object, list power4test objects, one population value parameter. method c.power4test_by_es() returns power4test_by_es object elements (tests different values pop_es_values) combined. function .power4test_by_es() returns power4test_by_es object converted input object. print-method power4test_by_es objects returns object invisibly. called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power By Effect Sizes — power4test_by_es","text":"function power4test_by_es() regenerates datasets set effect sizes (population values model parmeter) stored tests . Optionally, can also run object stored tests. case, additional arguments must set instruct power4test() tests conducted. usually used examine power sets effect sizes (population values). c method power4test_by_es objects used combine tests different runs power4test_by_es(). function .power4test_by_es() used convert power4test object power4test_by_es object, already one. Useful concatenating power4test objects power4test_by_es objects.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power By Effect Sizes — power4test_by_es","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  sim_only <- power4test(nrep = 2,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 40,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Do the test: test_indirect: x->m->y   out <- power4test_by_es(test_out,                             pop_es_name = \"y ~ m\",                             pop_es_values = c(.10, .20)) #>  #> Updating the simulation for new value: y ~ m = 0.100  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for new value: y ~ m = 0.200  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : out_reject <- rejection_rates(out) out_reject #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     par    es   est   p.v reject r.cilo r.cihi #> 1 y ~ m 0.100 0.043 1.000  0.000 -0.000  0.658 #> 2 y ~ m 0.200 0.038 1.000  0.500  0.095  0.905 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Power By Sample Sizes — power4test_by_n","title":"Power By Sample Sizes — power4test_by_n","text":"Estimate power set sample sizes.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power By Sample Sizes — power4test_by_n","text":"","code":"power4test_by_n(   object,   n = NULL,   progress = TRUE,   ...,   by_seed = NULL,   by_nrep = NULL,   save_sim_all = TRUE )  # S3 method for class 'power4test_by_n' c(   ...,   sort = TRUE,   skip_checking_models = FALSE,   tolerance_if_std_by_monte_carlo =     getOption(\"power4mome.tolerance_if_std_by_monte_carlo\", default = 0.01) )  as.power4test_by_n(original_object)  # S3 method for class 'power4test_by_n' print(x, print_all = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power By Sample Sizes — power4test_by_n","text":"object power4test object, power4test_by_n object. power4test_by_n object, first element, power4test object, used value argument. n numeric vector sample sizes simulation conducted. progress Logical. Whether progress simulation displayed. ... power4test_by_n(), arguments passed power4test(). c.power4test_by_n(), power4test_by_n() outputs combined together. print method output power4test_by_n(), arguments passed print method output power4test() (print.power4test()). by_seed set number, used generate seeds call power4test(). NULL, default, seeds still randomly generated results easily reproduced. by_nrep set number, used generate number replications (nrep) call power4test(). set numeric vector length n, nrep values calls, allowing different numbers replications sample sizes. NULL, default, original nrep used. argument used x_from_power() efficiency, rarely used calling function directly. save_sim_all FALSE, dataset power4test objects saved, reduce size output. Default TRUE. sort combining objects, whether sorted sample sizes. Default TRUE. skip_checking_models Whether check data generation model checked. Default TRUE. set FALSE users certain based model, model saved (e.g., save_sim_all set FALSE objects generated). argument used x_from_power() efficiency, rarely used calling c method directly. tolerance_if_std_by_monte_carlo tolerance used .equal() checking population values. standardization conducted using error variances estimated Monte Carlo simulation, may exactly across replications. tolerance used compare population values, allow minor variation due simulation. original_object object converted power4test_by_n object. x object printed. print_all TRUE, elements x, , results sample sizes examined, printed. FALSE, first sample size printed.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power By Sample Sizes — power4test_by_n","text":"function power4test_by_n() returns power4test_by_n object, list power4test objects, one sample size. method c.power4test_by_n() returns power4test_by_n object elements (tests different sample sizes) combined. function .power4test_by_n() returns power4test_by_n object converted input object. print-method power4test_by_n objects returns object invisibly. called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power By Sample Sizes — power4test_by_n","text":"function power4test_by_n() regenerates datasets set sample sizes stored tests . Optionally, can also run object stored tests. case, additional arguments must set instruct power4test() tests conducted. usually used examine power set sample sizes. c method power4test_by_n objects used combine tests different runs power4test_by_n(). function .power4test_by_n() used convert power4test object power4test_by_n object, already one. Useful concatenating power4test objects power4test_by_n objects.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power By Sample Sizes — power4test_by_n","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  sim_only <- power4test(nrep = 2,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 40,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Do the test: test_indirect: x->m->y   out <- power4test_by_n(test_out,                        n = c(100, 110, 120)) #>  #> Updating the simulation for sample size: 100  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for sample size: 110  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for sample size: 120  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : out_reject <- rejection_rates(out) out_reject #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.132 1.000  0.500  0.095  0.905 #> 2 110 0.166 1.000  1.000  0.342  1.000 #> 3 120 0.162 1.000  1.000  0.342  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Power Curve — power_curve","title":"Power Curve — power_curve","text":"Estimate relation power characteristic, sample size population effect size (population value model parameter).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power Curve — power_curve","text":"","code":"power_curve(   object,   formula = NULL,   start = NULL,   lower_bound = NULL,   upper_bound = NULL,   nls_args = list(),   nls_control = list(),   verbose = FALSE,   models = c(\"nls\", \"logistic\", \"lm\") )  # S3 method for class 'power_curve' print(x, data_used = FALSE, digits = 3, right = FALSE, row.names = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power Curve — power_curve","text":"object object class power4test_by_n power4test_by_es, output power4test_by_n() power4test_by_es(). formula formula model stats::nls(). can also list formulas, models fitted successively stats::nls(), first model fitted successfully adopted. response variable formula must named reject, predictor named x. Whether x represents n es depends class object. NULL, default, determined internally based type object. start Either named vector start value(s) parameter(s) formula, list named vectors starting value(s) list formula(s). NULL, default, determined internally. lower_bound Either named vector lower bound(s) parameter(s) formula, list named vectors lower bound(s) list formula(s). passed lower stats::nls(). NULL, default, determined internally based type object. upper_bound Either named vector upper bound(s) parameter(s) formula, list named vectors upper bound(s) list formula(s). passed upper stats::nls(). NULL, default, determined internally based type object. nls_args named list arguments used calling stats::nls(). Used override internal default, algorithm (default \"port\"). Use argument cautions. nls_control named list arguments passed control argument stats::nls(). values override internal default values, also override nls_args. Use argument cautions. verbose Logical. Whether messages printed trying different models. models Models try. Support \"nls\" (fitted nls()), \"logistic\" (fitted glm()), \"lm\" (fitted lm()). default, three models attempted, order. x power_curve object. data_used Logical. Whether rejection rates data frame used fit model printed. digits, right, row.names Arguments names used print method data.frame object. Used data_used TRUE rejection rates data frame printed. ... print method power_curve objects, optional arguments passed print.data.frame() printing rejection rates data frame.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power Curve — power_curve","text":"returns list power_curve object, following elements: fit: model fitted, output stats::nls(), stats::glm(), stats::lm(). reject_df: table reject rates characteristics, generated rejection_rates(). predictor: predictor power curve, ether \"n\" (sample size) \"es\" (population effect size). call: call used run function. print method power_curve object returns x invisibly. Called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power Curve — power_curve","text":"function power_curve() retrieves information output power4test_by_n() power4test_by_es(), estimate power curve: relation characteristic varied, sample size power4test_by_n() population effect size power4test_by_es(), rejection rate test conducted power4test_by_n() power4test_by_es(). rejection rate power null hypothesis false (e.g., population value effect size tested nonzero). model fitted intended precise model relation across wide range. crude estimate based limited number values characteristic (e.g., sample size) examined, can small four even smaller. model intended used range covered, estimating probable sample size effect size desirable level power. value studied higher precision simulation using functions power4test(). models tried, following order: One nonlinear models, fitted stats::nls(). several models specified, fitted one smallest deviance used. nonlinear models failed, whatever reason, logistic regression fitted stats::glm() predict binary significant test results. logistic model also failed, whatever reason, simple linear regression model fitted. Although power curve nonlinear across wide range , say, sample size, linear model can still good enough approximation narrow range predictor. output can plotted visualize power curve, using plot method (plot.power_curve()) output power_curve(). function can used directly, also used internally functions x_from_power().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power Curve — power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model # Set `parallel` to TRUE for faster, usually much faster, analysis # Set `progress` to TRUE to display the progress of the analysis  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 50, 100),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -4.28606      0.02986   #>  #> Degrees of Freedom: 29 Total (i.e. Null);  28 Residual #> Null Deviance:\t    19.5  #> Residual Deviance: 17.37 \tAIC: 21.37 plot(pout1)   # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                          nrep = 10,                          test_fun = test_parameters,                          test_args = list(par = \"y~x\"),                          pop_es_name = \"y ~ x\",                          pop_es_values = c(0, .3, .5),                          by_seed = 1234,                          parallel = FALSE,                          progress = FALSE)  pout2 <- power_curve(out2) pout2 #> Call: #> power_curve(object = out2) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      -27.13        93.25   #>  #> Degrees of Freedom: 29 Total (i.e. Null);  28 Residual #> Null Deviance:\t    41.05  #> Residual Deviance: 12.22 \tAIC: 16.22 plot(pout2)"},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for a 'power_curve' Object — predict.power_curve","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"Compute predicted values model fitted power_curve().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"","code":"# S3 method for class 'power_curve' predict(object, newdata, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"object power_curve object. newdata data frame column named x. can also named list, one element named x vector values. supplied, values x stored object used. ... Additional arguments. Passed corresponding predict method.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"returns numeric vector predicted rejection rates.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"predict method power_curve objects works two modes. new data supplied (newdata), retrieves stored results calls corresponding methods compute predicted values, predicted rejection rates (power levels null hypothesis false, e.g., population effect size equal zero). new data supplied, named list vector sample sizes, used compute predicted rejection rates.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model # Set `parallel` to TRUE for faster, usually much faster, analysis # Set `progress` to TRUE to display the progress of the analysis  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 100, 200, 1000),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ 1 - I(exp((a - x)/b)) #>    data: \"(Omitted)\" #>     a     b  #>  19.1 260.3  #>  residual sum-of-squares: 0.07498 #>  #> Algorithm \"port\", convergence message: relative convergence (4) predict(pout1,         newdata = list(x = c(150, 250, 500))) #> [1] 0.3951796 0.5880944 0.8423384  # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = seq(0, .7, .15),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) pout2 #> Call: #> power_curve(object = out2) #>  #> Predictor: es (Effect Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ 1 - 2/(exp(x/d) + exp(-x/d)) #>    data: \"(Omitted)\" #>     d  #> -0.13  #>  residual sum-of-squares: 0.05021 #>  #> Algorithm \"port\", convergence message: relative convergence (4) predict(pout2,         newdata = list(x = c(.25, .55))) #> [1] 0.7136569 0.9708902"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the Population Model — ptable_pop","title":"Generate the Population Model — ptable_pop","text":"Generate complete population model using model syntax user-specified effect sizes (population parameter values).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the Population Model — ptable_pop","text":"","code":"ptable_pop(   model = NULL,   pop_es = NULL,   es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5, si = 0.141, mi = 0.361, li = 0.51,     sm = 0.2, ml = 0.4),   es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15, sm = 0.075, ml = 0.125),   es_ind = c(\"si\", \"mi\", \"li\"),   standardized = TRUE,   n_std = 1e+05,   std_force_monte_carlo = FALSE,   add_cov_for_moderation = TRUE )  model_matrices_pop(x, ..., drop_list_single_group = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the Population Model — ptable_pop","text":"model String. model defined lavaan model syntax. See 'Details'. pop_es can data frame columns: lhs, op, rhs, pop. first three columns correspond lavaan parameter table. column pop stores population values. column es stores original labels, reference. can also named character vector (named list multigroup models) multiline string, preferred approaches. See help page specify vector. es1 Set values label effect size (population value) correlations regression paths. Used pop_es named vector multiline string. See help page specify argument. es2 Set values label effect size (population value) product term. Used pop_es named vector multiline string. See help page specify argument. es_ind names labels denoting effect size indirect effect. used determine population values component paths along indirect path. standardized Logical. TRUE, default, variances error variances scaled ensure population variances endogenous variables close one, hence effect sizes (population values) standardized effect sizes variances continuous exogenous variables also equal one. n_std sample size used determine error variances simulation std_force_monte_carlo TRUE. std_force_monte_carlo Logical. FALSE, default, standardization done analytically model product terms, simulation model product terms. , error variances required ensure implied variances equal one determined simulation. TRUE, simulation used whether model product terms . Always fall back simulation analytical standardization failed. add_cov_for_moderation Logical. TRUE, default, model one product terms moderation involve one mediator, covariances error terms product terms added automatically. covariances added, model may invariant linear transformation variables model. x can 'lavaan' model syntax, passed ptable_pop(), parameter table column start set population values, output ptable_pop(). ... x model syntax, arguments passed ptable_pop(). drop_list_single_group TRUE number groups equal one, output list matrices one group . Default TRUE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() returns lavaan parameter table model, column start set population values. function model_matrices_pop() returns lavaan LISREL-style model matrices (like output lavaan::lavInspect() set \"free\"), matrix elements set population values. x model syntax, stored attributes model. model multigroup model k groups (k greater 1), returns list k lists lavaan LISREL-style model matrices unless drop_list_single_group TRUE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() generates lavaan parameter table can used generate data based population values model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"the-role-of-ptable-pop-","dir":"Reference","previous_headings":"","what":"The role of ptable_pop()","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Generate the Population Model — ptable_pop","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Generate the Population Model — ptable_pop","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Generate the Population Model — ptable_pop","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Generate the Population Model — ptable_pop","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Generate the Population Model — ptable_pop","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Generate the Population Model — ptable_pop","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"the-role-of-model-matrices-pop-","dir":"Reference","previous_headings":"","what":"The role of model_matrices_pop()","title":"Generate the Population Model — ptable_pop","text":"function model_matrices_pop() generates models matrices population values, used ptable_pop(). Users usually call function directly, though developers can use build workflows generate data.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate the Population Model — ptable_pop","text":"","code":"# Specify the model  model1 <- \" m1 ~ x + c1 m2 ~ m1 + x2 + c1 y ~  m2 + m1 + x + w + x:w + c1 \"  # Specify the population values  model1_es <- c(\"m1 ~ x\" = \"-m\",                \"m2 ~ m1\" = \"s\",                \"y ~ m2\" = \"l\",                \"y ~ x\" = \"m\",                \"y ~ w\" = \"s\",                \"y ~ x:w\" = \"s\",                \"x ~~ w\" = \"s\")  ptable_final1 <- ptable_pop(model1,                             pop_es = model1_es) ptable_final1 #>    id lhs op rhs group user block free ustart exo label plabel      start est #> 1   1  m1  ~   x     1    1     1    1     NA   0         .p1. -0.3000000   0 #> 2   2  m1  ~  c1     1    1     1    2     NA   0         .p2.  0.0000000   0 #> 3   3  m2  ~  m1     1    1     1    3     NA   0         .p3.  0.1000000   0 #> 4   4  m2  ~  x2     1    1     1    4     NA   0         .p4.  0.0000000   0 #> 5   5  m2  ~  c1     1    1     1    5     NA   0         .p5.  0.0000000   0 #> 6   6   y  ~  m2     1    1     1    6     NA   0         .p6.  0.5000000   0 #> 7   7   y  ~  m1     1    1     1    7     NA   0         .p7.  0.0000000   0 #> 8   8   y  ~   x     1    1     1    8     NA   0         .p8.  0.3000000   0 #> 9   9   y  ~   w     1    1     1    9     NA   0         .p9.  0.1000000   0 #> 10 10   y  ~ x:w     1    1     1   10     NA   0        .p10.  0.0500000   0 #> 11 11   y  ~  c1     1    1     1   11     NA   0        .p11.  0.0000000   0 #> 12 12  m1 ~~  m1     1    0     1   12     NA   0        .p12.  0.9102952   1 #> 13 13  m2 ~~  m2     1    0     1   13     NA   0        .p13.  0.9899976   1 #> 14 14   y ~~   y     1    0     1   14     NA   0        .p14.  0.6509433   1 #> 15 15   x ~~   x     1    0     1   15     NA   0        .p15.  1.0000000   1 #> 16 16   x ~~  c1     1    0     1   16     NA   0        .p16.  0.0000000   0 #> 17 17   x ~~  x2     1    0     1   17     NA   0        .p17.  0.0000000   0 #> 18 18   x ~~   w     1    0     1   18     NA   0        .p18.  0.1000000   0 #> 19 19   x ~~ x:w     1    0     1   19     NA   0        .p19.  0.0000000   0 #> 20 20  c1 ~~  c1     1    0     1   20     NA   0        .p20.  1.0000000   1 #> 21 21  c1 ~~  x2     1    0     1   21     NA   0        .p21.  0.0000000   0 #> 22 22  c1 ~~   w     1    0     1   22     NA   0        .p22.  0.0000000   0 #> 23 23  c1 ~~ x:w     1    0     1   23     NA   0        .p23.  0.0000000   0 #> 24 24  x2 ~~  x2     1    0     1   24     NA   0        .p24.  1.0000000   1 #> 25 25  x2 ~~   w     1    0     1   25     NA   0        .p25.  0.0000000   0 #> 26 26  x2 ~~ x:w     1    0     1   26     NA   0        .p26.  0.0000000   0 #> 27 27   w ~~   w     1    0     1   27     NA   0        .p27.  1.0000000   1 #> 28 28   w ~~ x:w     1    0     1   28     NA   0        .p28.  0.0000000   0 #> 29 29 x:w ~~ x:w     1    0     1   29     NA   0        .p29.  1.0000000   1  # Use a multiline string, illustrated by a simpler model  model2 <- \" m ~ x y ~ m + x \"  model2_es_a <- c(\"m ~ x\" = \"s\",                  \"y ~ m\" = \"m\",                  \"y ~ x\" = \"nil\")  model2_es_b <- \" m ~ x: s y ~ m: m y ~ x: nil \"  ptable_model2_a <- ptable_pop(model2,                               pop_es = model2_es_a) ptable_model2_b <- ptable_pop(model2,                               pop_es = model2_es_b)  ptable_model2_a #>   id lhs op rhs group user block free ustart exo label plabel start est #> 1  1   m  ~   x     1    1     1    1     NA   0         .p1.  0.10   0 #> 2  2   y  ~   m     1    1     1    2     NA   0         .p2.  0.30   0 #> 3  3   y  ~   x     1    1     1    3     NA   0         .p3.  0.00   0 #> 4  4   m ~~   m     1    0     1    4     NA   0         .p4.  0.99   1 #> 5  5   y ~~   y     1    0     1    5     NA   0         .p5.  0.91   1 #> 6  6   x ~~   x     1    0     1    6     NA   0         .p6.  1.00   1 ptable_model2_b #>   id lhs op rhs group user block free ustart exo label plabel start est #> 1  1   m  ~   x     1    1     1    1     NA   0         .p1.  0.10   0 #> 2  2   y  ~   m     1    1     1    2     NA   0         .p2.  0.30   0 #> 3  3   y  ~   x     1    1     1    3     NA   0         .p3.  0.00   0 #> 4  4   m ~~   m     1    0     1    4     NA   0         .p4.  0.99   1 #> 5  5   y ~~   y     1    0     1    5     NA   0         .p5.  0.91   1 #> 6  6   x ~~   x     1    0     1    6     NA   0         .p6.  1.00   1  identical(ptable_model2_a,           ptable_model2_b) #> [1] TRUE  # model_matrices_pop  model_matrices_pop(ptable_final1) #> $lambda #>     m1 m2 y x c1 x2 w x:w #> m1   0  0 0 0  0  0 0   0 #> m2   0  0 0 0  0  0 0   0 #> y    0  0 0 0  0  0 0   0 #> x    0  0 0 0  0  0 0   0 #> c1   0  0 0 0  0  0 0   0 #> x2   0  0 0 0  0  0 0   0 #> w    0  0 0 0  0  0 0   0 #> x:w  0  0 0 0  0  0 0   0 #>  #> $theta #>     m1 m2 y x c1 x2 w x:w #> m1   0                    #> m2   0  0                 #> y    0  0 0               #> x    0  0 0 0             #> c1   0  0 0 0  0          #> x2   0  0 0 0  0  0       #> w    0  0 0 0  0  0 0     #> x:w  0  0 0 0  0  0 0   0 #>  #> $psi #>        m1    m2     y     x    c1    x2     w   x:w #> m1  0.910                                           #> m2  0.000 0.990                                     #> y   0.000 0.000 0.651                               #> x   0.000 0.000 0.000 1.000                         #> c1  0.000 0.000 0.000 0.000 1.000                   #> x2  0.000 0.000 0.000 0.000 0.000 1.000             #> w   0.000 0.000 0.000 0.100 0.000 0.000 1.000       #> x:w 0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000 #>  #> $beta #>      m1  m2 y    x c1 x2   w  x:w #> m1  0.0 0.0 0 -0.3  0  0 0.0 0.00 #> m2  0.1 0.0 0  0.0  0  0 0.0 0.00 #> y   0.0 0.5 0  0.3  0  0 0.1 0.05 #> x   0.0 0.0 0  0.0  0  0 0.0 0.00 #> c1  0.0 0.0 0  0.0  0  0 0.0 0.00 #> x2  0.0 0.0 0  0.0  0  0 0.0 0.00 #> w   0.0 0.0 0  0.0  0  0 0.0 0.00 #> x:w 0.0 0.0 0  0.0  0  0 0.0 0.00 #>  #> attr(,\"model\") #> [1] \"\\nm1 ~ x + c1\\nm2 ~ m1 + x2 + c1\\ny ~  m2 + m1 + x + w + x:w + c1\\n\"  model_matrices_pop(model1,                    pop_es = model1_es) #> $lambda #>     m1 m2 y x c1 x2 w x:w #> m1   0  0 0 0  0  0 0   0 #> m2   0  0 0 0  0  0 0   0 #> y    0  0 0 0  0  0 0   0 #> x    0  0 0 0  0  0 0   0 #> c1   0  0 0 0  0  0 0   0 #> x2   0  0 0 0  0  0 0   0 #> w    0  0 0 0  0  0 0   0 #> x:w  0  0 0 0  0  0 0   0 #>  #> $theta #>     m1 m2 y x c1 x2 w x:w #> m1   0                    #> m2   0  0                 #> y    0  0 0               #> x    0  0 0 0             #> c1   0  0 0 0  0          #> x2   0  0 0 0  0  0       #> w    0  0 0 0  0  0 0     #> x:w  0  0 0 0  0  0 0   0 #>  #> $psi #>       m1   m2    y    x   c1   x2    w  x:w #> m1  0.91                                    #> m2  0.00 0.99                               #> y   0.00 0.00 0.65                          #> x   0.00 0.00 0.00 1.00                     #> c1  0.00 0.00 0.00 0.00 1.00                #> x2  0.00 0.00 0.00 0.00 0.00 1.00           #> w   0.00 0.00 0.00 0.10 0.00 0.00 1.00      #> x:w 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1.00 #>  #> $beta #>      m1  m2 y    x c1 x2   w  x:w #> m1  0.0 0.0 0 -0.3  0  0 0.0 0.00 #> m2  0.1 0.0 0  0.0  0  0 0.0 0.00 #> y   0.0 0.5 0  0.3  0  0 0.1 0.05 #> x   0.0 0.0 0  0.0  0  0 0.0 0.00 #> c1  0.0 0.0 0  0.0  0  0 0.0 0.00 #> x2  0.0 0.0 0  0.0  0  0 0.0 0.00 #> w   0.0 0.0 0  0.0  0  0 0.0 0.00 #> x:w 0.0 0.0 0  0.0  0  0 0.0 0.00 #>  #> attr(,\"model\") #> [1] \"\\nm1 ~ x + c1\\nm2 ~ m1 + x2 + c1\\ny ~  m2 + m1 + x + w + x:w + c1\\n\""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":null,"dir":"Reference","previous_headings":"","what":"All-in-One Power Estimation For Mediation Models — q_power_mediation","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"--one functions estimating power finding region target power common mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"","code":"q_power_mediation(   model = NULL,   pop_es = NULL,   number_of_indicators = NULL,   reliability = NULL,   test_fun = NULL,   test_more_args = list(),   target_power = 0.8,   nrep = 400,   n = 100,   R = 1000,   ci_type = c(\"mc\", \"boot\"),   seed = NULL,   iseed = NULL,   parallel = TRUE,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   ...,   mode = c(\"power\", \"region\") )  # S3 method for class 'q_power_mediation' print(x, mode = c(\"all\", \"region\", \"power\"), ...)  # S3 method for class 'q_power_mediation' plot(x, ...)  # S3 method for class 'q_power_mediation' summary(object, ...)  q_power_mediation_simple(   a = \"m\",   b = \"m\",   cp = \"n\",   number_of_indicators = NULL,   reliability = NULL,   test_more_args = list(),   target_power = 0.8,   nrep = 400,   n = 100,   R = 1000,   ci_type = c(\"mc\", \"boot\"),   seed = NULL,   iseed = NULL,   parallel = TRUE,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   ...,   mode = c(\"power\", \"region\") )  q_power_mediation_serial(   ab = c(\"m\", \"m\"),   ab_other = \"n\",   cp = \"n\",   number_of_indicators = NULL,   reliability = NULL,   test_more_args = list(),   target_power = 0.8,   nrep = 400,   n = 100,   R = 1000,   ci_type = c(\"mc\", \"boot\"),   seed = NULL,   iseed = NULL,   parallel = TRUE,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   ...,   mode = c(\"power\", \"region\") )  q_power_mediation_parallel(   as = c(\"m\", \"m\"),   bs = c(\"m\", \"m\"),   cp = \"n\",   number_of_indicators = NULL,   reliability = NULL,   omnibus = c(\"all_sig\", \"at_least_one_sig\", \"at_least_k_sig\"),   at_least_k = 1,   test_more_args = list(),   target_power = 0.8,   nrep = 400,   n = 100,   R = 1000,   ci_type = c(\"mc\", \"boot\"),   seed = NULL,   iseed = NULL,   parallel = TRUE,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   ...,   mode = c(\"power\", \"region\") )"},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"model lavaan model syntax population model, used ptable_pop(). See 'Details' specify model. Ignored ptable specified. pop_es character vector multiline string specify population effect sizes (population values parameters). See help page specify argument. Ignored ptable specified. number_of_indicators named vector specify number indicators factors. See help page set argument. Default NULL variables model syntax observed variables. See help page use argument. reliability named vector (single-group model) named list named vectors (multigroup model) set reliability coefficient set indicators. Default NULL. See help page use argument. test_fun function test. See 'Details' power4test() requirement function. test_more_args named list additional arguments passed test function (test_indirect_effect() simple serial mediation models, test_k_indirect_effects() parallel mediation models). Similar test_args power4test(). target_power target power, value greater 0 less one. nrep number replications generate simulated datasets. Default NULL. Must set called create power4test object. n sample size dataset. Default 100. R number replications generate Monte Carlo bootstrapping estimates fit output. Monte Carlo bootstrapping estimates generated R set NULL. ci_type type simulation-based confidence intervals use. Can either \"mc\" Monte Carlo method (default) \"boot\" nonparametric bootstrapping method. Relevant test functions make use estimates generate gen_boot() gen_mc(), test_indirect_effect(). seed seed random number generator. Used n_region_from_power(). iseed seed random number generator. Used power4test(). parallel TRUE, parallel processing used calling functions, appropriate. progress TRUE, progress step displayed. Default TRUE. simulation_progress Logical. Whether progress call power4test(), power4test_by_n(), power4test_by_es() shown. passed progress argument functions. max_trials maximum number trials searching value target power. Rounded integer. ... q_power_mediation_*, optional arguments passed power4test() n_region_from_power(). print method, optional arguments passed print methods (see print.power4test() print.n_region_from_power()). plot method, optional arguments passed plot.n_region_from_power(). summary method, optional arguments passed summary.n_region_from_power(). mode print. \"region\" output n_region_from_power() available, print results n_region_from_power(). \"power\", output power4test() printed. \"\", available output printed. x object relevant methods. object summary method q_power_mediation() outputs. simple mediation model, population effect size path x m . b simple mediation model, population effect size path m y . cp simple mediation model, population effect size direct path c y . ab serial mediation model, numeric vector population effect sizes along path x->m1->m2->...->y. ab_other one single value. population effect sizes paths along x->m1->m2->...->y, except direct path x y. parallel mediation model, numeric vector population effect sizes paths x mediators: x->m1, x->m2, ... x->mp, parallel mediation model p mediators. bs parallel mediation model, numeric vector population effect sizes paths mediators y: m1->y, m2->y, ... mp->y, parallel mediation model p mediators. omnibus \"all_sig\", default, test declared significant paths significant. \"at_least_one_sig\", one row test stored, test declared significant least one paths significant. \"at_least_k_sig\", one row test stored, test declared significant least k paths significant, k determined argument at_least_k. at_least_k minimum number paths required significant omnibus test considered significant. Used omnibus \"at_least_k_sig\".","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"mode power, power4test object returned. mode region, n_region_from_power object returned. print method q_power_mediation returns x invisibly. Called side effect. plot-method q_power_mediation returns x invisibly. called side effect. summary method q_power_mediation objects returns output summary.n_region_from_power(). error raised output n_region_from_power() available.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"all-in-one-functions-for-common-mediation-models","dir":"Reference","previous_headings":"","what":"All-in-One Functions for Common Mediation Models","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"functions wrappers call power4test() n_region_from_power() () estimate level power mediation model, given population effects sample size, (b) find region sample sizes levels power significantly different target power. convenient functions set argument values automatically common mediation models calling power4test() n_region_from_power(). Please refer help pages two functions details estimation search conducted. arguments described details , please refer help pages power4test() n_region_from_power(),","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"simple-mediation-model","dir":"Reference","previous_headings":"","what":"Simple Mediation Model","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"function q_power_mediation_simple() can used power analysis simple mediation model one mediator. function fit following model:","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"serial-mediation-model","dir":"Reference","previous_headings":"","what":"Serial Mediation Model","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"function q_power_mediation_serial() can used power analysis serial mediation model number mediators. model fitted model two mediators:","code":"\"m1 ~ x  m2 ~ m1 + x  y ~ m2 + m1 + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"parallel-mediation-model","dir":"Reference","previous_headings":"","what":"Parallel Mediation Model","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"function q_power_mediation_parallel() can used power analysis parallel mediation model number mediators. model fitted model two mediators:","code":"\"m1 ~ x  m2 ~ x  y ~ m2 + m1 + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"an-arbitrary-mediation-model","dir":"Reference","previous_headings":"","what":"An Arbitrary Mediation Model","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"function q_power_mediation(), advanced function, can used power analysis arbitrary mediation model. model population effect sizes specified power4test(). example model parallel paths serial paths: Knowledge using power4test() required use advanced function. advanced function used, users need specify test_fun using power4test(), need set test_args correctly","code":"model <-  \"  m1 ~ x  m21 ~ m1  m22 ~ m1  y ~ m21 + m22 + x  \" pop_es <- \" m1 ~ x: m m21 ~ m1: m m22 ~ m1: m y ~ m21: m y ~ m22: m \""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/q_power_mediation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"All-in-One Power Estimation For Mediation Models — q_power_mediation","text":"","code":"if (FALSE) { # \\dontrun{  # An arbitrary mediation model  model <- \" m1 ~ x m21 ~ m1 m22 ~ m1 y ~ m21 + m22 \" pop_es <- \" m1 ~ x: m m21 ~ m1: m m22 ~ m1: m y ~ m21: m y ~ m22: m \"  # NOTE: In real power analysis: # - Set R to an appropriate value. # - Remove nrep or set nrep to the desired value. # - Remove parallel or set it to TRUE to enable parallel processing. # - Remove progress or set it to TRUE to see the progress.  outa1 <- q_power_mediation(     model = model,     pop_es = pop_es,     n = 100,     R = 199,     test_fun = test_k_indirect_effects,     test_more_args = list(x = \"x\",                           y = \"y\",                           omnibus = \"all\"),     seed = 1234,     mode = \"region\",     nrep = 20,     parallel = FALSE,     progress = FALSE   ) outa1 summary(outa1) plot(outa1)  } # }   # Simple mediation model  # NOTE: In real power analysis: # - Set R to an appropriate value. # - Remove nrep or set nrep to the desired value. # - Remove parallel or set it to TRUE to enable parallel processing. # - Remove progress or set it to TRUE to see the progress.  out <- q_power_mediation_simple(     a = \"m\",     b = \"m\",     cp = \"n\",     n = 50,     R = 199,     seed = 1234,     nrep = 20,     parallel = FALSE,     progress = FALSE   ) out #>  #> ========== power4test Results ========== #>  #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.910   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.090 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  20  #> Sample Sizes:  50  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 199  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. #>  #> ========== power4test Power ========== #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.071 1.000  0.250  0.112  0.469 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> ========== n_region_from_power Results ========== #>  #>  #> 'mode' is not 'region' and results not available. #>   # If mode = \"region\" is added, can call the following # summary(out) # plot(out)   if (FALSE) { # \\dontrun{ # Serial mediation model  # NOTE: In real power analysis: # - Set R to an appropriate value. # - Remove nrep or set nrep to the desired value. # - Remove parallel or set it to TRUE to enable parallel processing. # - Remove progress or set it to TRUE to see the progress.  outs <- q_power_mediation_serial(     ab = c(\"s\", \"m\", \"l\"),     ab_others = \"n\",     cp = \"s\",     n = 50,     R = 199,     seed = 1234,     mode = \"region\",     nrep = 20,     parallel = FALSE,     progress = FALSE   ) outs summary(outs) plot(outs) } # }   if (FALSE) { # \\dontrun{ # Parallel mediation model  # NOTE: In real power analysis: # - Set R to an appropriate value. # - Remove nrep or set nrep to the desired value. # - Remove parallel or set it to TRUE to enable parallel processing. # - Remove progress or set it to TRUE to see the progress.  outp <- q_power_mediation_parallel(     as = c(\"s\", \"m\"),     bs = c(\"m\", \"s\"),     cp = \"n\",     n = 100,     R = 199,     seed = 1234,     mode = \"region\",     nrep = 20,     parallel = FALSE,     progress = FALSE   ) outp summary(outp) plot(outp) } # }"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Beta Distribution — rbeta_rs","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"Generate random numbers beta distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"","code":"rbeta_rs(n = 10, shape1 = 0.5, shape2 = 0.5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"n number random numbers generate. shape1 shape1 stats::rbeta(). shape2 shape2 stats::rbeta(). pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"First, specify two parameters, shape1 shape2, desired population mean standard deviation. random numbers, drawn beta distribution stats::rbeta() rescaled desired population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"","code":"set.seed(90870962) x <- rbeta_rs(n = 5000,               shape1 = .5,               shape2 = .5,               pmean = 3,               psd = 1) mean(x) #> [1] 3.003229 sd(x) #> [1] 0.9983932 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"Generate random numbers beta distribution, rescaled user-specified population mean standard deviation, within specific range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"","code":"rbeta_rs2(n = 10, bmean, bsd, blow = 0, bhigh = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"n number random numbers generate. bmean population mean. bsd population standard deviation. bsd zero negative, random numbers equal bmean. blow lower bound target range. bhigh upper bound target range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"First, specify two parameters, shape1 shape2, desired population mean standard deviation. random numbers, drawn beta distribution stats::rbeta() rescaled desired population range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"","code":"set.seed(90870962) x <- rbeta_rs2(n = 5000,                bmean = .80,                bsd = .10,                blow = .00,                bhigh = .95) mean(x) #> [1] 0.7991104 sd(x) #> [1] 0.1005175 hist(x)  y <- rbeta_rs2(n = 5000,                bmean = 4,                bsd = 3,                blow = -10,                bhigh = 10) mean(y) #> [1] 4.003419 sd(y) #> [1] 3.045306 hist(y)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Binary Variable — rbinary_rs","title":"Random Binary Variable — rbinary_rs","text":"Generate random numbers distribution 0 1, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Binary Variable — rbinary_rs","text":"","code":"rbinary_rs(n = 10, p1 = 0.5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Binary Variable — rbinary_rs","text":"n number random numbers generate. p1 probability 1, rescaling. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Binary Variable — rbinary_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Binary Variable — rbinary_rs","text":"First, specify probability 1 (p1), desired population mean standard deviation. random numbers, drawn distribution 0 (1 - p1 probability) 1 (p1 probability), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Binary Variable — rbinary_rs","text":"","code":"set.seed(90870962) x <- rbinary_rs(n = 5000,                 p1 = .5,                 pmean = 3,                 psd = 1) mean(x) #> [1] 3.0244 sd(x) #> [1] 0.9998023 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":null,"dir":"Reference","previous_headings":"","what":"Rejection Rates — rejection_rates","title":"Rejection Rates — rejection_rates","text":"Get rejection rates tests stored power4test object supported objects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rejection Rates — rejection_rates","text":"","code":"rejection_rates(object, ...)  # Default S3 method rejection_rates(object, ...)  # S3 method for class 'power4test' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   collapse = c(\"none\", \"all_sig\", \"at_least_one_sig\", \"at_least_k_sig\"),   at_least_k = 1,   merge_all_tests = FALSE,   p_adjust_method = \"none\",   alpha = 0.05,   ... )  # S3 method for class 'power4test_by_es' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'power4test_by_n' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'rejection_rates_df' print(x, digits = 3, annotation = TRUE, abbreviate_col_names = TRUE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rejection Rates — rejection_rates","text":"object object rejection rates computed, power4test object, power4test_by_n object, power4test_by_es object. ... Optional arguments. print method, arguments passed print method data.frame objects print.data.frame(). used methods. all_columns TRUE, columns stored test extracted. Default FALSE essential columns related power printed. ci TRUE, confidence intervals rejection rates (column reject sig) computed. method determined option power4mome.ci_method. NULL \"wilson\", Wilson's (1927) method used. \"norm\", normal approximation used. level level confidence confidence intervals, ci TRUE. Default .95, denoting 95%. se TRUE, standard errors rejection rates (column reject sig) computed. Normal approximation used compute standard errors. collapse Whether single decision (significant vs. significant) made across tests test consists several tests (e.g., tests several parameters). \"none\", tests summarized individually. \"all_sig\", set tests considered significant individual tests significant. \"at_least_one_sig\", set tests considered significant least one tests significant. \"at_least_k_sig\", set tests considered significant least k tests significant, k set argument at_least_k. at_least_k Used collapse, number tests required significant set tests considered significant. merge_all_tests TRUE, tests replication merged one test. p_adjust_method method passed p.adjust() adjust p-values testing effects. Default \"none\" p-values adjusted. Ignored tests p-values stored. NOTE: Use tests can  conducted using p-values. alpha level significance use using p_adjust_method. significance results (column sig) updated using adjusted p-values. Used p_adjust_method \"none\". x rejection_rates_df object printed. digits number digits printed decimal. annotation Logical. Whether additional notes printed. abbreviate_col_names Logical. Whether column names abbreviated.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rejection Rates — rejection_rates","text":"rejection_rates method returns rejection_rates_df object, print method. input (object) power4test object, rejection_rates_df object data-frame like object number rows equal number tests. Note tests, test test_parameters(), conduct one test parameter. test counted one test. data frame least columns: test: name test. label: label test, \"Test\" test one test (e.g., test_indirect_effect()). pvalid: proportion valid tests across replications. reject: rejection rate test. null hypothesis false, power. rejection_rates method power4test_by_es objects returns object class rejection_rates_df_by_es, subclass rejection_rates_df. data frame similar output rejection_rates(), two columns added effect size (pop_es_name pop_es_values) test. rejection_rates method power4test_by_n objects returns object class rejection_rates_df_by_n, subclass rejection_rates_df. data frame similar output power4test object, column n added sample size test. print method rejection_rates_df object returns object invisibly. called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rejection Rates — rejection_rates","text":"power4test object, rejection_rates loops tests stored power4test object retrieves rejection rate test. rejection_rates method power4test_by_es objects used compute rejection rates power4test_by_es object, effect sizes added output. rejection_rates method power4test_by_n objects used compute rejection rates, sample sizes added output.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rejection Rates — rejection_rates","text":"Wilson, E. B. (1927). Probable inference, law succession, statistical inference. Journal American Statistical Association, 22(158), 209-212. doi:10.1080/01621459.1927.10502953","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rejection Rates — rejection_rates","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Generate some datasets to check the model  sim_only <- power4test(nrep = 4,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 50,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  # Do the test 'test_indirect_effect' on each datasets  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Do the test: test_indirect: x->m->y   # Do the test 'test_parameters' on each datasets # and add the results to 'test_out'  test_out <- power4test(object = test_out,                        test_fun = test_parameters) #> Do the test: test_parameters: CIs    # Compute and print the rejection rates for stored tests  rejection_rates(test_out) #>                     test test_label    est   p.v reject r.cilo r.cihi #> 1 test_indirect: x->m->y       Test  0.149 1.000  1.000  0.510  1.000 #> 2  test_parameters: CIs         m~x  0.317 1.000  1.000  0.510  1.000 #> 3  test_parameters: CIs         y~m  0.475 1.000  1.000  0.510  1.000 #> 4  test_parameters: CIs         y~x -0.080 1.000  0.000  0.000  0.490 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns.  # See the help pages of power4test_by_n() and power4test_by_es() # for other examples."},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From an Exponential Distribution — rexp_rs","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"Generate random numbers exponential distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"","code":"rexp_rs(n = 10, rate = 1, pmean = 0, psd = 1, rev = FALSE)"},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"n number random numbers generate. rate rate stats::rexp(). pmean Population mean. psd Population standard deviation. rev TRUE, distribution revered generate negatively skewed distribution. Default FALSE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"First, specify parameter, rate, desired population mean standard deviation. random numbers, drawn exponential distribution stats::rexp(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"","code":"set.seed(90870962) x <- rexp_rs(n = 5000,              rate = 4,              pmean = 3,              psd = 1) mean(x) #> [1] 2.999214 sd(x) #> [1] 1.008795 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Lognormal Distribution — rlnorm_rs","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"Generate random numbers lognormal distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"","code":"rlnorm_rs(n = 10, mui = 0, sigma = 1, rev = FALSE, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"n number random numbers generate. mui parameter mui used stats::rlnorm(). sigma parameter sigma used stats::rlnorm(). rev TRUE, distribution revered generate negatively skewed distribution. Default FALSE. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"First, specify parameter, mui sigma, desired population mean standard deviation. random numbers, drawn lognormal distribution stats::rlnorm(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"","code":"set.seed(90870962) x <- rlnorm_rs(n = 5000,                mui = 0,                sigma = 1,                pmean = 0,                psd = 1) mean(x) #> [1] -0.005312214 sd(x) #> [1] 0.9400859 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"Generate random numbers generalized normal distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"","code":"rpgnorm_rs(n = 10, p = 2, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"n number random numbers generate. p parameter distribution. Must positive non-zero number. Default 2, resulting normal distribution. Higher 2 results negative excess kurtosis. Lower 2 results positive excess kurtosis. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"First, specify parameter p desired population mean standard deviation. random numbers, drawn generalized normal distribution pgnorm::rpgnorm(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"","code":"set.seed(90870962) x <- rpgnorm_rs(n = 5000,                 p = 2,                 pmean = 0,                 psd = 1) mean(x) #> [1] -0.01118704 sd(x) #> [1] 1.010004 hist(x)  x_kurt <- function(p) {gamma(5/p)*gamma(1/p)/(gamma(3/p)^2) - 3}  p <- 6 x <- rpgnorm_rs(n = 50000,                 p = p,                 pmean = 0,                 psd = 1) mean(x) #> [1] 0.002266498 sd(x) #> [1] 1.001834 x_kurt(p) #> [1] -1 qqnorm(x); qqline(x)   p <- 1 x <- rpgnorm_rs(n = 50000,                 p = p,                 pmean = 0,                 psd = 1) mean(x) #> [1] 0.007350372 sd(x) #> [1] 0.9993787 x_kurt(p) #> [1] 3 qqnorm(x); qqline(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a t Distribution — rt_rs","title":"Random Variable From a t Distribution — rt_rs","text":"Generate random numbers t distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a t Distribution — rt_rs","text":"","code":"rt_rs(n = 10, df = 5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a t Distribution — rt_rs","text":"n number random numbers generate. df df stats::rt(). pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a t Distribution — rt_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a t Distribution — rt_rs","text":"First, specify parameter df desired population mean standard deviation. random numbers, drawn generalized normal distribution stats::rt(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a t Distribution — rt_rs","text":"","code":"set.seed(90870962) x <- rt_rs(n = 5000,            df = 5,            pmean = 3,            psd = 1) mean(x) #> [1] 3.004783 sd(x) #> [1] 0.9926204 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Uniform Distribution — runif_rs","title":"Random Variable From a Uniform Distribution — runif_rs","text":"Generate random numbers uniform distribution, user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Uniform Distribution — runif_rs","text":"","code":"runif_rs(n = 10, min = 0, max = 1, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Uniform Distribution — runif_rs","text":"n number random numbers generate. min min runif. max max runif. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Uniform Distribution — runif_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Uniform Distribution — runif_rs","text":"First, user specifies parameters, min max, desired population mean standard deviation. random numbers generated rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Uniform Distribution — runif_rs","text":"","code":"set.seed(90870962) x <- runif_rs(n = 5000,               min = 2,               max = 4,               pmean = 3,               psd = 1) mean(x) #> [1] 2.987606 sd(x) #> [1] 0.9978981 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Datasets Based on a Model — sim_data","title":"Simulate Datasets Based on a Model — sim_data","text":"Get model matrix effect size specification simulate number datasets, along information. function","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Datasets Based on a Model — sim_data","text":"","code":"sim_data(   nrep = 10,   ptable = NULL,   model = NULL,   pop_es = NULL,   ...,   n = 100,   iseed = NULL,   number_of_indicators = NULL,   reliability = NULL,   x_fun = list(),   e_fun = list(),   process_data = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )  # S3 method for class 'sim_data' print(   x,   digits = 3,   digits_descriptive = 2,   data_long = TRUE,   fit_to_all_args = list(),   est_type = \"standardized\",   variances = NULL,   pure_x = TRUE,   pure_y = TRUE,   ... )  pool_sim_data(object, as_list = FALSE)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Datasets Based on a Model — sim_data","text":"nrep number replications generate simulated datasets. Default 10. ptable output ptable_pop(), ptable_pop object, representing population model. NULL, default, ptable_pop() called generate ptable_pop object, using arguments model pop_es. model lavaan model syntax population model. Ignored ptable specified. See ptable_pop specify argument. pop_es character specify population effect sizes. See ptable_pop specify argument. Ignored ptable specified. ... sim_data, parameters passed ptable_pop(). print.sim_data(), arguments ignored. n sample size dataset. Default 100. iseed seed random number generator. Default NULL seed changed. number_of_indicators named vector specify number indicators factors. See help page set argument. Default NULL variables model syntax observed variables. See help page use argument. reliability named vector (single-group model) named list named vectors (multigroup model) set reliability coefficient set indicators. Default NULL. See help page use argument. x_fun function(s) used generate exogenous variables error terms. supplied, set list(), default, variables generated multivariate normal distribution. See help page use argument. e_fun function(s) used generate error terms indicators, . supplied, set list(), default, error terms indicators generated multivariate normal distribution. Specify way x_fun. Refer help page x_fun use argument. process_data NULL, must named list elements: fun (required), function processing simulated data, generating missing data using functions mice::ampute(); args (optional), named list arguments passed fun, except one source data; sim_data_name (required) name argument receive simulated data (e.g., data mice::ampute()); processed_data_name (optional), name data frame processed fun, data frame missing data output fun (e.g., \"amp\" mice::ampute()), omitted, output fun data frame missing data. parallel TRUE, parallel processing used simulate datasets. Default FALSE. progress TRUE, progress data simulation displayed. Default `FALSE. ncores number CPU cores use parallel processing used. x sim_data object printed. digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. data_long TRUE, detailed information printed. fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined samples stored. est_type type estimates printed. Can character vector one two elements. \"standardized\", standardized estimates printed. \"unstandardized\", unstandardized estimates printed. vector like c(\"standardized\", \"unstandardized\"), unstandardized standardized estimates printed. variances Logical. Whether variances error variances printed. Default depends est_type. \"unstandardized\" est_type, default TRUE \"standardized\" est_type, default FALSE. pure_x, pure_y Logical. printing indirect effects, whether \"pure\" x-variables (variables predicted another variables) /\"pure\" y-variables (variables predict variables indicators) included enumerating paths. object Either sim_data object power4test object. extracts simulated data return , combined one single data frame , as_list TRUE, list data frames. as_list Logical. TRUE, simulated datasets returned one single data frame. FALSE, returned list data frames.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_out() returns list class sim_data, length nrep. element sim_data_i object, following major elements: ptable: lavaan parameter table model, population values set column start. (output function ptable_pop().) mm_out: population model represented model matrices lavaan. (output function model_matrices_pop().) mm_lm_out: list regression model formula, one endogenous variable. (output internal function mm_lm().) mm_lm_dat_out: simulated dataset generated population model. (output internal function mm_lm_data()). model_original: original model syntax (.e., argument model). model_final: modified model syntax model latent variable model. Indicators added syntax. fit0: output lavaan::sem() ptable model .fit set FALSE. Used easy retrieval information model. print method sim_data returns x invisibly. called side effect. function pool_sim_data() returns either one data frame list data frames, depending argument as_list","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() generates list datasets based population model.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"the-role-of-sim-data-","dir":"Reference","previous_headings":"","what":"The role of sim_data()","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"workflow","dir":"Reference","previous_headings":"","what":"Workflow","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() two tasks: Determine actual population model population values based : model syntax observed variables (path model) latent factors (latent variable model). textual specification effect sizes parameters. number indicators latent factor model latent variable model. reliability latent factor measured indicators model latent factor model. Generate nrep simulated datasets population model. simulated datasets can used fit model, test parameters, estimate power. output usually used fit_model() fit target model, default population model, dataset.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"set-number-of-indicators-and-reliability-","dir":"Reference","previous_headings":"","what":"Set 'number_of_indicators' and 'reliability'","title":"Simulate Datasets Based on a Model — sim_data","text":"arguments number_of_indicators reliability used specify number indicators (e.g., items) factor, population reliability coefficient factor, variables model syntax latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"variable model replaced indicators generated data, set number_of_indicators named numeric vector. names variables variables indicators, appeared model syntax. value name number indicators. argument reliability set named numeric vector (list, see section multigroup models) specify population reliability coefficient (\"omega\") set indicators. population standardized factor loadings computed ensure population reliability coefficient target value. examples single group model: numbers indicators m, x, y 3, 4, 5, respectively. population reliability coefficients m, x, y .90, .80, .70, respectively.","code":"number of indicator = c(m = 3, x = 4, y = 5) reliability = c(m = .90, x = .80, y = .70)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-models","dir":"Reference","previous_headings":"","what":"Multigroup Models","title":"Simulate Datasets Based on a Model — sim_data","text":"Multigroup models supported. number groups inferred pop_es (see help page ptable_pop()), directly ptable. multigroup model, number indicators variable must across groups. However, population reliability coefficients can different across groups. multigroup model k groups, one population reliability coefficients differ across groups, argument reliability set named list. names variables population reliability coefficients set. element name either single value common reliability coefficient, numeric vector reliability coefficient group. example reliability model 2 groups: reliability coefficients x .80 groups, reliability coefficients m .70 one group .80 another.","code":"reliability = list(x = .80, m = c(.70, .80))"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"equal-numbers-of-indicators-and-or-reliability-coefficients","dir":"Reference","previous_headings":"","what":"Equal Numbers of Indicators and/or Reliability Coefficients","title":"Simulate Datasets Based on a Model — sim_data","text":"variables model number indicators, number_of_indicators can set one single value. Similarly, sets indicators population reliability groups, reliability can also set one single value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-the-distributions-of-exogenous-variables-or-error-terms-using-x-fun-","dir":"Reference","previous_headings":"","what":"Specify The Distributions of Exogenous Variables Or Error Terms Using 'x_fun'","title":"Simulate Datasets Based on a Model — sim_data","text":"default, variables error terms generated multivariate normal distribution. desired, users can supply function used generate exogenous variable error term setting x_fun named list. names list variables user function used generate data. element list must also list. first element list, can unnamed, function used. arguments need supplied, included named elements list. example: variables x w generated user-supplied functions. x, function power4mome::rexp_rs. additional argument calling function. w, function power4mome::rbinary_rx. argument p1 = .70 passed function generating values w. variable endogenous variable (e.g., predicted another variable model), x_fun used generate error term. implied population distribution may still different generate x_fun distribution also depends distribution variables predicting . requirements user-functions: must return numeric vector. mush argument n number values. population mean standard deviation generated values must 0 1, respectively. package power4mome helper functions generating values common nonnormal distributions scaling population mean standard deviation equal 0 1 (default), respectively. : rbinary_rs(). rexp_rs(). rbeta_rs(). rlnorm_rs(). rpgnorm_rs(). use x_fun, variables must zero covariances variables population. possible generate nonnormal multivariate data believe rarely needed estimating power data.","code":"x_fun = list(x = list(power4mome::rexp_rs),              w = list(power4mome::rbinary_rs,                       p1 = .70)))"},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Simulate Datasets Based on a Model — sim_data","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Simulate Datasets Based on a Model — sim_data","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Simulate Datasets Based on a Model — sim_data","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-3","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Simulate Datasets Based on a Model — sim_data","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Simulate Datasets Based on a Model — sim_data","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Simulate Datasets Based on a Model — sim_data","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Datasets Based on a Model — sim_data","text":"","code":"# Specify the model  mod <- \"m ~ x  y ~ m + x\"  # Specify the population values  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate the simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  data_all #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #>  y ~ m + x #> == Model on Variables/Indicators == #> m ~ x #>  y ~ m + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.910   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.090 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars   n  mean   sd  skew kurtosis   se #> m    1 500 -0.03 1.00 -0.09    -0.03 0.04 #> y    2 500 -0.01 0.98  0.03     0.41 0.04 #> x    3 500  0.01 0.94 -0.21     0.17 0.04 #>  #> ===== Parameter Estimates Based on All 5 Samples Combined ===== #>  #> Total Sample Size: 500  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.323 #>   y ~                       #>     m                 0.277 #>     x                -0.098 #>"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a 'sim_out' Object — sim_out","title":"Create a 'sim_out' Object — sim_out","text":"Combine outputs sim_data(), fit_model(), optionally gen_mc() /gen_boot() one single object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a 'sim_out' Object — sim_out","text":"","code":"sim_out(data_all, ...)  # S3 method for class 'sim_out' print(x, digits = 3, digits_descriptive = 2, fit_to_all_args = list(), ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a 'sim_out' Object — sim_out","text":"data_all output sim_data(). ... Named arguments objects added replication element extra. example, set fit = fit_all, fit_all output fit_model(), data_all[[1]]$extra$fit set first output fit_all. x sim_out object printed. digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined samples stored.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a 'sim_out' Object — sim_out","text":"function sim_out() returns sim_out object, list length equal length data_all. element list sim_data object element extra added . named elements added name. example. output fit_model() replication can added fit, extra. See description argument ... details. print method sim_out returns x invisibly. Called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a 'sim_out' Object — sim_out","text":"merges one object output sim_data(), list nrep simulated datasets, fit_model(), list lavaan::sem() output nrep datasets, optionally output gen_mc() gen_boot(), list R sets Monte Carlo bootstrap estimates based results fit_model(). list nrep elements, element data, model fit results, optionally Monte Carlo estimates matched. object can used testing effects interests, processed estimate power test. function sim_out() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a 'sim_out' Object — sim_out","text":"","code":"# Specify the model  mod <- \"m ~ x  y ~ m + x\"  # Specify the population values  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate the simulated datasets  dats <- sim_data(nrep = 5,                  model = mod,                  pop_es = es,                  n = 100,                  iseed = 1234)  # Fit the population model to each dataset  fits <- fit_model(dats)  # Combine the results to one object  sim_out_all <- sim_out(data_all = dats,                        fit = fits) sim_out_all #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #>  y ~ m + x #> == Model on Variables/Indicators == #> m ~ x #>  y ~ m + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.910   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.090 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars   n  mean   sd  skew kurtosis   se #> m    1 500 -0.03 1.00 -0.09    -0.03 0.04 #> y    2 500 -0.01 0.98  0.03     0.41 0.04 #> x    3 500  0.01 0.94 -0.21     0.17 0.04 #>  #> ===== Parameter Estimates Based on All 5 Samples Combined ===== #>  #> Total Sample Size: 500  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.323 #>   y ~                       #>     m                 0.277 #>     x                -0.098 #>   # Verify that the elements of fits are set to extra$fit  library(lavaan) #> This is lavaan 0.6-21 #> lavaan is FREE software! Please report any bugs. parameterEstimates(fits[[1]]) #>   lhs op rhs   est    se     z pvalue ci.lower ci.upper #> 1   m  ~   x 0.382 0.099 3.837  0.000    0.187    0.577 #> 2   y  ~   m 0.266 0.103 2.591  0.010    0.065    0.467 #> 3   y  ~   x 0.108 0.109 0.990  0.322   -0.106    0.322 #> 4   m ~~   m 0.903 0.128 7.071  0.000    0.653    1.153 #> 5   y ~~   y 0.951 0.134 7.071  0.000    0.687    1.214 #> 6   x ~~   x 0.913 0.000    NA     NA    0.913    0.913 parameterEstimates(sim_out_all[[1]]$extra$fit) #>   lhs op rhs   est    se     z pvalue ci.lower ci.upper #> 1   m  ~   x 0.382 0.099 3.837  0.000    0.187    0.577 #> 2   y  ~   m 0.266 0.103 2.591  0.010    0.065    0.467 #> 3   y  ~   x 0.108 0.109 0.990  0.322   -0.106    0.322 #> 4   m ~~   m 0.903 0.128 7.071  0.000    0.653    1.153 #> 5   y ~~   y 0.951 0.134 7.071  0.000    0.687    1.214 #> 6   x ~~   x 0.913 0.000    NA     NA    0.913    0.913 parameterEstimates(fits[[2]]) #>   lhs op rhs    est    se      z pvalue ci.lower ci.upper #> 1   m  ~   x  0.383 0.108  3.559  0.000    0.172    0.594 #> 2   y  ~   m  0.208 0.104  1.995  0.046    0.004    0.413 #> 3   y  ~   x -0.172 0.119 -1.442  0.149   -0.406    0.062 #> 4   m ~~   m  0.988 0.140  7.071  0.000    0.714    1.262 #> 5   y ~~   y  1.078 0.153  7.071  0.000    0.780    1.377 #> 6   x ~~   x  0.854 0.000     NA     NA    0.854    0.854 parameterEstimates(sim_out_all[[2]]$extra$fit) #>   lhs op rhs    est    se      z pvalue ci.lower ci.upper #> 1   m  ~   x  0.383 0.108  3.559  0.000    0.172    0.594 #> 2   y  ~   m  0.208 0.104  1.995  0.046    0.004    0.413 #> 3   y  ~   x -0.172 0.119 -1.442  0.149   -0.406    0.062 #> 4   m ~~   m  0.988 0.140  7.071  0.000    0.714    1.262 #> 5   y ~~   y  1.078 0.153  7.071  0.000    0.780    1.377 #> 6   x ~~   x  0.854 0.000     NA     NA    0.854    0.854"},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Test Results — summarize_tests","title":"Summarize Test Results — summarize_tests","text":"Extract summarize test results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Test Results — summarize_tests","text":"","code":"summarize_tests(   object,   collapse = c(\"none\", \"all_sig\", \"at_least_one_sig\", \"at_least_k_sig\"),   at_least_k = 1,   merge_all_tests = FALSE,   p_adjust_method = \"none\",   alpha = 0.05 )  # S3 method for class 'test_summary_list' print(x, digits = 3, ...)  # S3 method for class 'test_summary' print(x, digits = 2, ...)  # S3 method for class 'test_out_list' print(x, digits = 3, test_long = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Test Results — summarize_tests","text":"object power4test object element test_all power4test object. collapse Whether single decision (significant vs. significant) made across tests test consists several tests (e.g., tests several parameters). \"none\", tests summarized individually. \"all_sig\", set tests considered significant individual tests significant. \"at_least_one_sig\", set tests considered significant least one tests significant. \"at_least_k_sig\", set tests considered significant least k tests significant, k set argument at_least_k. at_least_k Used collapse, number tests required significant set tests considered significant. merge_all_tests TRUE, tests replication merged one test. p_adjust_method method passed p.adjust() adjust p-values testing effects. Default \"none\" p-values adjusted. unadjusted p-values stored column pvalue_org. Ignored tests p-values stored. NOTE: Use tests can  conducted using p-values. alpha level significance use using p_adjust_method. significance results (column sig) updated using adjusted p-values. Used p_adjust_method \"none\". x object printed. digits numbers digits decimal printing numeric results. ... Optional arguments. used. test_long TRUE, detailed report printed.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() returns list class test_summary_list. element contains summary test stored. elements class test_summary, elements: test_attributes: stored information test, printing. nrep: number datasets (replications). mean: means numeric information. significance tests, rejection rates. nvalid: number non-NA replications used compute mean. print methods returns x invisibly. called side effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() used extract information test stored power4test object. method print.test_out_list() used print content list test stored power4test object, option print just names tests.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"the-role-of-summarize-tests-and-related-functions","dir":"Reference","previous_headings":"","what":"The role of summarize_tests() and related functions","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() related print methods used --one function power4test() summary method. Users usually call directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Test Results — summarize_tests","text":"","code":"# Specify the model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulated datasets  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Test the parameters in each dataset  test_out <- power4test(object = sim_only,                        test_fun = test_parameters) #> Do the test: test_parameters: CIs    # Print the summary  summarize_tests(test_out) #>  #> =============== <test_parameters: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #> 4       m~~m   m ~~   m  0.945 0.134  7.071  0.000  0.683 1.207 1.000 #> 5       y~~y   y ~~   y  0.836 0.118  7.071  0.000  0.604 1.068 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize 'x_from_power' Results — summary.x_from_power","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"summary method output x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"","code":"# S3 method for class 'x_from_power' summary(object, ...)  # S3 method for class 'n_region_from_power' summary(object, ...)  # S3 method for class 'summary.x_from_power' print(x, digits = 3, ...)  # S3 method for class 'summary.n_region_from_power' print(x, digits = 3, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"object x_from_power-class object, output x_from_power(), object class n_region_from_power, output n_region_from_power(). ... Additional arguments. used now. x output summary.x_from_power(), summary method x_from_power object, output x_from_power(), output summary.n_region_from_power(), summary method n_region_from_power object (output n_region_from_power()). digits number digits decimal printing results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"summary method x_from_power objects returns object class summary.x_from_power, simply output x_from_power(), print method dedicated detailed summary. Please refer x_from_power() contents. print-method summary.x_from_power objects returns object x invisibly. called side effect. print-method summary.n_region_from_power objects returns object x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"summary method simply prepares results x_from_power() printed details.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 5,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 2345) #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 5,                            max_trials = 1,                            seed = 1234) #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  ci_hit  #> What:  point   (Estimated Power)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [50, 100]  #>  #>  #> Do the simulation for the lower bound: #>  #> Try x = 50  #>  #> Updating the simulation for sample size: 50  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 0.400, 95.0% confidence interval: [0.118,0.769] #>  #> Initial interval: [50, 100]  #>  #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2 100 0.298 1.000  0.800  0.376  0.964 #>  #>  #>  #> == Enter extending interval ... #>  #>  #>  #> == Exit extending interval ... #>  #>  #> Iteration # 1  #>  #> Try x = 75  #>  #> Updating the simulation for sample size: 75  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 1.000, 95.0% confidence interval: [0.566,1.000] #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2  75 0.334 1.000  1.000  0.566  1.000 #> 3 100 0.298 1.000  0.800  0.376  0.964 #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2026-02-01 15:17:54  #> - Rejection Rates: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2  75 0.334 1.000  1.000  0.566  1.000 #> 3 100 0.298 1.000  0.800  0.376  0.964 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.25384      0.04624   #>  #> Degrees of Freedom: 14 Total (i.e. Null);  13 Residual #> Null Deviance:\t    17.4  #> Residual Deviance: 15.23 \tAIC: 19.23 #>  #>  #> - Final Value: 75  #>  #> - Final Estimated Power: 1.0000  #> - Confidence Interval: [0.5655; 1.0000] #> - CI Level: 95.00% summary(power_vs_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = test_out, x = \"n\", target_power = 0.8,  #>     progress = TRUE, max_trials = 1, final_nrep = 5, seed = 1234) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 75 #>  #> - Final Estimated Power: 1.000  #> - Confidence Interval: [0.566; 1.000] #> - Level of confidence: 95.0% #> - Based on 5 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 75  #> - Time spent in the search: 0.9416 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.25384      0.04624   #>  #> Degrees of Freedom: 14 Total (i.e. Null);  13 Residual #> Null Deviance:\t    17.4  #> Residual Deviance: 15.23 \tAIC: 19.23 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2  75 0.334 1.000  1.000  0.566  1.000 #> 3 100 0.298 1.000  0.800  0.376  0.964 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a Conditional Indirect Effect — test_cond_indirect","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"Test conditional indirect effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"","code":"test_cond_indirect(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   wvalues = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   test_method = c(\"ci\", \"pvalue\"),   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"fit fit object, passed manymome::cond_indirect(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. wvalues numeric vector named elements. names variable names moderators, values values moderators set . Default NULL. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). test_method method test. \"ci\", confidence interval (e.g., bootstrap confidence interval) used test. \"pvalue\", asymmetric p-value Asparouhov & Muthén (2021) used test, confidence interval computed. ... Additional arguments passed manymome::cond_indirect(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"function used power4test() testing conditional indirect effect, setting test_fun argument. uses manymome::cond_indirect() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm(). can also used test conditional effect direct path mediator. Just omit m calling function.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"","code":"# Specify the model  model_simple_mod <- \" m ~ x + w + x:w y ~ m + x \"  # Specify the population values  model_simple_mod_es <- \" y ~ m: l y ~ x: n m ~ x: m m ~ w: n m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_mod,                        pop_es = model_simple_mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_cond_indirect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         wvalues = c(w = 1),                                         mc_ci = TRUE)) #> Do the test: test_cond_indirect: x->m->y (w = 1)  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.000   #>     x:w               0.150   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.888   #>    .y                 0.750   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Effect(s) == #>  #>        ind #> x -> y   0 #>  #>  - The 'ind' column shows the effect(s). #>   #> == Conditional indirect effects == #>  #>  Path: x -> m -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w)   ind   m~x   y~m #> 1 M+1.0SD   1 0.225 0.450 0.500 #> 2 Mean      0 0.150 0.300 0.500 #> 3 M-1.0SD  -1 0.075 0.150 0.500 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~x’,‘y~m’ is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> == Conditional indirect effects == #>  #>  Path: w -> m -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)    ind    m~w   y~m #> 1 M+1.0SD   1  0.075  0.150 0.500 #> 2 Mean      0 -0.000 -0.000 0.500 #> 3 M-1.0SD  -1 -0.075 -0.150 0.500 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~w’,‘y~m’ is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.530 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.104 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ======== <test_cond_indirect: x->m->y (w = 1)> ======== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig pvalue #>  0.206 0.068 0.377 0.800  0.048 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 5  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"Test several conditional indirect effects power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"","code":"test_cond_indirect_effects(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   wlevels = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   test_method = c(\"ci\", \"pvalue\"),   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"fit fit object, passed manymome::cond_indirect_effects(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. wlevels output manymome::merge_mod_levels(), moderator(s) passed manymome::mod_levels_list(). moderators can represented one variable, , moderator () numeric variable, (b) dichotomous categorical variable, (c) factor string variable used stats::lm() fit, vector names moderators appeared data frame. least one moderators categorical variable represented one variable, user-created dummy variables used lavaan::sem(), must list names moderators, moderators represented vector names. example: list(\"w1\", c(\"gpgp2\", \"gpgp3\"), first moderator w1 second moderator three-category variable represented gpgp2 gpgp3. See help page manymome::cond_indirect_effects() details. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). test_method method test. \"ci\", confidence interval (e.g., bootstrap confidence interval) used test. \"pvalue\", asymmetric p-value Asparouhov & Muthén (2021) used test, confidence interval computed. ... Additional arguments passed manymome::cond_indirect_effects(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"normal usage, returns output returned manymome::cond_indirect_effects(), following modifications: est: estimated conditional indirect effects. cilo cihi: lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated label conditional effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"function used power4test() testing several conditional indirect effects, setting test_fun argument. uses manymome::cond_indirect_effects() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm(). can also used test conditional effects direct path mediator. Just omit m calling function.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"","code":"# Specify the model  model_simple_mod <- \" m ~ x + w + x:w y ~ m + x \"  # Specify the population values  model_simple_mod_es <- \" y ~ m: l y ~ x: n m ~ x: m m ~ w: n m ~ x:w: l \"  # Simulate the data  # Set nrep to a larger value in real analysis, such as 400 sim_only <- power4test(nrep = 5,                        model = model_simple_mod,                        pop_es = model_simple_mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the tests in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_cond_indirect_effects,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         wlevels = c(\"w\"),                                         mc_ci = TRUE)) #> Do the test: test_cond_indirect_effects: x->m->y  print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.000   #>     x:w               0.150   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.887   #>    .y                 0.751   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Effect(s) == #>  #>        ind #> x -> y   0 #>  #>  - The 'ind' column shows the effect(s). #>   #> == Conditional indirect effects == #>  #>  Path: x -> m -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w)   ind   m~x   y~m #> 1 M+1.0SD   1 0.225 0.450 0.500 #> 2 Mean      0 0.150 0.300 0.500 #> 3 M-1.0SD  -1 0.075 0.150 0.500 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~x’,‘y~m’ is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> == Conditional indirect effects == #>  #>  Path: w -> m -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x)    ind    m~w   y~m #> 1 M+1.0SD   1  0.075  0.150 0.500 #> 2 Mean      0 -0.000 -0.000 0.500 #> 3 M-1.0SD  -1 -0.075 -0.150 0.500 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~w’,‘y~m’ is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.530 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.104 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ======== <test_cond_indirect_effects: x->m->y> ======== #>  #> Mean(s) across replication: #>             test_label     [w]    (w)   est   cilo  cihi   sig pvalue   m~x #> 1 x->m->y | w: M+1.0SD M+1.0SD  1.060 0.212  0.081 0.408 0.800  0.028 0.438 #> 2    x->m->y | w: Mean    Mean  0.061 0.132  0.033 0.254 0.800  0.160 0.275 #> 3 x->m->y | w: M-1.0SD M-1.0SD -0.939 0.053 -0.093 0.192 0.000  0.172 0.112 #>     y~m #> 1 0.474 #> 2 0.474 #> 3 0.474 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 5  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a Moderated Mediation Effect — test_index_of_mome","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"Test moderated mediation effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"","code":"test_index_of_mome(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   w = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   test_method = c(\"ci\", \"pvalue\"),   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"fit fit object, passed manymome::index_of_mome(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. w name moderator. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). test_method method test. \"ci\", confidence interval (e.g., bootstrap confidence interval) used test. \"pvalue\", asymmetric p-value Asparouhov & Muthén (2021) used test, confidence interval computed. ... Additional arguments passed manymome::index_of_mome(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"function used power4test() testing moderated mediation effect, setting test_fun argument. uses manymome::index_of_mome() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"","code":"# Specify the model  mod <- \" m ~ x + w + x:w y ~ m \"  # Specify the population values  mod_es <- \" m ~ x: n y ~ x: m m ~ w: l m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_index_of_mome,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         w = \"w\",                                         mc_ci = TRUE)) #> Do the test: test_index_of_mome: x->m->y, moderated by w   print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.000   #>     w                 0.500   #>     x:w               0.150   #>   y ~                         #>     m                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.731   #>    .y                 1.000   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Conditional indirect effects == #>  #>  Path: x -> m -> y #>  Conditional on moderator(s): w #>  Moderator(s) represented by: w #>  #>       [w] (w) ind    m~x y~m #> 1 M+1.0SD   1   0  0.150   0 #> 2 Mean      0   0 -0.000   0 #> 3 M-1.0SD  -1   0 -0.150   0 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~x’,‘y~m’ is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> == Conditional indirect effects == #>  #>  Path: w -> m -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x) ind   m~w y~m #> 1 M+1.0SD   1   0 0.650   0 #> 2 Mean      0   0 0.500   0 #> 3 M-1.0SD  -1   0 0.350   0 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~w’,‘y~m’ is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 2 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         6 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 5.502 #>   Degrees of freedom                                 3 #>   P-value (Chi-square)                           0.139 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ==== <test_index_of_mome: x->m->y, moderated by w> ==== #>  #> Mean(s) across replication: #>     est   cilo  cihi   sig pvalue #>  -0.006 -0.040 0.029 0.000  0.630 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 2  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Test an Indirect Effect — test_indirect_effect","title":"Test an Indirect Effect — test_indirect_effect","text":"Test indirect effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test an Indirect Effect — test_indirect_effect","text":"","code":"test_indirect_effect(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   test_method = c(\"ci\", \"pvalue\"),   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test an Indirect Effect — test_indirect_effect","text":"fit fit object, passed manymome::indirect_effect(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). test_method method test. \"ci\", confidence interval (e.g., bootstrap confidence interval) used test. \"pvalue\", asymmetric p-value Asparouhov & Muthén (2021) used test, confidence interval computed. ... Additional arguments passed manymome::indirect_effect(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test an Indirect Effect — test_indirect_effect","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test an Indirect Effect — test_indirect_effect","text":"function used power4test() testing indirect effect, setting test_fun argument. uses manymome::indirect_effect() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Test an Indirect Effect — test_indirect_effect","text":"Asparouhov, ., & Muthén, B. (2021). Bootstrap p-value computation. Retrieved https://www.statmodel.com/download/FAQ-Bootstrap%20-%20Pvalue.pdf","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test an Indirect Effect — test_indirect_effect","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         mc_ci = TRUE)) #> Do the test: test_indirect: x->m->y  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig pvalue #>  0.163 0.051 0.296 1.000  0.008 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 5  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_k_indirect_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Several Indirect Effects — test_k_indirect_effects","title":"Test Several Indirect Effects — test_k_indirect_effects","text":"Test several indirect effects power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_k_indirect_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Several Indirect Effects — test_k_indirect_effects","text":"","code":"test_k_indirect_effects(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   test_method = c(\"ci\", \"pvalue\"),   ...,   omnibus = c(\"no\", \"all_sig\", \"at_least_one_sig\", \"at_least_k_sig\"),   at_least_k = 1,   p_adjust_method = \"none\",   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_k_indirect_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Several Indirect Effects — test_k_indirect_effects","text":"fit fit object, passed manymome::indirect_effect(). x name x-variable, predictor. m Must list character vectors. character vector stores name(s) mediator(s) along path. path moves first mediator vector last mediator vector. NULL, stored paths used, indirect paths model x y, default. y name y-variable, outcome variable. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). test_method method test. \"ci\", confidence interval (e.g., bootstrap confidence interval) used test. \"pvalue\", asymmetric p-value Asparouhov & Muthén (2021) used test, confidence interval computed. ... Additional arguments passed manymome::many_indirect_effects(). omnibus \"\", default, test results paths stored. \"all_sig\", one row test stored, test declared significant paths significant. \"at_least_one_sig\", one row test stored, test declared significant least one paths significant. \"at_least_k_sig\", one row test stored, test declared significant least k paths significant, k determined argument at_least_k. at_least_k minimum number paths required significant omnibus test considered significant. Used omnibus \"at_least_k_sig\". p_adjust_method method passed p.adjust() adjust p-values testing effects. Default \"none\" p-values adjusted. unadjusted p-values stored column pvalue_org. fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_k_indirect_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Several Indirect Effects — test_k_indirect_effects","text":"normal usage, returns data frame following columns: est: estimated indirect effect path. cilo cihi: lower upper limits confidence interval (95% default), respectively, indirect effect sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated label indirect effects. omnibus \"all_sig\" \"at_least_one\"sig\", data frame one row, columns \"est\", \"cilo\", \"cihi\" NA. column sig determined whether paths significant (\"all_sig\") whether least one path significant (\"at_least_one_sig\").","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_k_indirect_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test Several Indirect Effects — test_k_indirect_effects","text":"function used power4test() testing indirect effect, setting test_fun argument. uses manymome::many_indirect_effects() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_k_indirect_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test Several Indirect Effects — test_k_indirect_effects","text":"","code":"# Specify the model  model_simple_med <- \" m1 ~ x m2 ~ x y ~ m1 + m2 + x \"  # Specify the population values  model_simple_med_es <- \" y ~ m1: s m1 ~ x: m y ~ m2: s m2 ~ x: l y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_k_indirect_effects,                        test_args = list(x = \"x\",                                         y = \"y\",                                         mc_ci = TRUE)) #> Do the test: test_indirects: x-...->y  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.500   #>   y ~                         #>     m1                0.100   #>     m2                0.100   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.750   #>    .y                 0.977   #>     x                 1.000   #>  #> (Computing indirect effects for 3 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.030 #> x -> m2 -> y 0.050 #> x -> y       0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         8 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.219 #>   Degrees of freedom                                 1 #>   P-value (Chi-square)                           0.640 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ============== <test_indirects: x-...->y> ============== #>  #> Mean(s) across replication: #>     test_label   est   cilo  cihi pvalue   sig #> 1 x -> m1 -> y 0.026 -0.042 0.103  0.504 0.000 #> 2 x -> m2 -> y 0.034 -0.081 0.155  0.408 0.200 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 5  #> - Proportion of valid replications for rejection rate(s): 1.000   # Set omnibus = \"all_sig\" to declare # significant only if all paths are # significant  test_ind_all_sig <- power4test(                        object = sim_only,                        test_fun = test_k_indirect_effects,                        test_args = list(x = \"x\",                                         y = \"y\",                                         mc_ci = TRUE,                                         omnibus = \"all_sig\")) #> Do the test: test_indirects: x-...->y  print(test_ind_all_sig,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.500   #>   y ~                         #>     m1                0.100   #>     m2                0.100   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.750   #>    .y                 0.977   #>     x                 1.000   #>  #> (Computing indirect effects for 3 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.030 #> x -> m2 -> y 0.050 #> x -> y       0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         8 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.219 #>   Degrees of freedom                                 1 #>   P-value (Chi-square)                           0.640 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ============== <test_indirects: x-...->y> ============== #>  #> Mean(s) across replication: #>           test_label  est cilo cihi pvalue   sig #> 1 x-...->y (All sig)  NaN  NaN  NaN  0.504 0.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 5  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test All Moderation Effects — test_moderation","title":"Test All Moderation Effects — test_moderation","text":"Test moderation effects testing product terms power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test All Moderation Effects — test_moderation","text":"","code":"test_moderation(   fit = fit,   standardized = FALSE,   check_post_check = TRUE,   ...,   p_adjust_method = \"none\",   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test All Moderation Effects — test_moderation","text":"fit fit object, passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). standardized Logical. TRUE, lavaan::standardizedSolution() used. Can used models fitted lavaan. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). p_adjust_method method passed p.adjust() adjust p-values testing effects. Default \"none\" p-values adjusted. unadjusted p-values stored column pvalue_org. fit_name name fit results parameter names displayed. Default \"fit\". get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test All Moderation Effects — test_moderation","text":"normal usage, returns output returned lavaan::parameterEstimates() lmhelprs::lm_list_to_partable(), following modifications: est: parameter estimates, even standardized estimates requested (est.std). cilo cihi: lower upper limits confidence interval (95% default), respectively (ci.lower ci.upper). sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated lavaan::lav_partable_labels(), usually labels used coef() label parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test All Moderation Effects — test_moderation","text":"function used power4test() testing product terms, setting test_fun argument. just wrapper test_parameters(). first identifies product terms (terms : names), call test_parameters(), pars set select regression coefficients terms.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test All Moderation Effects — test_moderation","text":"","code":"# Specify the model  mod <- \" m ~ x + w1 + x:w1 y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: n y ~ x: m m ~ w1: n m ~ x:w1: l \"  # Simulate the data  sim_only <- power4test(nrep = 4,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Do the test in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_moderation) #> Do the test: test_moderation: CIs    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w1 + x:w1 #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w1 + x:w1 #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.000   #>     w1                0.000   #>     x:w1              0.150   #>   y ~                         #>     m                 0.000   #>     x                 0.300   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w1                0.000   #>     x:w1              0.000   #>   w1 ~~                       #>     x:w1              0.000   #>  #> Variances: #>                    Population #>    .m                 0.977   #>    .y                 0.910   #>     x                 1.000   #>     w1                1.000   #>     x:w1              1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> (Computing conditional effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Effect(s) == #>  #>          ind #> x -> y 0.300 #>  #>  - The 'ind' column shows the effect(s). #>   #> == Conditional indirect effects == #>  #>  Path: x -> m -> y #>  Conditional on moderator(s): w1 #>  Moderator(s) represented by: w1 #>  #>      [w1] (w1) ind    m~x y~m #> 1 M+1.0SD    1   0  0.150   0 #> 2 Mean       0   0  0.000   0 #> 3 M-1.0SD   -1   0 -0.150   0 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~x’,‘y~m’ is/are the path coefficient(s) along the path conditional #>    on the moderator(s). #>  #>  #> == Conditional indirect effects == #>  #>  Path: w1 -> m -> y #>  Conditional on moderator(s): x #>  Moderator(s) represented by: x #>  #>       [x] (x) ind   m~w1 y~m #> 1 M+1.0SD   1   0  0.150   0 #> 2 Mean      0   0  0.000   0 #> 3 M-1.0SD  -1   0 -0.150   0 #>  #>  - The 'ind' column shows the conditional indirect effects. #>  - ‘m~w1’,‘y~m’ is/are the path coefficient(s) along the path #>    conditional on the moderator(s). #>  #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  4  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.537 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.103 #>  #> =============== <test_moderation: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op  rhs   est    se     z pvalue   cilo  cihi   sig #> 1     m~x:w1   m  ~ x:w1 0.150 0.101 1.557  0.160 -0.047 0.348 0.250 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 4  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Test All Free Parameters — test_parameters","title":"Test All Free Parameters — test_parameters","text":"Test free parameters, including user-defined parameters, power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test All Free Parameters — test_parameters","text":"","code":"test_parameters(   fit = fit,   standardized = FALSE,   pars = NULL,   op = NULL,   remove.nonfree = TRUE,   check_post_check = TRUE,   ...,   omnibus = c(\"no\", \"all_sig\", \"at_least_one_sig\", \"at_least_k_sig\"),   at_least_k = 1,   p_adjust_method = \"none\",   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )  find_par_names(object, fit_name = \"fit\")"},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test All Free Parameters — test_parameters","text":"fit fit object, passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). standardized Logical. TRUE, lavaan::standardizedSolution() used. Can used models fitted lavaan. pars Optional. set character vector, parameters test_label equal values pars returned. See help page valid names. op Optional. set character vector, parameters operators (e.g., \"~\", \"=~\") returned. pars op specified, parameters meeting requirements returned. remove.nonfree Logical. TRUE, default, free parameters returned. Ignored standardized TRUE model fitted lavaan. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). omnibus \"\", default, test results paths stored. \"all_sig\", one row test stored, test declared significant paths significant. \"at_least_one_sig\", one row test stored, test declared significant least one paths significant. \"at_least_k_sig\", one row test stored, test declared significant least k paths significant, k determined argument at_least_k. at_least_k minimum number paths required significant omnibus test considered significant. Used omnibus \"at_least_k_sig\". p_adjust_method method passed p.adjust() adjust p-values testing effects. Default \"none\" p-values adjusted. unadjusted p-values stored column pvalue_org. fit_name name fit results parameter names displayed. Default \"fit\". get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument. object power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test All Free Parameters — test_parameters","text":"normal usage, returns output returned lavaan::parameterEstimates() lmhelprs::lm_list_to_partable(), following modifications: est: parameter estimates, even standardized estimates requested (est.std). cilo cihi: lower upper limits confidence interval (95% default), respectively (ci.lower ci.upper). sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated lavaan::lav_partable_labels(), usually labels used coef() label parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test All Free Parameters — test_parameters","text":"function used power4test() testing free user-defined model parameters, setting test_fun argument. models fitted lavaan, uses lavaan::parameterEstimates() test. bootstrapping requested (setting se = \"boot\"), supports bootstrap confidence intervals returned lavaan::parameterEstimates(). preliminary, though limited, supported models fitted stats::lm() (lmhelprs::many_lm()). Tests conducted ordinary least squares confidence intervals based t statistic, reported stats::confint() applied output stats::lm().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"find-the-names-of-parameters","dir":"Reference","previous_headings":"","what":"Find the names of parameters","title":"Test All Free Parameters — test_parameters","text":"use argument pars, names appeared function coef() must used. output lavaan, can usually inferred parameter syntax (e.g., y~x, space). sure, call coef() output lavaan. parameter labelled, label used par. sure, function find_par_names() can used find valid names.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test All Free Parameters — test_parameters","text":"","code":"# Specify the model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Do the tests in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_parameters) #> Do the test: test_parameters: CIs    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =============== <test_parameters: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #> 4       m~~m   m ~~   m  0.945 0.134  7.071  0.000  0.683 1.207 1.000 #> 5       y~~y   y ~~   y  0.836 0.118  7.071  0.000  0.604 1.068 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000   # Do the tests in each replication: Standardized solution # Delta method SEs will be used to do the tests  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(standardized = TRUE)) #> Do the test: test_parameters: CIs (standardized)    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ======== <test_parameters: CIs (standardized) > ======== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.347 0.085  4.069  0.000  0.180 0.514 1.000 #> 2        y~m   y  ~   m  0.446 0.086  5.190  0.000  0.277 0.615 1.000 #> 3        y~x   y  ~   x -0.024 0.094 -0.233  0.232 -0.209 0.160 0.000 #> 4       m~~m   m ~~   m  0.880 0.059 14.888  0.000  0.764 0.995 1.000 #> 5       y~~y   y ~~   y  0.791 0.071 11.181  0.000  0.652 0.931 1.000 #> 6       x~~x   x ~~   x  1.000 0.000    NaN    NaN  1.000 1.000 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000   # Do the tests in each replication: Parameters with the selected operator  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(op = \"~\")) #> Do the test: test_parameters: CIs (op: ~)   print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Conditional/Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #> x -> y      0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-21 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ============ <test_parameters: CIs (op: ~)> ============ #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000    # Finding valid parameter names  find_par_names(sim_only) #> [1] \"m~x\"  \"y~m\"  \"y~x\"  \"m~~m\" \"y~~y\""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Size and Effect Size Determination — x_from_power","title":"Sample Size and Effect Size Determination — x_from_power","text":"searches simulation sample size (given factors, effect sizes) effect size (given factors, sample size) power detect effect close target value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Size and Effect Size Determination — x_from_power","text":"","code":"x_from_power(   object,   x = arg_x_from_power(object, \"x\", arg_in = \"call\") %||% \"n\",   pop_es_name = arg_x_from_power(object, \"pop_es_name\", arg_in = \"call\"),   target_power = 0.8,   what = arg_x_from_power(object, \"what\") %||% \"point\",   goal = arg_x_from_power(object, \"goal\") %||% {      switch(what, point = \"ci_hit\", ub     = \"close_enough\", lb = \"close_enough\")  },   ci_level = 0.95,   tolerance = 0.02,   x_interval = switch(x, n = c(50, 2000), es = NULL),   extendInt = NULL,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   final_nrep = attr(object, \"args\")$nrep %||% (object$nrep_final %||% 400),   final_R = attr(object, \"args\")$R %||% (object$args$final_R %||% 1000),   seed = NULL,   x_include_interval = FALSE,   check_es_interval = TRUE,   power_curve_args = list(power_model = NULL, start = NULL, lower_bound = NULL,     upper_bound = NULL, nls_control = list(), nls_args = list()),   save_sim_all = FALSE,   algorithm = NULL,   control = list(),   internal_args = list() )  n_from_power(   object,   pop_es_name = NULL,   target_power = 0.8,   what = formals(x_from_power)$what,   goal = formals(x_from_power)$goal,   ci_level = 0.95,   tolerance = 0.02,   x_interval = c(50, 2000),   extendInt = NULL,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   final_nrep = formals(x_from_power)$final_nrep,   final_R = formals(x_from_power)$final_R,   seed = NULL,   x_include_interval = FALSE,   check_es_interval = TRUE,   power_curve_args = list(power_model = NULL, start = NULL, lower_bound = NULL,     upper_bound = NULL, nls_control = list(), nls_args = list()),   save_sim_all = FALSE,   algorithm = NULL,   control = list() )  n_region_from_power(   object,   pop_es_name = NULL,   target_power = 0.8,   ci_level = 0.95,   tolerance = 0.02,   x_interval = c(50, 2000),   extendInt = NULL,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   final_nrep = formals(x_from_power)$final_nrep,   final_R = formals(x_from_power)$final_R,   seed = NULL,   x_include_interval = FALSE,   check_es_interval = TRUE,   power_curve_args = list(power_model = NULL, start = NULL, lower_bound = NULL,     upper_bound = NULL, nls_control = list(), nls_args = list()),   save_sim_all = FALSE,   algorithm = NULL,   control = list() )  # S3 method for class 'x_from_power' print(x, digits = 3, ...)  # S3 method for class 'n_region_from_power' print(x, digits = 3, ...)  arg_x_from_power(object, arg, arg_in = NULL)"},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Size and Effect Size Determination — x_from_power","text":"object power4test object, output power4test(). Can also power4test_by_n object, output power4test_by_n(), power4test_by_es object, output power4test_by_es(). two types objects, attempt power closest target_power used object, attempts included estimation subsequent attempts final output. Last, can also output previous call x_from_power(), stored trials retrieved. x x_from_power(), x set value searched. Can \"n\", sample size, \"es\", population value parameter (set pop_es_name). print method x_from_power objects, output x_from_power(). pop_es_name name parameter. Required x \"es\". See help page ptable_pop() names argument pop_es. target_power target power, value greater 0 less one. value searched: estimate power (\"point\"), upper bound confidence interval (\"ub\"), lower bound confidence interval (\"lb\"). goal goal search. \"ci_hit\", goal find value x confidence interval estimated power including target power. \"close_enough\", goal find value x value \"close enough\" target power, defined absolute difference target power less tolerance. ci_level level confidence confidence intervals computed estimated power. Default .95, denoting 95%. tolerance Used goal \"close_enough\". x_interval vector two values, minimum value maximum values x, search values (sample sizes population values). NULL, default x = \"es\", determined internally. extendInt Whether x_interval can expanded estimating values try. value passed argument name stats::uniroot(). x \"n\", default value \"upX\". , value higher maximum x_interval allowed, predicted tentative model. Otherwise, default value \"\". See help page stats::uniroot() information. progress Logical. Whether searching progress reported. simulation_progress Logical. Whether progress call power4test(), power4test_by_n(), power4test_by_es() shown. passed progress argument functions. max_trials maximum number trials searching value target power. Rounded integer. final_nrep number replications final stage, also maximum number replications call power4test(), power4test_by_n(), power4test_by_es(). object output power4test() x_from_power() argument set, final_nrep set nrep final_nrep stored object. final_R number Monte Carlo simulation bootstrapping samples final stage. R calling power4test(), power4test_by_n(), power4test_by_es() stepped value approaching target power. need large goal estimate power replications, high precision one single replication. object output power4test() x_from_power() argument set, finalR set R final_R stored object. seed NULL, set.seed() used make process reproducible. always possible many stages parallel processing involved. x_include_interval Logical. Whether minimum maximum values x_interval mandatory included values searched. check_es_interval TRUE, default, x \"es\", conservative probable range valid values selected parameter determined, used instead x_interval. range spans positive negative values, interval sign population value object used. power_curve_args named list arguments passed power_curve() estimating relation power x (sample size effect size). Please refer power_curve() available arguments. one except: power_model mapped formula argument power_curve(). save_sim_all FALSE, default, data power4test object value x saved, reduce size output. set TRUE, size output can large size. algorithm algorithm finding x. Can \"power_curve\" \"bisection\". default algorithm depends x. control named list additional arguments passed algorithm used. advanced users. internal_args named list internal arguments. internal testing. use . digits number digits decimal printing results. ... Optional arguments. used now. arg name element retrieve. arg_in name element element retrieved.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Size and Effect Size Determination — x_from_power","text":"function x_from_power() returns x_from_power object, list following elements: power4test_trials: output power4test_by_n() sample sizes examined, power4test_by_es() population values selected parameter examined. rejection_rates: output rejection_rates(). x_tried: sample sizes population values examined. power_tried: estimated rejection rates values examined. x_final: sample size population value solution. NA solution found. power_final: estimated power value solution. NA solution found. i_final: position solution power4test_trials. NA solution found. ci_final: confidence interval estimated power solution. method determined option power4mome.ci_method. NULL \"wilson\", Wilson's (1927) method used. \"norm\", normal approximation used. ci_level: level confidence ci_final. nrep_final: number replications (nrep) estimating power solution. power_curve: output power_curve() estimating power curve. target_power: requested target power. power_tolerance: allowed difference solution's estimated power target power. Determined number replications level confidence confidence intervals. x_estimated: value (sample size population value) target power, estimated power_curve. used, solution found, determine range values search calling function . start: time date process started. end: time date process ended. time_spent: time spent search. args: named list arguments x_from_power() used search. call: call function called. function n_region_from_power() returns named list two output n_from_power(), class n_region_from_power. output = \"ub\" named \"\", output = \"lb\" namd \"\". print-method x_from_power objects returns object x invisibly. called side effect. print-method x_from_power_region objects returns object x invisibly. called side effect. function arg_x_from_power() returns requested argument available. available, returns NULL.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Size and Effect Size Determination — x_from_power","text":"use x_from_power(): Specify model power4test(), do_the_test = FALSE, set magnitude effect sizes minimum levels detect. Add test using power4test() using test_fun test_args (see help page power4test() details). Run starting sample size effect size. Call x_from_power() output power4test() returned previous step. function iteratively repeat analysis either sample sizes, values selected model parameter (effect sizes), trying achieve goal (goal) value interest (). goal \"ci_hit\", search try find value (sample size, population value selected model parameter) power level close enough target power, defined confidence interval power including target power. goal \"close_enough\", search try find value x level power (\"point\"), upper bound confidence interval level power (\"ub\"), lower bound confidence interval fro level power (\"lb\") \"close enough\" target level power, defined absolute difference less tolerance. several values x (sample size population value model parameter) already examined power4test_by_n() power4test_by_es(), output two functions can also used object x_from_power(). Usually, default values arguments sufficient. results can viewed using summary(), output plot method (plot.x_from_power()) plot relation power values (x) examined. detailed illustration use function sample size can found page: https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html function n_from_power() just wrapper x_from_power(), x set \"n\". function n_region_from_power() just wrapper x_from_power(), x set \"n\", two passes, one = \"ub\" one = \"lb\". print method prints basic information. Call summary method x_from_power objects (summary.x_from_power()) print method detailed results function arg_x_from_power() helper set argument values object output x_from_power() similar functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"algorithms","dir":"Reference","previous_headings":"","what":"Algorithms","title":"Sample Size and Effect Size Determination — x_from_power","text":"Two algorithms currently available, simple (though sometimes inefficient) bisection method, method makes use estimated crude power curve. Unlike typical root-finding problems, prediction level power stochastic. Moreover, computational cost high Monte Carlo bootstrap confidence intervals used test estimation power one single value x can sometimes take one minute longer. Therefore, addition simple bisection method, method, named power curve method, also specifically developed scenario.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"bisection-method","dir":"Reference","previous_headings":"","what":"Bisection Method","title":"Sample Size and Effect Size Determination — x_from_power","text":"method, algorithm = \"bisection\", basically starts interval probably encloses value x meets goal, successively narrows interval. mid-point interval used estimate. Though simple, cases can slow. Nevertheless, preliminary examination suggests method good enough common scenarios. Therefore, method default algorithm x n.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"power-curve-method","dir":"Reference","previous_headings":"","what":"Power Curve Method","title":"Sample Size and Effect Size Determination — x_from_power","text":"method, algorithm = \"power_curve\", starts crude power curve based points. tentative model used suggest values examine next iteration. form, just parameters, model can change across iterations, data points available. method default method x = \"es\" goal = \"ci_hit\" relation power population value parameter varies across parameters, unlike relation power sample size. Therefore, taking account working power curve may help finding desired value x. version 0.1.1.33, method can used goal \"ci_hit\". Since version 0.1.1.34, supports goals, like bisection method. technical internal workflow method implemented x_from_power() can found page: https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample Size and Effect Size Determination — x_from_power","text":"Wilson, E. B. (1927). Probable inference, law succession, statistical inference. Journal American Statistical Association, 22(158), 209-212. doi:10.1080/01621459.1927.10502953","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Size and Effect Size Determination — x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 5,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 2345) #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  # In real analysis, to have more stable results: # - Use a larger final_nrep (e.g., 400).  # If the default values are OK, this call is sufficient: # power_vs_n <- x_from_power(test_out, #                            x = \"n\", #                            seed = 4567) power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 5,                            max_trials = 1,                            seed = 1234) #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  ci_hit  #> What:  point   (Estimated Power)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [50, 100]  #>  #>  #> Do the simulation for the lower bound: #>  #> Try x = 50  #>  #> Updating the simulation for sample size: 50  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 0.400, 95.0% confidence interval: [0.118,0.769] #>  #> Initial interval: [50, 100]  #>  #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2 100 0.298 1.000  0.800  0.376  0.964 #>  #>  #>  #> == Enter extending interval ... #>  #>  #>  #> == Exit extending interval ... #>  #>  #> Iteration # 1  #>  #> Try x = 75  #>  #> Updating the simulation for sample size: 75  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 1.000, 95.0% confidence interval: [0.566,1.000] #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2  75 0.334 1.000  1.000  0.566  1.000 #> 3 100 0.298 1.000  0.800  0.376  0.964 #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2026-02-01 15:18:10  #> - Rejection Rates: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2  75 0.334 1.000  1.000  0.566  1.000 #> 3 100 0.298 1.000  0.800  0.376  0.964 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.25384      0.04624   #>  #> Degrees of Freedom: 14 Total (i.e. Null);  13 Residual #> Null Deviance:\t    17.4  #> Residual Deviance: 15.23 \tAIC: 19.23 #>  #>  #> - Final Value: 75  #>  #> - Final Estimated Power: 1.0000  #> - Confidence Interval: [0.5655; 1.0000] #> - CI Level: 95.00% summary(power_vs_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = test_out, x = \"n\", target_power = 0.8,  #>     progress = TRUE, max_trials = 1, final_nrep = 5, seed = 1234) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 75 #>  #> - Final Estimated Power: 1.000  #> - Confidence Interval: [0.566; 1.000] #> - Level of confidence: 95.0% #> - Based on 5 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 75  #> - Time spent in the search: 0.9927 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.25384      0.04624   #>  #> Degrees of Freedom: 14 Total (i.e. Null);  13 Residual #> Null Deviance:\t    17.4  #> Residual Deviance: 15.23 \tAIC: 19.23 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.222 1.000  0.400  0.118  0.769 #> 2  75 0.334 1.000  1.000  0.566  1.000 #> 3 100 0.298 1.000  0.800  0.376  0.964 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on Wilson's (1927) method. #> - Refer to the tests for the meanings of other columns. #>  plot(power_vs_n)"},{"path":"https://sfcheung.github.io/power4mome/news/index.html","id":"power4mome-01135","dir":"Changelog","previous_headings":"","what":"power4mome 0.1.1.35","title":"power4mome 0.1.1.35","text":"Improve function extending initial interval bisection search. (0.1.1.1) Changed default method rejection rate confidence intervals Wilson’s (1927) method. backward compatibility, use options(power4mome.ci_method = \"norm\") set default method normal approximation. (0.1.1.2) Added test_method argument tests indirect effects variants use asymmetric p-values tests. (0.1.1.3) Updated test functions used manymome store number bootstrap Monte Carlo samples number estimates less zero. (0.1.1.4) Updated summarize_tests() rejection_rates() use extrapolation method Boos Zhang (2000) number resamples bootstrapping Monte Carlo supported values. (0.1.1.5, 0.1.1.6, 0.1.1.7) Improved rejection_rates_by_n() rejection_rates_by_es() handle attempts different number columns (due new Boos-Zhang methods). (0.1.1.8) Boos-Zhang-2000 method disabled default. Enable setting option power4mome.bz TRUE. (0.1.1.9) x_from_power() now detects whether test one result (e.g., testing two parameters omnibus \"none\"). yes, throw error. (0.1.1.10) Added two levels effects, sm small--moderate, ml moderate--large. (0.1.1.11) Updated extend_interval() handle intervals nearly equal function values. (0.1.1.12) Improved x_from_power() friends (e.g., n_from_power() n_region_from_power()) make use previous trials. (0.1.1.13) Optimized search bisection, make use value already tried store values tried. (0.1.1.14) Fixed duplicated values x extending range. (0.1.1.15) Functions print call replace object <hidden> symbol. (0.1.1.16) Functions print call replace function original function name symbol. (0.1.1.17) Added q_power_mediation() friends common mediation models. (0.1.1.18, 0.1.1.19) arguments final_nrep final_R x_from_power() wrappers use stored values available. (0.1.1.20) bisection algorithm improved handling unusual intervals. (0.1.1.21) Disable check number elements number_of_indicators reliability q_power_mediation_*() functions. (0.1.1.22) Skip check combining objects bisection algorithm must identical model. (0.1.1.23) Revised c.power4test_by_n() allow minor differences error variances determined Monte Carlo simulation. (0.1.1.24) Properly support model one latent variable. (0.1.1.25) Vertically displace labels sample sizes plot.n_region_from_power() prevent overlapping. (0.1.1.26) Fixed printing effects multigroup model within-group moderation. (0.1.1.27) Added merge_all_tests rejection_rates() support merging tests one. argument collapse can used collapse several different tests, just one test several results. (0.1.1.28) function power4test() now properly reuse arguments parallel ncores adding new test power4test object. (0.1.1.29) Updated test functions include p-values output. (0.0.1.30) Added p_adjust_method argument tests, well rejection_rates method summarize_tests(). Users can adjust p-values using p.adjust() one test test function set test_fun, merging several tests summarize_tests(). feature used estimate power multiple-comparison adjustment used, false discover rate (FDR) Bonferroni correction. (0.1.1.31) Updated tests disable printout running test context. (0.1.1.32) Added one model power_curve(). (0.1.1.34) Modified power curve algorithm support goal = \"close_enough\" three types (\"point\", \"lb\", \"ub\"). (0.1.1.34) Fixed bug extending intervals bisection algorithm, also improved way intervals extended. (0.1.1.35)","code":""},{"path":"https://sfcheung.github.io/power4mome/news/index.html","id":"power4mome-011","dir":"Changelog","previous_headings":"","what":"power4mome 0.1.1","title":"power4mome 0.1.1","text":"CRAN release: 2025-09-21 Updated compatible forthcoming version lavaan, 0.9-12. (0.1.1)","code":""},{"path":"https://sfcheung.github.io/power4mome/news/index.html","id":"power4mome-010","dir":"Changelog","previous_headings":"","what":"power4mome 0.1.0","title":"power4mome 0.1.0","text":"CRAN release: 2025-09-04 First public version. (0.1.0)","code":""}]
