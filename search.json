[{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://sfcheung.github.io/power4mome/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"article brief illustration use power4test() package power4mome power analysis mediation, moderation, moderated-mediation model fitted structural equation model modeling using lavaan.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Basic knowledge fitting models lavaan required. Readers also expected basic knowledge mediation, moderation, /moderated mediation.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"brief illustration. complicated scenarios features power4mome described vignettes.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"introduction needs following package:","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Two functions sufficient estimating power given model, population values, sample size, test used. basic workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified. Call rejection_rates() compute power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Let’s consider simple mediation model. like estimate power testing mediation effect Monte Carlo confidence interval.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"model syntax Note , even going test mediation, moderation, moderated-mediation effects, need add labels model. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) product term moderation, convention: Small: .05 (-.05) Medium: .10 (-.10) Large: .15 (-.15) values standardized solution (correlations -called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : string denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified string, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size many replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown printing object: default, population model fitted dataset, hence section <fit>. Perfect fit expected population model saturated model. check section Population Values see whether values expected. example, population values regression paths specified. different expect, check string pop_es see whether set population values correctly. necessary, can check data generation adding data_long = TRUE printing output: section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. results show specified population model correctly. can proceed specify test estimate power.","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can now simulation estimate power. large number datasets (e.g., 500) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect x y m, sample size 50. call: new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. real studies, number 10000 even 20000 Monte Carlo confidence intervals. However, 2000 sufficient goal estimate power generating many intervals, rather one single stable interval. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-functions common tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case tests done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 nrep = 400, 95% confidence limits power .80 .04 .80. precise enough determining whether sample size sufficient power. default printout: test_long = TRUE added printing output print(), summary test also printed. summary test: mean estimates across replications 0.152, close population value.","code":"out <- power4test(nrep = 400,                   model = mod,                   pop_es = mod_es,                   n = 50,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. print(out,       test_long = TRUE) #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est   cilo  cihi   sig #>  0.152 -0.009 0.347 0.468 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 400  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power","dir":"Articles","previous_headings":"Mediation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"power estimate simply proportion significant results, rejection rate, null hypothesis false. addition using test_long = TRUE print(), rejection rate can also retrieved rejection_rates(). example , estimated power test indirect effect, conducted Monte Carlo confidence interval, 0.468, column reject. p.v proportion valid results across replications. 1.000 means test conducted normally replications. default, 95% confidence interval rejection rate (power) based normal approximation also printed, column r.cilo r.cihi. example, 95% confidence interval [0.419; 0.516].","code":"out_power <- rejection_rates(out) out_power #>                     test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: x->m->y       Test 1.000  0.468  0.419  0.516 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"moderation","dir":"Articles","previous_headings":"","what":"Moderation","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Let’s consider moderation model, control variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"pop_es_xw","dir":"Articles","previous_headings":"Moderation","what":"Specify the Population Model and Values","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"model moderation, predictor x moderator w. product term included lavaan style, x:w. unrealistic specific population values control variables. Therefore, can just add proxy, control represent set control variables may included. syntax population values: example introduces one useful tag, .beta. model many paths, inconvenient specify manually. tag .beta. specify default value regression paths specified explicitly, small (.10) example. path explicitly included (y ~ control y ~ x:w), manually specified value used instead .beta.. example also illustrates can set population values correlations (covariances standardized solution). Control variables included usually may correlate predictors. Therefore, example, hypothesized small correlation x proxy control variable (x ~~ control: s). Last, recall section convention product term values different: l denotes .15 product terms.","code":"mod2 <- \" y ~ x + w + x:w + control \" mod2_es <- \" .beta.: s x ~~ control: s y ~ control: s y ~ x:w: l \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model-1","dir":"Articles","previous_headings":"Moderation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"check model first: population values regression paths specified, estimates based 5 × 104 2 100000 support dataset generated correctly. NOTE: product term involved, component terms (x w example) correlated, population standard deviation product term may equal one (Bohrnstedt & Goldberger, 1969). Therefore, model can specified correctly even standard deviations product terms section Descriptive Statistics close one.","code":"out2 <- power4test(nrep = 2,                    model = mod2,                    pop_es = mod2_es,                    n = 50000,                    iseed = 1234) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> y ~ x + w + x:w + control #>  #> == Model on Variables/Indicators == #>  #> y ~ x + w + x:w + control #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   y ~                         #>     x                 0.100   #>     w                 0.100   #>     x:w               0.150   #>     control           0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>     control           0.100   #>   w ~~                        #>     x:w               0.000   #>     control           0.000   #>   x:w ~~                      #>     control           0.000   #>  #> Variances: #>                    Population #>    .y                 0.946   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>     control           1.000   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>         vars     n mean sd  skew kurtosis se #> y          1 1e+05 0.00  1  0.02     0.01  0 #> x          2 1e+05 0.00  1  0.01     0.01  0 #> w          3 1e+05 0.00  1  0.00    -0.02  0 #> x:w        4 1e+05 0.00  1 -0.03     6.01  0 #> control    5 1e+05 0.01  1  0.00     0.00  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   y ~                       #>     x                 0.097 #>     w                 0.104 #>     x:w               0.152 #>     control           0.099 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                -0.003 #>     x:w               0.002 #>     control           0.101 #>   w ~~                      #>     x:w              -0.004 #>     control           0.001 #>   x:w ~~                    #>     control           0.004 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-test-the-moderation-effect","dir":"Articles","previous_headings":"Moderation","what":"Call power4test() to Test The Moderation Effect","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can now simulation estimate power. simple model, test just test product term, x:w. model can fitted linear regression using lm(). Let’s estimate power sample size 50 model fitted lm(): new arguments used: fit_model_args: named list stores additional arguments fit_model(). default, lavaan::sem() used. fit model linear regression using lm(), add fit_function = \"lm\" list.6 test_fun: set test_moderation, provided power4mome. function automatically identifies product terms model test . test used depends method used fit model. lm() used, usual t test used.7","code":"out2 <- power4test(nrep = 400,                    model = mod2,                    pop_es = mod2_es,                    n = 100,                    fit_model_args = list(fit_function = \"lm\"),                    test_fun = test_moderation,                    iseed = 1234,                    parallel = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power-1","dir":"Articles","previous_headings":"Moderation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can ues rejection_rates() estimate power: estimated power test product term, x:w, 0.347, 95% confidence interval [0.301; 0.394].","code":"out2_power <- rejection_rates(out2) out2_power #>                    test test_label   p.v reject r.cilo r.cihi #> 1 test_moderation: CIs       y~x:w 1.000  0.347  0.301  0.394 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"moderated-mediation","dir":"Articles","previous_headings":"","what":"Moderated-Mediation","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Let’s consider moderated mediation model.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"specify-the-population-model-and-values","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Specify the Population Model and Values","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"model mediation model -path, m ~ x, moderated w. explained , need use label define parameters. handled test function used. syntax population values: Please refer previous section setting syntax.","code":"mod3 <- \" m ~ x + w + x:w y ~ m + x \" mod3_es <- \" .beta.: s m ~ x: m y ~ m: m m ~ x:w: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model-2","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"check model first: population values estimates based 5 × 104 2 100000 expect.","code":"out3 <- power4test(nrep = 2,                    model = mod3,                    pop_es = mod3_es,                    n = 50000,                    iseed = 1234) print(out3,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.100   #>     x:w               0.050   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.898   #>    .y                 0.881   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n mean sd skew kurtosis se #> m      1 1e+05    0  1 0.03     0.03  0 #> y      2 1e+05    0  1 0.01    -0.01  0 #> x      3 1e+05    0  1 0.00    -0.02  0 #> w      4 1e+05    0  1 0.00     0.01  0 #> x:w    5 1e+05    0  1 0.04     5.92  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.303 #>     w                 0.099 #>     x:w               0.052 #>   y ~                       #>     m                 0.299 #>     x                 0.098 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                 0.003 #>     x:w              -0.001 #>   w ~~                      #>     x:w               0.008 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.007 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.997"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-test-the-moderated-mediation-effect","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Call power4test() to Test The Moderated-Mediation Effect","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"estimate power moderated-mediation effect, can test index moderated-mediation (Hayes, 2015). example, product coefficient m ~ x:w coefficient y ~ m. can done test function test_index_of_mome(), provided power4mome. , Monte Carlo confidence interval used. Let’s estimate power sample size 100. call similar one used testing mediation. new argument used: test_fun: set test_index_of_mome() example. function similar test_indirect_effect(), one argument, w, moderator. Although example one mediator, support number mediators along path.8","code":"out3 <- power4test(nrep = 400,                    model = mod3,                    pop_es = mod3_es,                    n = 100,                    R = 2000,                    ci_type = \"mc\",                    test_fun = test_index_of_mome,                    test_args = list(x = \"x\",                                     m = \"m\",                                     y = \"y\",                                     w = \"w\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power-2","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can ues rejection_rates() estimate power: estimated power test moderated mediation effect, conducted test index moderated mediation, 0.050, 95% confidence interval [0.029; 0.071]. Unlike previous example moderation tested regression, estimating power Monte Carlo confidence intervals substantially slower. However, necessary Monte Carlo nonparametric bootstrapping confidence interval test usually used moderated-mediation (mediation).","code":"out3_power <- rejection_rates(out3) out3_power #>                                          test test_label   p.v reject r.cilo #> 1 test_index_of_mome: x->m->y, moderated by w       Test 1.000  0.050  0.029 #>   r.cihi #> 1  0.071 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"new_n","dir":"Articles","previous_headings":"","what":"Repeating a Simulation With A Different Sample Size","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"function power4test() also supports redoing analysis using new value sample size (population effect sizes set pop_es). Simply set output power4test first argument, set new value n. example, can repeat simulation test moderation , sample size 200. simply call power4test() , set previous output (out2 example moderation) first argument, set n new value (200 example): estimated power sample size 200. estimated power 0.527, 95% confidence interval [0.479; 0.576], sample size 200. technique can repeated find required sample size target power, can used scenarios covered , mediation moderated-mediation.","code":"out2_new_n <- power4test(out2,                          n = 200) out2_new_n out2_new_n_reject <- rejection_rates(out2_new_n) out2_new_n_reject #>                    test test_label   p.v reject r.cilo r.cihi #> 1 test_moderation: CIs       y~x:w 1.000  0.527  0.479  0.576 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"find-the-sample-size-with-desired-power","dir":"Articles","previous_headings":"","what":"Find the Sample Size With Desired Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"two efficient ways find sample size desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"using-power4test_by_n","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using power4test_by_n()","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"First, function power4test_by_n() can used estimate power sequence sample sizes. example, can estimate power moderation model sample sizes: 250, 300, 350, 400. first argument output power4test() arbitrary sample size. argument n numeric vector sample sizes examine. argument by_seed, set integer, try make results reproducible. call take times run equivalent calling power4test() sample size. rejection rates sample size can retrieved rejection_rates() : results show , power .800 detect moderation effect, sample size 350 needed. Please refer help page power4test_by_n() examples.","code":"out2_several_ns <- power4test_by_n(out2,                                    n = c(250, 300, 350, 400),                                    by_seed = 4567) rejection_rates(out2_several_ns) #>     n                  test test_label   p.v reject r.cilo r.cihi #> 1 250 test_moderation: CIs       y~x:w 1.000  0.660  0.614  0.706 #> 2 300 test_moderation: CIs       y~x:w 1.000  0.733  0.689  0.776 #> 3 350 test_moderation: CIs       y~x:w 1.000  0.810  0.772  0.848 #> 4 400 test_moderation: CIs       y~x:w 1.000  0.850  0.815  0.885 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"using-x_from_power","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using x_from_power()","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Second, function x_from_power() can used systematically search within interval sample size target power. takes longer run , instead manually trying different sample size, function search automatically. See article illustration use x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"other-advanced-features","dir":"Articles","previous_headings":"","what":"Other Advanced Features","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"brief illustration covers basic features power4mome. advanced features covered articles: inherent restriction form model. Typical models can specified lavaan model syntax can population model, although may special models power4test yet support. population model can model latent factors indicators. Nevertheless, users can specify relation among factors. need include indicators model syntax, also need manually specify factor loadings. number indicators factor factor loadings set argument number_of_indicators reliability (see help page sim_data() set ). model syntax used fit data automatically include indicators. Though illustrated , estimating power tests conducted nonparametric bootstrapping supported, although take longer run. Although package focuses moderation, mediation, moderated-mediation, principle, power test can estimated, long test function test_fun available. functions provided power4mome (e.g., test_parameters() testing free model parameters). See help page do_test() write function test available power4mome. estimating power, usually population model fitted data. However, possible fit model generated data. can done using argument fit_model_args set argument model fit_model(). Preliminary support multigroup model available. See help pages ptable_pop() pop_es_yaml() specify population value syntax. Functions added tests relevant multigroup models (e.g., testing -group difference indirect effect). Although illustrated rerunning analysis new sample size (n), also possible rerun analysis using new population value parameter. can done using previous output power4test() first argument, setting pop_es named vector: Basic support generating nonnormal variables, including dichotomous variables available. See argument x_fun power4test() details.","code":"out2_new_xw <- power4test(out2,                           pop_es = c(\"y ~ x:w\" = \".30\"))"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Monte Carlo confidence interval supported models fitted lm() (regression). estimate power testing mediation moderated-mediation effects models fitted lm(), ci_type = \"boot\" needed.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis for Latent Variable Mediation","text":"article brief illustration use power4test() package power4mome power analysis mediation effect among latent factors model fitted structural equation model modeling using lavaan.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Power Analysis for Latent Variable Mediation","text":"Basic knowledge fitting models lavaan required. Readers also expected basic knowledge mediation structural equation modeling.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Power Analysis for Latent Variable Mediation","text":"make vignette self-contained, sections vignette(\"power4mome\") repeated . power analysis mediation effect path model latent factors, please refer vignette(\"power4mome\").","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Power Analysis for Latent Variable Mediation","text":"introduction needs following package:","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Power Analysis for Latent Variable Mediation","text":"Two functions sufficient estimating power given model, population values, sample size, test used. basic workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified. Call rejection_rates() compute power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Power Analysis for Latent Variable Mediation","text":"Let’s consider simple mediation model three factors. like estimate power testing mediation effect Monte Carlo confidence interval.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Power Analysis for Latent Variable Mediation","text":"model latent factor, need specify model syntax factors. need include measurement part indicators. model syntax: latent variables fx, fm, fy. indirect path fx fy, fm. Note , even going test mediation effect, need add labels model. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" fm ~ fx fy ~ fm + fx \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Power Analysis for Latent Variable Mediation","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path fx fm “large” strength. path fm fy “large” strength. path fx fm “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (correlations -called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : string denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified string, set zero.","code":"mod_es <- \" fm ~ fx: l fy ~ fm: l fy ~ fx: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"measurement","dir":"Articles","previous_headings":"Mediation","what":"Specify the Measurement Part","title":"Power Analysis for Latent Variable Mediation","text":"Power analysis usually conducted data collection. rarely know advance factor loadings items. purpose power analysis, intended conducted knowledge factor loadings, believe , instead specify explicitly loadings, sufficient specify two values factor: number indicators. population reliability. approach used power4mome. factor, population standardized factor loadings indicator derived automatically hypothesized (expected) population reliability number indicators, assuming indicators equal loadings. Although equal-loading unrealistic, priori power analysis, difficult, impossible, specify pattern factor loadings. level details also necessary power estimated merely used guide planning data collection, instead estimating “true” power data collected. Two argument used set number indicators reliability. number_of_indicators: named vector number indicators factor. names names factors appeared model syntax, values number indicators. reliability: named vector reliability factor. names names factors appeared model syntax, values population reliability. example, suppose use following vectors: numbers indicators fx, fm, fy 4, 3, 5, respectively. population reliability coefficients fx, fm, fy .50, .60, .70, respectively. real research, reliability low .50 can problematic. chose values merely illustration orders intentionally arbitrary, demonstrate order matter. names used interpret numbers correctly.","code":"k <- c(fm = 3, fx = 4, fy = 5) mod_rel <- c(fy = .70, fm = .60, fx = .50)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Latent Variable Mediation","text":"set can call power4test() check model: arguments used: nrep: number replications. stage, small number can used. important large sample size many replications. model: model syntax. pop_es: string setting population values. number_of_indicators: named vector number indicators factor, described previous section. reliability: named vector population reliability factor, described previous section. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown printing object: default, population model fitted dataset, hence section <fit>. fit “perfect” model saturated model. However, p-value high significant (, population model fitted, chance significant close .05). Although specify structure latent factors, can see automatically generated measurement part syntax section Model Variables/Indicators: confirmed specified measurement part correctly. check section Population Values see whether values expected. example, population values regression paths specified. different expect, check string pop_es see whether set population values correctly. section Variances: shows variances error variances latent factors. fm fy endogenous factors, values presented, next .fm .fy, error variances, ’s 1, unlike fx. section Population Reliability shows population reliability coefficients: values set reliability. section Population Standardized Loadings shows standardized factor loadings factor. one value factor loadings assumed items: necessary, can check data generation adding data_long = TRUE printing output: Two new sections printed. first one: section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics indicators. expected, means close zero standard deviations close one, datasets generated using standardized model. second one: section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. results show specified population model correctly. can proceed specify test estimate power.","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   number_of_indicators = k,                   reliability = mod_rel,                   n = 50000,                   iseed = 1234) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> == Model on Variables/Indicators == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   fm ~                        #>     fx                0.500   #>   fy ~                        #>     fm                0.500   #>     fx                0.100   #>  #> Variances: #>                    Population #>    .fm                0.750   #>    .fy                0.690   #>     fx                1.000   #>  #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #>  #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 44 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        27 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                38.042 #>   Degrees of freedom                                51 #>   P-value (Chi-square)                           0.910 #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 print(out,       data_long = TRUE) #> ==== Descriptive Statistics ==== #>  #>     vars     n mean   sd  skew kurtosis se #> fm1    1 1e+05 0.00 1.00  0.01     0.00  0 #> fm2    2 1e+05 0.01 1.00  0.01    -0.01  0 #> fm3    3 1e+05 0.00 1.01  0.00    -0.02  0 #> fx1    4 1e+05 0.00 1.00  0.00     0.00  0 #> fx2    5 1e+05 0.00 1.00 -0.01     0.00  0 #> fx3    6 1e+05 0.00 1.00 -0.01    -0.02  0 #> fx4    7 1e+05 0.00 1.00  0.00     0.00  0 #> fy1    8 1e+05 0.00 1.00  0.01     0.01  0 #> fy2    9 1e+05 0.00 1.00  0.01     0.00  0 #> fy3   10 1e+05 0.00 1.00  0.00     0.01  0 #> fy4   11 1e+05 0.01 1.00  0.01     0.00  0 #> fy5   12 1e+05 0.00 1.00  0.02    -0.01  0 #> fy5   12 1e+05 0.00 1.00  0.02    -0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Latent Variables: #>                     est.std #>   fm =~                     #>     fm1               0.578 #>     fm2               0.579 #>     fm3               0.578 #>   fx =~                     #>     fx1               0.445 #>     fx2               0.443 #>     fx3               0.445 #>     fx4               0.445 #>   fy =~                     #>     fy1               0.559 #>     fy2               0.560 #>     fy3               0.563 #>     fy4               0.565 #>     fy5               0.569 #>  #> Regressions: #>                     est.std #>   fm ~                      #>     fx                0.504 #>   fy ~                      #>     fm                0.505 #>     fx                0.097"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Power Analysis for Latent Variable Mediation","text":"can now simulation estimate power. large number datasets (e.g., 400) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect fx fy fm, sample size 150. call: new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. real studies, number 10000 even 20000 Monte Carlo confidence intervals. However, 2000 sufficient goal estimate power generating many intervals, rather one single stable interval. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-functions common tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case tests done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 nrep = 400, 95% confidence limits power .80 .04 .80. precise enough determining whether sample size sufficient power. default printout:","code":"out <- power4test(nrep = 400,                   model = mod,                   pop_es = mod_es,                   number_of_indicators = k,                   reliability = mod_rel,                   n = 150,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"fx\",                                    m = \"fm\",                                    y = \"fy\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> == Model on Variables/Indicators == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   fm ~                        #>     fx                0.500   #>   fy ~                        #>     fm                0.500   #>     fx                0.100   #>  #> Variances: #>                    Population #>    .fm                0.750   #>    .fy                0.690   #>     fx                1.000   #>  #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #>  #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  150  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 38 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        27 #>  #>   Number of observations                           150 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                69.181 #>   Degrees of freedom                                51 #>   P-value (Chi-square)                           0.046 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: fx->fm->fy #>  #> Call print() and set 'test_long = TRUE' for a detailed report."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"compute-the-power","dir":"Articles","previous_headings":"Mediation","what":"Compute the Power","title":"Power Analysis for Latent Variable Mediation","text":"power estimate simply proportion significant results, rejection rate, null hypothesis false. rejection rate can retrieved rejection_rates(). example , estimated power test indirect effect, conducted Monte Carlo confidence interval, 0.492, column reject. p.v proportion valid results across replications. 1.000 means test conducted normally replications. default, 95% confidence interval rejection rate (power) based normal approximation also printed, column r.cilo r.cihi. example, 95% confidence interval [0.444; 0.541].","code":"out_power <- rejection_rates(out) out_power #>                        test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: fx->fm->fy       Test 1.000  0.492  0.444  0.541 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"new_n","dir":"Articles","previous_headings":"","what":"Repeat a Simulation With A Different Sample Size","title":"Power Analysis for Latent Variable Mediation","text":"function power4test() also supports redoing analysis using new value sample size (population effect sizes set pop_es). Simply set output power4test first argument, set new value n. example, can repeat simulation test indirect effect, smaller sample size 100. simply call power4test() , set previous output (example moderation) first argument, set n new value (100 example): estimated power sample size 200. estimated power 0.815, 95% confidence interval [0.777; 0.853], sample size 200. technique can repeated find required sample size target power.","code":"out_new_n <- power4test(out,                         n = 200) out_new_n out_new_n_reject <- rejection_rates(out_new_n) out_new_n_reject #>                        test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: fx->fm->fy       Test 1.000  0.815  0.777  0.853 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"repeat-a-simulation-with-different-numbers-of-indicators-or-reliability","dir":"Articles","previous_headings":"","what":"Repeat a Simulation With Different Numbers of Indicators or Reliability","title":"Power Analysis for Latent Variable Mediation","text":"can also redo analysis using new values reliability. know power low 150 cases. may want see whether can higher power use reliable scales. previous example, just call power4test() one original output, set reliability new vector. Assume want know power scenario, scales population reliability .80: estimated power higher population reliability: estimated power 0.985, 95% confidence interval [0.973; 0.997], much higher original scenario.","code":"out_new_rel <- power4test(out,                           reliability = c(fx = .80,                                           fm = .80,                                           fy = .80)) out_new_rel out_new_rel_reject <- rejection_rates(out_new_rel) out_new_rel_reject #>                        test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: fx->fm->fy       Test 1.000  0.985  0.973  0.997 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"find-the-sample-size-with-desired-power","dir":"Articles","previous_headings":"","what":"Find the Sample Size With Desired Power","title":"Power Analysis for Latent Variable Mediation","text":"two efficient ways find sample size desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"using-power4test_by_n","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using power4test_by_n()","title":"Power Analysis for Latent Variable Mediation","text":"First, function power4test_by_n() can used estimate power sequence sample sizes. example, suppose know power .80 sample size 200. can estimate power mediation model sample sizes: 175, 200, 225, 250. first argument output power4test() arbitrary sample size. argument n numeric vector sample sizes examine. n, nrep datasets generated. Although limit number sample sizes try, recommended restrict number sample sizes 5 less. argument by_seed, set integer, try make results reproducible. call take times run equivalent calling power4test() sample size. rejection rates sample size can retrieved rejection_rates() : results show , power .800 detect mediation effect, sample size 200 needed. Please refer help page power4test_by_n() examples.","code":"out_several_ns <- power4test_by_n(out,                                   n = c(175, 200, 225, 250),                                   by_seed = 4567) rejection_rates(out_several_ns) #>     n                      test test_label   p.v reject r.cilo r.cihi #> 1 175 test_indirect: fx->fm->fy       Test 1.000  0.703  0.658  0.747 #> 2 200 test_indirect: fx->fm->fy       Test 1.000  0.830  0.793  0.867 #> 3 225 test_indirect: fx->fm->fy       Test 1.000  0.892  0.862  0.923 #> 4 250 test_indirect: fx->fm->fy       Test 1.000  0.902  0.873  0.932 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"using-x_from_power","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using x_from_power()","title":"Power Analysis for Latent Variable Mediation","text":"Second, function x_from_power() can used systematically search within interval sample size target power. takes longer run , instead manually trying different sample size, function search automatically. See article illustration use x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"other-scenarios","dir":"Articles","previous_headings":"","what":"Other Scenarios","title":"Power Analysis for Latent Variable Mediation","text":"scenarios, moderation moderated-mediation, please refer vignette(\"power4mome\").","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflow of `power4test()`","text":"technical appendix describes workflow power4test() power4mome.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_workflow.html","id":"from-population-to-power-power4test","dir":"Articles","previous_headings":"","what":"From Population to Power (power4test())","title":"Workflow of `power4test()`","text":"main power4test() can tasks one call: Generate nrep datasets (nrep replications) based population model values population parameters (“effect sizes”) (conducted sim_data()). Fit one models datasets (conducted fit_model()). (Optional) Generate Monte Carlo bootstrap estimates based fitted model(s), tests methods Monte Carlo bootstrap confidence intervals (conducted gen_mc() gen_boot()). (Optional) one tests model fit results (conducted do_test()). Return power4test() object. Power can estimated conducted tests functions rejection_rates(). following workflow: Population Power","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/sim_data_i_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflows of `sim_data_i()","text":"technical appendix describes workflow internal function sim_data_i() power4mome.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/sim_data_i_workflow.html","id":"generate-simulated-data-sim_data_i","dir":"Articles","previous_headings":"","what":"Generate Simulated Data (sim_data_i())","title":"Workflows of `sim_data_i()","text":"internal function sim_data_i() called m times sim_data() generate m datasets. workflow sim_data_i(): Workflow sim_data_i() generating many datasets, steps need repeated. Therefore, required objects (e.g., parameter table) supplied sim_data(), sim_data_i() data generation.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Mediation with Observed Variables","text":"“Quick Template” vignettes examples R code power analysis determine sample size typical models using power4mome. Users can quickly adapt scenarios.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), power4test_by_n(), x_from_power(), refer Get-Started article, article finding sample size given desired power using x_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Mediation with Observed Variables","text":"file simple mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Mediation with Observed Variables","text":"Estimate power sample size. code: results:","code":"library(power4mome) # # ====== Model: Form ====== model <- \" m ~ x y ~ m + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) model_es <- \" m ~ x: s y ~ m: l y ~ x: m \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #> #> ====================== Model Information ====================== #> #> == Model on Factors/Variables == #> #> m ~ x #> y ~ m + x #> #> == Model on Variables/Indicators == #> #> m ~ x #> y ~ m + x #> #> ====== Population Values ====== #> #> Regressions: #>                    Population #>   m ~ #>     x                 0.100 #>   y ~ #>     m                 0.500 #>     x                 0.300 #> #> Variances: #>                    Population #>    .m                 0.990 #>    .y                 0.630 #>     x                 1.000 #> #> ======================= Data Information ======================= #> #> Number of Replications:  400 #> Sample Sizes:  100 #> #> ==== Descriptive Statistics ==== #> #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01    -0.01 0.01 #> y    2 40000 -0.01  1 -0.02    -0.03 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #> #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #> #> Total Sample Size: 40000 #> #> ==== Standardized Estimates ==== #> #> Variances and error variances omitted. #> #> Regressions: #>                     est.std #>   m ~ #>     x                 0.099 #>   y ~ #>     m                 0.499 #>     x                 0.305 #> #> #> ==================== Extra Element(s) Found ==================== #> #> - fit #> - mc_out #> #> === Element(s) of the First Dataset === #> #> ============ <fit> ============ #> #> lavaan 0.6-19 ended normally after 1 iteration #> #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #> #>   Number of observations                           100 #> #> Model Test User Model: #> #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #> #> =========== <mc_out> =========== #> #> #> == A 'mc_out' class object == #> #> Number of Monte Carlo replications: 1000 #> #> #> ====================== Test(s) Conducted ====================== #> #> - test_indirect: x->m->y #> #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #>                     test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: x->m->y       Test 1.000  0.195  0.156  0.234 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-another-n","dir":"Articles","previous_headings":"","what":"Try Another N","title":"Quick Template: Mediation with Observed Variables","text":"rerun simulation estimate power another sample size. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 150 # Set n to 150 out_new_n <- power4test(out,                         n = 150) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #>                     test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: x->m->y       Test 1.000  0.290  0.246  0.334 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-several-ns","dir":"Articles","previous_headings":"","what":"Try Several N’s","title":"Quick Template: Mediation with Observed Variables","text":"Rerun simulation estimate power several sample sizes. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 200, 250, 300 # Use power4test_by_n() out_ns <- power4test_by_n(out,                           n = c(200, 250, 300),                           by_seed = 5789) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_ns) rejection_rates(out_ns) #>     n                   test test_label   p.v reject r.cilo r.cihi #> 1 200 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368 #> 2 250 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368 #> 3 300 test_indirect: x->m->y       Test 1.000  0.445  0.396  0.494 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"search-n-with-target-power","dir":"Articles","previous_headings":"","what":"Search N With Target Power","title":"Quick Template: Mediation with Observed Variables","text":"Search, simulation, sample size estimated power close target level (e.g., .80).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"use-the-output-of-power4test","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test()","title":"Quick Template: Mediation with Observed Variables","text":"step calling power4test() sample size. can take time run estimated power sample size different target power. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call x_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80 <- x_from_power(out,                            x = \"n\",                            seed = 1357) # # ===== Print the Summary ===== summary(n_power_80) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80) # # ===== Print the Summary ===== summary(n_power_80) #> #> ====== x_from_power Results ====== #> #> Call: #> x_from_power(object = out, x = \"n\", seed = 1357) #> Predictor (x): Sample Size #> #> - Target Power: 0.800 #> #> === Major Results === #> #> - Final Value: 849 #> - Final Estimated Power: 0.807 #> - Confidence Interval: [0.769; 0.846] #> - Level of confidence: 95.0% #> - Based on 400 replications. #> #> === Technical Information === #> #> - The range of values explored: 100 to 849 #> - Time spent in the search: 2.26 mins #> - The final crude model for the power-predictor relation: #> #> Model Type: Logistic Regression #> #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start, #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args, #>     nls_control = nls_control, verbose = progress) #> #> Predictor: n (Sample Size) #> #> Model: #> #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #> #> Coefficients: #> (Intercept)            x #>    -1.88634      0.00472 #> #> Degrees of Freedom: 599 Total (i.e. Null);  598 Residual #> Null Deviance:       701.9 #> Residual Deviance: 661.5     AIC: 665.5 #> #> - Detailed Results: #> #>      n                   test test_label   p.v reject r.cilo r.cihi #> 1  100 test_indirect: x->m->y       Test 1.000  0.195  0.156  0.234 #> 2  255 test_indirect: x->m->y       Test 1.000  0.340  0.247  0.433 #> 3  410 test_indirect: x->m->y       Test 1.000  0.510  0.412  0.608 #> 4  586 test_indirect: x->m->y       Test 1.000  0.672  0.627  0.718 #> 5  645 test_indirect: x->m->y       Test 1.000  0.750  0.665  0.835 #> 6  692 test_indirect: x->m->y       Test 1.000  0.755  0.713  0.797 #> 7  693 test_indirect: x->m->y       Test 1.000  0.739  0.678  0.800 #> 8  694 test_indirect: x->m->y       Test 1.000  0.720  0.632  0.808 #> 9  750 test_indirect: x->m->y       Test 1.000  0.780  0.699  0.861 #> 10 849 test_indirect: x->m->y       Test 1.000  0.807  0.769  0.846 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"use-the-output-of-power4test_by_n","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test_by_n()","title":"Quick Template: Mediation with Observed Variables","text":"step calling power4test_by_n() sample size. Continue search using output several sample sizes calling x_from_power() output power4test_by_n(). can take time run estimated levels power sample sizes different target power. code: results: Power Curve","code":"# # ===== Reuse the output of power4test_by_n() ===== # Call x_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ns <- x_from_power(out_ns,                               x = \"n\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ns) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns) # # ===== Print the Summary ===== summary(n_power_80_ns) #> #> ====== x_from_power Results ====== #> #> Call: #> x_from_power(object = out_ns, x = \"n\", seed = 1357) #> Predictor (x): Sample Size #> #> - Target Power: 0.800 #> #> === Major Results === #> #> - Final Value: 910 #> - Final Estimated Power: 0.833 #> - Confidence Interval: [0.796; 0.869] #> - Level of confidence: 95.0% #> - Based on 400 replications. #> #> === Technical Information === #> #> - The range of values explored: 200 to 910 #> - Time spent in the search: 2.19 mins #> - The final crude model for the power-predictor relation: #> #> Model Type: Logistic Regression #> #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start, #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args, #>     nls_control = nls_control, verbose = progress) #> #> Predictor: n (Sample Size) #> #> Model: #> #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #> #> Coefficients: #> (Intercept)            x #>   -1.608780     0.004152 #> #> Degrees of Freedom: 1399 Total (i.e. Null);  1398 Residual #> Null Deviance:       1879 #> Residual Deviance: 1830  AIC: 1834 #> #> - Detailed Results: #> #>      n                   test test_label   p.v reject r.cilo r.cihi #> 1  200 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368 #> 2  250 test_indirect: x->m->y       Test 1.000  0.323  0.277  0.368 #> 3  300 test_indirect: x->m->y       Test 1.000  0.445  0.396  0.494 #> 4  420 test_indirect: x->m->y       Test 1.000  0.540  0.442  0.638 #> 5  539 test_indirect: x->m->y       Test 1.000  0.630  0.535  0.725 #> 6  594 test_indirect: x->m->y       Test 1.000  0.685  0.639  0.731 #> 7  666 test_indirect: x->m->y       Test 1.000  0.770  0.688  0.852 #> 8  721 test_indirect: x->m->y       Test 1.000  0.804  0.749  0.859 #> 9  722 test_indirect: x->m->y       Test 1.000  0.733  0.689  0.776 #> 10 785 test_indirect: x->m->y       Test 1.000  0.842  0.770  0.913 #> 11 910 test_indirect: x->m->y       Test 1.000  0.833  0.796  0.869 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, set m ~ x path y ~ m path medium (.30) (population indirect effect .09). code: results: illustration, go directly searching x_from_power(): code: results: Power Curve","code":"model_es2 <- \" m ~ x: m y ~ m: m y ~ x: m \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effect,                    test_args = list(x = \"x\",                                     m = \"m\",                                     y = \"y\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #> #> ====================== Model Information ====================== #> #> == Model on Factors/Variables == #> #> m ~ x #> y ~ m + x #> #> == Model on Variables/Indicators == #> #> m ~ x #> y ~ m + x #> #> ====== Population Values ====== #> #> Regressions: #>                    Population #>   m ~ #>     x                 0.300 #>   y ~ #>     m                 0.300 #>     x                 0.300 #> #> Variances: #>                    Population #>    .m                 0.910 #>    .y                 0.766 #>     x                 1.000 #> #> ======================= Data Information ======================= #> #> Number of Replications:  400 #> Sample Sizes:  100 #> #> ==== Descriptive Statistics ==== #> #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01     0.00 0.01 #> y    2 40000 -0.01  1 -0.01    -0.01 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #> #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #> #> Total Sample Size: 40000 #> #> ==== Standardized Estimates ==== #> #> Variances and error variances omitted. #> #> Regressions: #>                     est.std #>   m ~ #>     x                 0.299 #>   y ~ #>     m                 0.298 #>     x                 0.306 #> #> #> ==================== Extra Element(s) Found ==================== #> #> - fit #> - mc_out #> #> === Element(s) of the First Dataset === #> #> ============ <fit> ============ #> #> lavaan 0.6-19 ended normally after 1 iteration #> #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #> #>   Number of observations                           100 #> #> Model Test User Model: #> #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #> #> =========== <mc_out> =========== #> #> #> == A 'mc_out' class object == #> #> Number of Monte Carlo replications: 1000 #> #> #> ====================== Test(s) Conducted ====================== #> #> - test_indirect: x->m->y #> #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #>                     test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: x->m->y       Test 1.000  0.745  0.702  0.788 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Reuse the output of power4test() ===== n2_power_80 <- x_from_power(out2,                             x = \"n\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_80) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80) # # ===== Print the Summary ===== summary(n2_power_80) #> #> ====== x_from_power Results ====== #> #> Call: #> x_from_power(object = out2, x = \"n\", seed = 1357) #> Predictor (x): Sample Size #> #> - Target Power: 0.800 #> #> === Major Results === #> #> - Final Value: 110 #> - Final Estimated Power: 0.812 #> - Confidence Interval: [0.774; 0.851] #> - Level of confidence: 95.0% #> - Based on 400 replications. #> #> === Technical Information === #> #> - The range of values explored: 96 to 127 #> - Time spent in the search: 2.156 mins #> - The final crude model for the power-predictor relation: #> #> Model Type: Logistic Regression #> #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start, #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args, #>     nls_control = nls_control, verbose = progress) #> #> Predictor: n (Sample Size) #> #> Model: #> #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #> #> Coefficients: #> (Intercept)            x #>    -2.39667      0.03479 #> #> Degrees of Freedom: 599 Total (i.e. Null);  598 Residual #> Null Deviance:       663.6 #> Residual Deviance: 662.6     AIC: 666.6 #> #> - Detailed Results: #> #>     n                   test test_label   p.v reject r.cilo r.cihi #> 1  96 test_indirect: x->m->y       Test 1.000  0.780  0.739  0.821 #> 2 100 test_indirect: x->m->y       Test 1.000  0.745  0.702  0.788 #> 3 102 test_indirect: x->m->y       Test 1.000  0.770  0.688  0.852 #> 4 104 test_indirect: x->m->y       Test 1.000  0.790  0.710  0.870 #> 5 107 test_indirect: x->m->y       Test 1.000  0.780  0.699  0.861 #> 6 109 test_indirect: x->m->y       Test 1.000  0.755  0.695  0.815 #> 7 110 test_indirect: x->m->y       Test 1.000  0.812  0.774  0.851 #> 8 116 test_indirect: x->m->y       Test 1.000  0.876  0.813  0.939 #> 9 127 test_indirect: x->m->y       Test 1.000  0.863  0.829  0.896 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Effect Size Given Desired Power","text":"article brief illustration use x_from_power() power4test() package power4mome find simulation, given sample size factors, given desired power, minimum effect size detected level power (see note “minimum”). illustration use indirect effect tested Monte Carlo confidence interval example, though procedure similar tests supported power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Effect Size Given Desired Power","text":"Basic knowledge fitting models lavaan required. Readers also expected know use power4test() (see get-started introduction).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Effect Size Given Desired Power","text":"brief illustration. complicated scenarios features x_from_power() described vignettes. sections repeated vignettes make vignette self-contained.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Effect Size Given Desired Power","text":"illustration needs following package(s):","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Effect Size Given Desired Power","text":"Three functions, along methods, sufficient estimating sample size, given desired power, along factors test, model, sample size. basic workflow: Specify model syntax population model, lavaan style, set initial population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified, using sample size examined. Call rejection_rates() compute power verify test setup correctly. Call x_from_power() estimated minimum effect size can detected, given factors, including sample size examined target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Effect Size Given Desired Power","text":"Let’s consider simple mediation model, effect concern indirect effect tested Monte Carlo confidence interval. special consideration regarding indirect effect: effect function two model parameters. example, simple mediation -path predictor mediator, b-path mediator outcome variable, indirect effect ab. found power detect particular value ab, say 0.25, combinations b. example, Kenny & Judd (2014) found required sample size power .80 detect ab .0225 can vary 450 large 5000, depending values b. Therefore, even like find minimum ab can detected power .80 given sample size, still manipulate one parameter (e.g., b) one time. Two additional notes notion “minimum”. First, simplicity, positive population values considered. However, may cases population values consideration negative. cases, “minimum” refers minimum magnitude. Second, may cases , even keeping values considered positive, relation power parameter varied U-shaped. cases, two values selected parameters may target power. plot relation (described lated) examined see whether solution likely minimum value range examined. illustrated vignette.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Effect Size Given Desired Power","text":"model syntax Note , even going test mediation, need add labels defined user-parameters. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Effect Size Given Desired Power","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (-called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : word denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified, set zero.","code":"mod_es <- \" m ~ x: m y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Effect Size Given Desired Power","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown print object: argument data_long = TRUE used verify simulation. population values regression paths section Population Values specified. model specified correctly. section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. default, population model fitted dataset, hence section <fit>. section just verifies population can fitted results show population model desired one. can proceed next stage","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) print(out,       data_long = TRUE) #>  #> ============================== Model Information ============================== #>  #> ====== Model on Factors/Variables ====== #>  #> m ~ x #> y ~ m + x #>  #> ==== Model on Variables/Indicators ==== #>  #> m ~ x #> y ~ m + x #>  #> ========== Population Values ========== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.882   #>     x                 1.000   #>  #> =============================== Data Information =============================== #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ======== Descriptive Statistics ======== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ============= Parameter Estimates Based on All 2 Samples Combined ============= #>  #> Total Sample Size: 100000  #>  #> ======== Standardized Estimates ======== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.301 #>   y ~                       #>     m                 0.295 #>     x                 0.101 #>  #>  #> ============================ Extra Element(s) Found ============================ #>  #> - fit #>  #> ======== Element(s) of the First Dataset ======== #>  #> ================ <fit> ================ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Effect Size Given Desired Power","text":"can now simulation estimate power initial values (m ~ x) b (y ~ m), given target sample size verify test want . large number datasets (e.g., 500) target sample size initial population values model generated, target test conducted datasets. Suppose start hold b medium (.30) direct effect (y ~ x) small (.10), sample size 100, like estimate power using Monte Carlo confidence interval test indirect effect x y m, also medium. call, based previous one: goal find value parameter, case, specific level power sample size, sufficient precision, need large number replications (nrep) stage. can use 50. can set target number replications calling function x_from_power(). successively increase nrep search, accepts solution based target number replications. new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-function tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case test done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 Note simulation can take time run (3 4 minutes using 20 cores). Progress printed run interactive session. default printout: argument test_long = TRUE added verify test set . shown , setup correct. can now call x_from_power() search.","code":"out <- power4test(nrep = 50,                   model = mod,                   pop_es = mod_es,                   n = 100,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) print(out,       test_long = TRUE) #>  #> ============================== Model Information ============================== #>  #> ====== Model on Factors/Variables ====== #>  #> m ~ x #> y ~ m + x #>  #> ==== Model on Variables/Indicators ==== #>  #> m ~ x #> y ~ m + x #>  #> ========== Population Values ========== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.882   #>     x                 1.000   #>  #> =============================== Data Information =============================== #>  #> Number of Replications:  50  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ============================ Extra Element(s) Found ============================ #>  #> - fit #> - mc_out #>  #> ======== Element(s) of the First Dataset ======== #>  #> ================ <fit> ================ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =============== <mc_out> =============== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== <test_indirect: x->m->y> ====================== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.086 0.014 0.180 0.720 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 50  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"call-x_from_power-to-estimate-the-minimum-value-of-a","dir":"Articles","previous_headings":"Mediation","what":"Call x_from_power() to Estimate the Minimum Value of a","title":"Effect Size Given Desired Power","text":"simplified description x_from_power() works: rerun simulation test output power4test() different values selected parameter, estimate power levels . try estimate relation power value selected parameter, select next value(s) try. adopt value solution () confidence interval estimated power includes target power (default level 95%), (b) number replications used estimation target one (ensure standard error desired level). argument used : x: want find, \"es\" stands effect sizes. pop_es_name: name parameter value varied. name one used lavaan using coef(). See power4test_by_es() setting name. target_power: target power. Default .80. final_nrep: number replications desired solution. using normal approximation form 95% confidence interval sample proportion (power case). nrep = 400, 95% confidence limits power .80 .04 .80. precise enough estimating sample size required. seed: make search reproducible, possible, set seed integer.","code":"out_es_a <- x_from_power(out,                          x = \"es\",                          pop_es_name = \"m~x\",                          target_power = .80,                          final_nrep = 400,                          seed = 4567)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"examine-the-output","dir":"Articles","previous_headings":"Mediation","what":"Examine the Output","title":"Effect Size Given Desired Power","text":"basic output: estimated value power close .80 power detect indirect effect (ab, b equal .30 population) Monte Carlo interval 0.410. estimated power based simulation 0.835. , given model sample size 100, population value b medium (.30), test approximate power .80 population value 0.410. corresponding indirect effect 0.123 obtain detailed results search, can use summary() method: reports 95% confidence interval estimated power, [0.799; 0.871]. also reports major technical information regarding search, range values tried, time spent, table values examined, along estimated power levels confidence intervals. also prints model, “power curve”, used estimate relation power value selected parameter. Note crude model intended values examined. intended estimate power values outside range studied. Even though model crude one, can still give rough idea relation. simple plot can requested plot(): Power Curve black line plot sample sizes studied, along estimated power levels 95% confidence intervals. intervals vary width different number replications. red line plot based model (logistic model case), along range sample sizes examined.","code":"out_es_a #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"m~x\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #> Predictor (x): Effect Size  #> Parameter Name (pop_es_name): m~x  #> - Target Power: 0.800  #> - Final Value: 0.410  #> - Final Estimated Power: 0.835  #> Call `summary()` for detailed results. summary(out_es_a) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"m~x\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #> Predictor (x): Effect Size  #> Parameter Name (pop_es_name): m~x  #>  #> - Target Power: 0.800  #>  #> === Major Results === #>  #> - Final Value: 0.410  #> - Final Estimated Power: 0.835  #> - Confidence Interval: [0.799; 0.871] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - The range of values explored: 0.176930746349867 to 0.507444912661905  #> - Time spent in the search: 2.101 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      0.2416       2.7801   #>  #> Degrees of Freedom: 249 Total (i.e. Null);  248 Residual #> Null Deviance:       277.8  #> Residual Deviance: 277.8     AIC: 281.8 #>  #> - Detailed Results: #>  #>    par    es                   test test_label   p.v reject r.cilo r.cihi #> 1  m~x 0.177 test_indirect: x->m->y       Test 1.000  0.380  0.332  0.428 #> 2  m~x 0.284 test_indirect: x->m->y       Test 1.000  0.733  0.689  0.776 #> 3  m~x 0.300 test_indirect: x->m->y       Test 1.000  0.720  0.596  0.844 #> 4  m~x 0.317 test_indirect: x->m->y       Test 1.000  0.780  0.699  0.861 #> 5  m~x 0.329 test_indirect: x->m->y       Test 1.000  0.700  0.610  0.790 #> 6  m~x 0.333 test_indirect: x->m->y       Test 1.000  0.750  0.665  0.835 #> 7  m~x 0.410 test_indirect: x->m->y       Test 1.000  0.835  0.799  0.871 #> 8  m~x 0.412 test_indirect: x->m->y       Test 1.000  0.800  0.745  0.855 #> 9  m~x 0.414 test_indirect: x->m->y       Test 1.000  0.870  0.804  0.936 #> 10 m~x 0.507 test_indirect: x->m->y       Test 1.000  0.740  0.654  0.826 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the rejection rate.If #>   the null hypothesis is true, this is the Type I error rate. If the null hypothesis is #>   false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based on normal #>   approximation. #> - Refer to the tests for the meanings of other columns. plot(out_es_a)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"finding-the-minimum-value-of-b-when-holding-a-to--30","dir":"Articles","previous_headings":"Mediation","what":"Finding the Minimum Value of b When Holding a to .30","title":"Effect Size Given Desired Power","text":"can also find minimum value b holding medium (.30). Just call x_from_power() , setting pop_es_name \"y~m\". estimated value b power close .80 power detect indirect effect (ab, equal .30 population) Monte Carlo interval 0.340. estimated power based simulation 0.785. , given model sample size 100, population value medium (.30), test approximate power .80 population value b 0.340. corresponding indirect effect 0.102, slightly lower indirect effect b hold .30. detailed results search b varied: reports 95% confidence interval estimated power, [0.745; 0.825]. Power Curve (b varied)","code":"out_es_b <- x_from_power(out,                          x = \"es\",                          pop_es_name = \"y~m\",                          target_power = .80,                          final_nrep = 400,                          seed = 4567) summary(out_es_b) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"y~m\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #> Predictor (x): Effect Size  #> Parameter Name (pop_es_name): y~m  #>  #> - Target Power: 0.800  #>  #> === Major Results === #>  #> - Final Value: 0.340  #> - Final Estimated Power: 0.785  #> - Confidence Interval: [0.745; 0.825] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - The range of values explored: 0.254636767979519 to 0.441595906965659  #> - Time spent in the search: 1.971 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>       -1.26         7.83   #>  #> Degrees of Freedom: 249 Total (i.e. Null);  248 Residual #> Null Deviance:       266  #> Residual Deviance: 265.5     AIC: 269.5 #>  #> - Detailed Results: #>  #>   par    es                   test test_label   p.v reject r.cilo r.cihi #> 1 y~m 0.255 test_indirect: x->m->y       Test 1.000  0.578  0.529  0.626 #> 2 y~m 0.300 test_indirect: x->m->y       Test 1.000  0.720  0.596  0.844 #> 3 y~m 0.309 test_indirect: x->m->y       Test 1.000  0.740  0.654  0.826 #> 4 y~m 0.317 test_indirect: x->m->y       Test 1.000  0.800  0.722  0.878 #> 5 y~m 0.333 test_indirect: x->m->y       Test 1.000  0.780  0.699  0.861 #> 6 y~m 0.338 test_indirect: x->m->y       Test 1.000  0.720  0.658  0.782 #> 7 y~m 0.340 test_indirect: x->m->y       Test 1.000  0.785  0.745  0.825 #> 8 y~m 0.372 test_indirect: x->m->y       Test 1.000  0.840  0.768  0.912 #> 9 y~m 0.442 test_indirect: x->m->y       Test 1.000  0.892  0.862  0.923 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the rejection rate.If #>   the null hypothesis is true, this is the Type I error rate. If the null hypothesis is #>   false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based on normal #>   approximation. #> - Refer to the tests for the meanings of other columns. plot(out_es_b)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"advanced-features","dir":"Articles","previous_headings":"","what":"Advanced Features","title":"Effect Size Given Desired Power","text":"brief illustration covers basic features x_from_power(). ways customize search, range values parameter examine (default 0 0.7), level confidence confidence interval, number trials (10 default). Please refer help page x_from_power() options.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sample Size Given Desired Power","text":"article brief illustration use x_from_power() power4test() package power4mome find simulation sample size power close desired level detect effect, given level population effect size. illustration use indirect effect tested Monte Carlo confidence interval example, though procedure similar tests supported power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Sample Size Given Desired Power","text":"Basic knowledge fitting models lavaan required. Readers also expected know use power4test() (see get-started introduction).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Sample Size Given Desired Power","text":"brief illustration. complicated scenarios features x_from_power() described vignettes. sections repeated vignettes make vignette self-contained.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Sample Size Given Desired Power","text":"illustration needs following package(s):","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Sample Size Given Desired Power","text":"Three functions, along methods, sufficient estimating sample size, given desired power, along factors test, model, population values. basic workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified, using initial sample size. Call rejection_rates() compute power verify test setup correctly. Call x_from_power() estimated sample size required desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Sample Size Given Desired Power","text":"Let’s consider simple mediation model. like estimate sample size required detect mediation effect Monte Carlo confidence interval.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Sample Size Given Desired Power","text":"model syntax Note , even going test mediation. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Sample Size Given Desired Power","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (-called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : word denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Sample Size Given Desired Power","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown print object: argument data_long = TRUE used verify simulation. population values regression paths section Population Values specified. model specified correctly. section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. default, population model fitted dataset, hence section <fit>. section just verifies population can fitted results show population model desired one. can proceed next stage","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Sample Size Given Desired Power","text":"can now simulation estimate power initial sample size, verify test wan . large number datasets (e.g., 500) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect x y m, sample size 50. call, based previous one: goal find sample size specific level power, sufficient precision, need large number replications (nrep) stage. can use 50. can set target number replications calling function x_from_power(). successively increase nrep search, accepts solution based target number replications. new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-function tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case test done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 Note simulation can take time run (3 4 minutes using 20 cores). Progress printed run interactive session. default printout: argument test_long = TRUE added verify test set . shown , setup correct. can now call x_from_power() search.","code":"out <- power4test(nrep = 50,                   model = mod,                   pop_es = mod_es,                   n = 50,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) print(out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  50  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est   cilo  cihi   sig #>  0.139 -0.026 0.337 0.400 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 50  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"call-x_from_power-to-estimate-the-sample-size","dir":"Articles","previous_headings":"Mediation","what":"Call x_from_power() to Estimate the Sample Size","title":"Sample Size Given Desired Power","text":"simplified description x_from_power() works: rerun simulation test output power4test() different sample sizes, estimate power levels . try estimate relation power sample size, select next sample size(s) try. adopt sample size solution () confidence interval estimated power includes target power (default level 95%), (b) number replications used estimation target one (ensure standard error desired level). argument used : x: want find, \"n\" stands sample size. target_power: target power. Default .80. final_nrep: number replications desired solution. using normal approximation form 95% confidence interval sample proportion (power case). nrep = 400, 95% confidence limits power .80 .04 .80. precise enough estimating sample size required. seed: make search reproducible, possible, set seed integer.","code":"out_n <- x_from_power(out,                       x = \"n\",                       target_power = .80,                       final_nrep = 400,                       seed = 1234)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"examine-the-output","dir":"Articles","previous_headings":"Mediation","what":"Examine the Output","title":"Sample Size Given Desired Power","text":"basic output: estimated sample size power close .80 power detect indirect effect Monte Carlo interval 103. estimated power based simulation 0.782. obtain detailed results search, can use summary() method: reports 95% confidence interval estimated power, [0.742; 0.823]. also reports major technical information regarding search, range sample sizes tried, time spent, table sample sizes examined, along estimated power levels confidence intervals. also prints model, “power curve”, used estimate relation power sample size. Note crude model intended values sample size examined. intended estimate power sample sizes outside range studied. Even though model crude one, can still give rough idea relation. simple plot can requested plot(): Power Curve black line plot sample sizes studied, along estimated power levels 95% confidence intervals. intervals vary width different number replications. red line plot based model (logistic model case), along range sample sizes examined.","code":"out_n #> Call: #> x_from_power(object = out, x = \"n\", target_power = 0.8, final_nrep = 400,  #>     seed = 1234) #> Predictor (x): Sample Size  #> - Target Power: 0.800  #> - Final Value: 103  #> - Final Estimated Power: 0.782  #> Call `summary()` for detailed results. summary(out_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"n\", target_power = 0.8, final_nrep = 400,  #>     seed = 1234) #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #>  #> === Major Results === #>  #> - Final Value: 103  #> - Final Estimated Power: 0.782  #> - Confidence Interval: [0.742; 0.823] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - The range of values explored: 50 to 133  #> - Time spent in the search: 1.98 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.59991      0.02858   #>  #> Degrees of Freedom: 249 Total (i.e. Null);  248 Residual #> Null Deviance:       321.8  #> Residual Deviance: 306.2     AIC: 310.2 #>  #> - Detailed Results: #>  #>     n                   test test_label   p.v reject r.cilo r.cihi #> 1  50 test_indirect: x->m->y       Test 1.000  0.400  0.264  0.536 #> 2  75 test_indirect: x->m->y       Test 1.000  0.690  0.599  0.781 #> 3  80 test_indirect: x->m->y       Test 1.000  0.682  0.637  0.728 #> 4  96 test_indirect: x->m->y       Test 1.000  0.720  0.632  0.808 #> 5 100 test_indirect: x->m->y       Test 1.000  0.750  0.665  0.835 #> 6 103 test_indirect: x->m->y       Test 1.000  0.782  0.742  0.823 #> 7 104 test_indirect: x->m->y       Test 1.000  0.856  0.806  0.905 #> 8 114 test_indirect: x->m->y       Test 1.000  0.780  0.699  0.861 #> 9 133 test_indirect: x->m->y       Test 1.000  0.892  0.862  0.923 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. plot(out_n)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"advanced-features","dir":"Articles","previous_headings":"","what":"Advanced Features","title":"Sample Size Given Desired Power","text":"brief illustration cover basic features x_from_power(). ways customize search, range sample sizes examine (default 50 2000), level confidence confidence interval, number trials (10 default). Please refer help page x_from_power() options.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflow of 'x_from_power()'","text":"technical appendix describes workflow x_from_power() power4mome.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"x_from_power","dir":"Articles","previous_headings":"","what":"x_from_power()","title":"Workflow of 'x_from_power()'","text":"following workflow x_from_power(). Simulation done value x, can slow Monte Carlo bootstrapping confidence intervals involved test. feasible, also necessary, accurately estimate levels power along many values across range x, goal find value x target power. Therefore, steps taken balance speed precision finding solution. Power x (Sample Size Effect Size [Parameter Value]) x_from_power, x can sample size (n) population value (es, “effect size”) selected model parameter.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"annotation","dir":"Articles","previous_headings":"","what":"Annotation","title":"Workflow of 'x_from_power()'","text":"by_x_1 collection values tried results. updated whenever new value(s) /tried. fit_1 latest power curve estimated power_curve, using values tried, stored by_x_1. updated whenever by_x_1 updated. x_j value(s) power levels estimated trial. nrep_j number replications used estimate power level value x. trial, numbers replications can different different values, efficiency. by_x_j results power4test_by_n() power4test_by_es() given x_j trial. x_out value x candidate solution (e.g., estimated power closest target value). power_out, nrep_out, ci_out, by_x_out Results based x_out. ci_hit Logical. Set TRUE least one value x confidence interval estimated power including target power. final_nrep desired number replications solution. value determines desired level precision (width confidence interval) solution. sequences values nrep, R, number x trial. initial number replications (nrep) can smaller final_nrep, initial trials, though lower precision (wider confidence intervals), faster run. solution likely found (values x estimated power close target value found), nrep increased successively final_nrep, trial slower run higher precision. values affect speed, number values x (xs_per_trial) number iterations (R) Monte Carlo confidence intervals bootstrapping, also increased successively. x_final value x solution (e.g., estimated power closest target value), found. power_final, nrep_final, ci_final, by_x_final Results based x_final. Main functions used power4test_by_n() power4test_by_es(), estimating power levels set values x. power_curve(), estimating relation power value x, based values x examined. internal function estimate_x_range(), determining value(s) x examined trial, given value(s) examined far tentative power curve.","code":""},{"path":"https://sfcheung.github.io/power4mome/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Shu Fai Cheung. Author, maintainer. Sing-Hang Cheung. Author. Wendie Yang. Author.","code":""},{"path":"https://sfcheung.github.io/power4mome/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cheung S, Cheung S, Yang W (2025). power4mome: Power Analysis Moderation Mediation. R package version 0.0.1.48, https://sfcheung.github.io/power4mome/.","code":"@Manual{,   title = {power4mome: Power Analysis for Moderation and Mediation},   author = {Shu Fai Cheung and Sing-Hang Cheung and Wendie Yang},   year = {2025},   note = {R package version 0.0.1.48},   url = {https://sfcheung.github.io/power4mome/}, }"},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"power4mome","dir":"","previous_headings":"","what":"Power Analysis for Moderation and Mediation","title":"Power Analysis for Moderation and Mediation","text":"package power analysis sample size determination moderation, mediation, moderated-mediation. includes functions power analysis sample size determination moderation, mediation, moderated-mediation effects models fitted structural equation modeling (SEM) multiple linear regression. SEM, latent variable models path models observed variables supported. information package, please visit GitHub page: https://sfcheung.github.io/power4mome/ get-started guide illustrates use package: https://sfcheung.github.io/power4mome/articles/power4mome.html","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"philosophy","dir":"","previous_headings":"","what":"Philosophy","title":"Power Analysis for Moderation and Mediation","text":"package developed philosophy: Easy specify population models, even latent variables. manually-set numbers possible specifying population models, convenient default values. restrictions possible form models, even models latent factors. automatic possible finding sample size target power. achieve comes costs, goals conflict goals: flexible usually means less user-friendly, easy specify model usually means supporting models. Therefore, also try balance goals, allow functions used different ways, accommodate scenarios prioritize goals differently.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Power Analysis for Moderation and Mediation","text":"latest developmental version package can installed remotes::install_github:","code":"remotes::install_github(\"sfcheung/power4mome\")"},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"background","dir":"","previous_headings":"","what":"Background","title":"Power Analysis for Moderation and Mediation","text":"us developers developed package manymome (Cheung & Cheung, 2024) computing testing effects models mediation, mediation, moderated-mediation. tests usually done simulation-based methods Monte Carlo bootstrap confidence intervals, due complicated sampling distributions effects. Therefore, simple ways determine power test analytically accurately. computation becomes complicated latent variables involved, necessitating simulation-based method estimate sample size. already many excellent packages estimating power structural equation modeling general, also specifically mediation moderated-mediation. intended replace reinvent wheel. just want tool meet needs: leverages flexibility manymome testing indirect effect conditional effect little limitations model. allows users (us collaborators) specify population model easy (quickly) typical power analysis programs. know power estimation simulation, necessary. However, time concern like tool , though specifically designed mediation, moderation, moderated-mediation mind may limited scope (though “big” scope), easy daily use estimating power. , power4mome, developed users, believe also useful others need power analysis mediation, moderation, moderated-mediation.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"not-just-that-","dir":"","previous_headings":"","what":"Not Just That …","title":"Power Analysis for Moderation and Mediation","text":"power4mome just mediation, moderation, moderated-mediation. avoided hardcoding functions just effects, left room testing effects, hinted examples help pages. may introduced later. now, supporting effects can tested manymome priority.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Power Analysis for Moderation and Mediation","text":"suggestions found bugs, please feel feel open GitHub issue: https://github.com/sfcheung/power4mome/issues Thanks.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"Power Analysis for Moderation and Mediation","text":"Cheung, S. F., & Cheung, S.-H. (2024). manymome: R package computing indirect effects, conditional effects, conditional indirect effects, standardized unstandardized, bootstrap confidence intervals, many (though ) models. Behavior Research Methods, 56(5), 4862–4882. https://doi.org/10.3758/s13428-023-02224-z","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Do a Test on Each Replication — do_test","title":"Do a Test on Each Replication — do_test","text":"test replication output sim_out().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do a Test on Each Replication — do_test","text":"","code":"do_test(   sim_all,   test_fun,   test_args = list(),   map_names = c(fit = \"fit\"),   results_fun = NULL,   results_args = list(),   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )"},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do a Test on Each Replication — do_test","text":"sim_all output sim_out(). test_fun function test. See 'Details' requirement function. built-test functions power4mome, described 'Details'. test_args list arguments passed test_fun function. Default list(). map_names named character vector specifying content element extra replication sim_all map argument test_fun. Default c(fit = \"fit\"), indicating element fit element extra set argument fit test_fun. , first replication, fit = sim_out[[1]]$extra$fit calling test_fun. results_fun function used extract test results. See Details requirements function. Default NULL, assuming output test_fun can used directly. results_args list arguments passed results_fun function. Default list(). parallel TRUE, parallel processing used tests. Default FALSE. progress TRUE, progress tests displayed. Default `FALSE. ncores number CPU cores use parallel processing used.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do a Test on Each Replication — do_test","text":"object class test_out, list length equal sim_all, one element replication. element list two elements: test: output function set test_fun. test_results: output function set results_fun.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Do a Test on Each Replication — do_test","text":"arbitrary test replication using function set test_fun.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-role-of-do-test-","dir":"Reference","previous_headings":"","what":"The role of do_test()","title":"Do a Test on Each Replication — do_test","text":"function do_test() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-test-function-test-fun-","dir":"Reference","previous_headings":"","what":"The test function (test_fun)","title":"Do a Test on Each Replication — do_test","text":"function set test_fun, test function, usually work output lavaan::sem(), lmhelprs::many_lm(), stats::lm(), can also function works output function set fit_function calling fit_model() power4test() (see fit_model_args). function two default requirements. First, argument fit, set output lavaan::sem() another output stored element extra$fit replication sim_all object. (requirement can relaxed; see section map_names.) , function definition : FUN(fit, ...). form test_* functions power4mome. arguments passed test function, can set test_args named list. Second, test function must returns output () can processed results function (see ), (b) required format output results function (see next section). already returns output required format, need set results function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-results-function-results-fun-","dir":"Reference","previous_headings":"","what":"The results function (results_fun)","title":"Do a Test on Each Replication — do_test","text":"test results extracted output test_fun function set results_fun, results function. test_fun already returns output expected format (see ), set results_fun NULL, default. output test_fun used estimating power. function set results_fun must accept output test_fun, first argument, return named list (can data frame) named vector following elements: est: Optional. estimate parameter, applicable. se: Optional. standard error estimate, applicable. cilo: Optional. lower limit confidence interval, applicable. cihi: Optional. upper limit confidence interval, applicable. sig: Required. 1, test significant. 0, test significant. test done reason, NA. results can used estimate power Type error test. example, null hypothesis false, proportion significant, , mean values sig across replications, power.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"built-in-test-functions","dir":"Reference","previous_headings":"","what":"Built-in test functions","title":"Do a Test on Each Replication — do_test","text":"package power4mome ready--use test functions: test_indirect_effect() test_cond_indirect() test_cond_indirect_effects() test_moderation() test_index_of_mome() test_parameters() Please refer help pages examples.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-argument-map-names","dir":"Reference","previous_headings":"","what":"The argument map_names","title":"Do a Test on Each Replication — do_test","text":"argument developers using test function different name argument fit object (\"fit\", default). test_fun set function works output , say, lavaan::sem() argument name output fit, mapping can changed map_names. example, lavaan::parameterEstimates() receives output lavaan::sem() reports test results model parameters. However, argument name lavaan output object. instruct do_test() test correctly setting test_fun lavaan::parameterEstimates, add map_names = c(object = \"fit\"). element fit replication set argument object lavaan::parameterEstimates().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-background-for-having-the-results-fun-argument","dir":"Reference","previous_headings":"","what":"The background for having the results_fun argument","title":"Do a Test on Each Replication — do_test","text":"early development power4mome, test_fun designed accept existing functions packages, manymome::indirect_effect(). outputs required format power analysis, results functions needed process outputs. current version power4mome, ready--use test functions, usually wrappers existing functions packages, developed, longer need results functions process output. argument results_fun kept backward compatibility advanced users use test functions packages.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do a Test on Each Replication — do_test","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate Monte Carlo estimates for forming Monte Carlo confidence intervals  mc_all <- gen_mc(fit_all,                  R = 50,                  iseed = 4567)  # Combine the results to a 'sim_all' object sim_all <- sim_out(data_all = data_all,                    fit = fit_all,                    mc_out = mc_all)  # Test the indirect effect in each replication test_all <- do_test(sim_all,                     test_fun = test_indirect_effect,                     test_args = list(x = \"x\",                                      m = \"m\",                                      y = \"y\",                                      mc_ci = TRUE),                     parallel = FALSE,                     progress = FALSE)  # The results lapply(test_all, function(x) x$test_results) #> [[1]] #>        est       cilo       cihi        sig  #> 0.10147276 0.02144103 0.18035550 1.00000000  #>  #> [[2]] #>          est         cilo         cihi          sig  #>  0.079776696 -0.002117072  0.194482289  0.000000000  #>  #> [[3]] #>          est         cilo         cihi          sig  #>  0.052746533 -0.001695808  0.117672020  0.000000000  #>  #> [[4]] #>        est       cilo       cihi        sig  #> 0.10461042 0.02975369 0.23184723 1.00000000  #>  #> [[5]] #>         est        cilo        cihi         sig  #> 0.116902305 0.003271956 0.251780798 1.000000000  #>"},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Model to a List of Datasets — fit_model","title":"Fit a Model to a List of Datasets — fit_model","text":"Get output sim_data() fit model stored datasets.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Model to a List of Datasets — fit_model","text":"","code":"fit_model(   data_all = NULL,   model = NULL,   fit_function = \"lavaan\",   arg_data_name = \"data\",   arg_model_name = \"model\",   arg_group_name = \"group\",   ...,   fit_out = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )"},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Model to a List of Datasets — fit_model","text":"data_all output sim_data(), sim_data class object. model model fitted. NULL, default, model stored data_all, data generation model, used. fit_function function used fit model. Can also string: \"lavaan\" (default) lavaan::sem(), \"lm\" many_lm lmhelprs::many_lm(). functions can also used necessary. arg_data_name name argument fit_function expecting dataset. Default \"data\". arg_model_name name argument fit_function expecting model definition. Default \"model\". arg_group_name name argument fit_function expecting name group variable. Used multigroup models. Default \"group\". ... Optional arguments passed fit_function fitting model. fit_out set fit_out object (output fit_model()), missing arguments retrieved fit_out. , users can use fit_model(data_all = new_data, fit_out = old_out) re-fit model originally fitted old_out new list dataset (new_data). need include arguments. parallel TRUE, parallel processing used fit models. Default FALSE. progress TRUE, progress model fitting displayed. Default `FALSE. ncores number CPU cores use parallel processing used.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Model to a List of Datasets — fit_model","text":"object class fit_out, list output fit_function (lavaan::sem() default). error occurred fitting model dataset, element error message fit function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a Model to a List of Datasets — fit_model","text":"default, extracts model stored output sim_data(), fits model dataset simulated using fit_function, default \"lavaan\" lavaan::sem() called, returns results. datasets generated multigroup model calling sim_data(), multigroup model fitted.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"the-role-of-fit-model-","dir":"Reference","previous_headings":"","what":"The role of fit_model()","title":"Fit a Model to a List of Datasets — fit_model","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize model fitting step power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Model to a List of Datasets — fit_model","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all) fit_all[[1]] #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0  # Fit the population model using the MLR estimator  fit_all_mlr <- fit_model(data_all,                          estimator = \"MLR\") fit_all_mlr[[1]] #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                               Standard      Scaled #>   Test Statistic                                 0.000       0.000 #>   Degrees of freedom                                 0           0  # Fit a model different from the population model, # with the MLR estimator  mod2 <- \"m ~ x  y ~ m\"  fit_all_mlr2 <- fit_model(data_all,                           mod2,                           estimator = \"MLR\") fit_all_mlr2[[1]] #> lavaan 0.6-19 ended normally after 2 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         4 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                               Standard      Scaled #>   Test Statistic                                 0.975       1.128 #>   Degrees of freedom                                 1           1 #>   P-value (Chi-square)                           0.323       0.288 #>   Scaling correction factor                                  0.864 #>     Yuan-Bentler correction (Mplus variant)"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Bootstrap Estimates — gen_boot","title":"Generate Bootstrap Estimates — gen_boot","text":"Get list output lavaan::sem() lmhelprs::many_lm() generate bootstrap estimates model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Bootstrap Estimates — gen_boot","text":"","code":"gen_boot(   fit_all,   R = 100,   ...,   iseed = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   compute_implied_stats = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Bootstrap Estimates — gen_boot","text":"fit_all output fit_model() object class fit_out. R number replications generate bootstrap estimates fit output. ... Optional arguments passed manymome::do_boot() generating bootstrap estimates. iseed seed random number generator. Default NULL seed changed. parallel TRUE, parallel processing used generate bootstrap estimates fit outputs. Default FALSE. progress TRUE, progress displayed. Default `FALSE. ncores number CPU cores use parallel processing used. compute_implied_stats Whether implied statistics computed bootstrap samples. Usually needed default FALSE","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Bootstrap Estimates — gen_boot","text":"boot_list object, list output manymome::do_boot().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Bootstrap Estimates — gen_boot","text":"simply calls manymome::do_boot() output lavaan::sem() lmhelprs::many_lm() fit_all. simulated estimates can used test effects indirect effects, usually functions manymome package, manymome::indirect_effect().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"the-role-of-gen-boot-","dir":"Reference","previous_headings":"","what":"The role of gen_boot()","title":"Generate Bootstrap Estimates — gen_boot","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize workflow power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Bootstrap Estimates — gen_boot","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 2,                      model = mod,                      pop_es = es,                      n = 50,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate bootstrap estimates for each replication  boot_all <- gen_boot(fit_all,                      R = 10,                      iseed = 4567) boot_all #> [[1]] #>  #> == A 'boot_out' class object == #>  #> Number of bootstrap samples: 10  #>  #>  #> [[2]] #>  #> == A 'boot_out' class object == #>  #> Number of bootstrap samples: 10  #>  #>  #> attr(,\"class\") #> [1] \"boot_list\" \"list\""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Monte Carlo Estimates — gen_mc","title":"Generate Monte Carlo Estimates — gen_mc","text":"Get list output lavaan::sem() generate Monte Carlo estimates model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Monte Carlo Estimates — gen_mc","text":"","code":"gen_mc(   fit_all,   R = 100,   ...,   iseed = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   compute_implied_stats = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Monte Carlo Estimates — gen_mc","text":"fit_all output fit_model() object class fit_out. R number replications generate Monte Carlo estimates fit output. ... Optional arguments passed manymome::do_mc() generating Monte Carlo estimates. iseed seed random number generator. Default NULL seed changed. parallel TRUE, parallel processing used generate Monte Carlo estimates fit outputs. Default FALSE. progress TRUE, progress displayed. Default `FALSE. ncores number CPU cores use parallel processing used. compute_implied_stats Whether implied statistics computed Monte Carlo replication. Usually needed default FALSE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Monte Carlo Estimates — gen_mc","text":"mc_list object, list output manymome::do_mc().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Monte Carlo Estimates — gen_mc","text":"simply calls manymome::do_mc() output lavaan::sem() fit_all. simulated estimates can used test effects indirect effects, usually functions manymome package, manymome::indirect_effect().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"the-role-of-gen-mc-","dir":"Reference","previous_headings":"","what":"The role of gen_mc()","title":"Generate Monte Carlo Estimates — gen_mc","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize workflow power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Monte Carlo Estimates — gen_mc","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate Monte Carlo estimates for each replication  mc_all <- gen_mc(fit_all,                  R = 100,                  iseed = 4567)  mc_all #> [[1]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[2]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[3]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[4]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[5]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> attr(,\"class\") #> [1] \"mc_list\" \"list\""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Power Curve — plot.power_curve","title":"Plot a Power Curve — plot.power_curve","text":"plots results 'power_curve' object, estimated power sample size.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Power Curve — plot.power_curve","text":"","code":"# S3 method for class 'power_curve' plot(   x,   what = c(\"ci\", \"power_curve\"),   main = paste0(\"Power Curve \", \"(Predictor: \", switch(x$predictor, n = \"Sample Size\", es     = \"Effect Size\"), \")\"),   xlab = switch(x$predictor, n = \"Sample Size\", es = \"Effect Size\"),   ylab = \"Estimated Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Power Curve — plot.power_curve","text":"x power_curve object, output power_curve(). character vector include plot. Possible values \"ci\" (confidence intervals estimated sample size) \"power_curve\" (crude power curve, available). default, elements plotted. main title plot. xlab, ylab labels horizontal vertical axes, respectively. pars_ci named list arguments passed arrows() customize drawing confidence intervals. type argument default plot method plot.default(). Default \"l\". See plot.default() options. ylim two-element numeric vector range vertical axis. ci_level level confidence confidence intervals, requested. Default .95, denoting 95%. ... Optional arguments. Passed plot() drawing base plot.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Power Curve — plot.power_curve","text":"plot-method power_curve objects, output power_curve(), returns x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a Power Curve — plot.power_curve","text":"currently plots relation estimated power predictor. elements can requested (see argument ), can customized individually.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a Power Curve — plot.power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 100, 200, 1000),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.550280     0.004213   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    54.55  #> Residual Deviance: 38.37 \tAIC: 42.37 plot(pout1)   # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = seq(0, .7, .15),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) plot(pout2)"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot The Results of 'x_from_power' — plot.x_from_power","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"plots results 'x_from_power', estimated power sample size.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"","code":"# S3 method for class 'x_from_power' plot(   x,   what = c(\"ci\", \"power_curve\", \"final_x\", \"final_power\", \"target_power\"),   text_what = c(\"final_x\", \"final_power\"),   digits = 3,   main = paste0(\"Power Curve \", \"(Target Power: \", formatC(x$target_power, digits =     digits, format = \"f\"), \")\"),   xlab = NULL,   ylab = \"Estimated Power\",   pars_ci = list(),   pars_power_curve = list(),   pars_ci_final_x = list(lwd = 2, length = 0.2, col = \"blue\"),   pars_target_power = list(lty = \"dotted\"),   pars_final_x = list(lty = \"dotted\"),   pars_final_power = list(lty = \"dotted\", col = \"blue\"),   pars_text_final_x = list(y = 0, pos = 3, cex = 1),   pars_text_final_power = list(pos = 3, cex = 1),   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"x x_from_power object, output x_from_power(). character vector include plot. Possible values \"ci\" (confidence intervals estimated value predictor), \"power_curve\" (crude power curve, available), \"final_x\" (vertical line value predictor estimated power close enough target power confidence interval), \"final_power\" (horizontal line estimated power final value predictor), \"target_power\" (horizontal line target power). default, elements plotted. text_what character vector numbers added labels. Possible values \"final_x\" (value predictor estimated power close enough target power confidence interval) \"final_power\" (estimated power final value predictor). default, labels added. digits number digits decimal used adding numbers. main title plot. xlab, ylab labels horizontal vertical axes, respectively. pars_ci named list arguments passed arrows() customize drawing confidence intervals. pars_power_curve named list arguments passed points() customize drawing power curve. pars_ci_final_x named list arguments passed arrows() customize drawing confidence interval final value predictor. pars_target_power named list arguments passed abline() drawing horizontal line target power. pars_final_x named list arguments passed abline() drawing vertical line final value predictor. pars_final_power named list arguments passed abline() drawing horizontal line estimated power final value predictor. pars_text_final_x named list arguments passed text() adding label final value predictor. pars_text_final_power named list arguments passed text() adding label estimated power final value predictor. ... Optional arguments. Passed plot() drawing estimated power predictor.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"plot-method x_from_power returns x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"currently plots relation estimated power values examined x_from_power(). elements can requested (see argument ), can customized individually.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 10,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 10,                            xs_per_trial = 1,                            nrep_steps = 1,                            max_trials = 1,                            seed = 2345) #>  #> --- Pre-iteration Search --- #>  #> - Start at 2025-06-02 11:58:33  #> - Value(s) to try:  125  #>  #> Updating the simulation for sample size: 125  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 125 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> - Power Curve: #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.85743      0.03244   #>  #> Degrees of Freedom: 19 Total (i.e. Null);  18 Residual #> Null Deviance:\t    16.91  #> Residual Deviance: 16.51 \tAIC: 20.51 #>  #>  #>  #> --- Trial 1 --- #>  #> - Start at 2025-06-02 11:58:37  #> - Value(s) to try: 64, 99  #> - Numbers of replications: 10, 10  #>  #> Updating the simulation for sample size: 64  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Updating the simulation for sample size: 99  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  64 test_parameters: CIs (pars: m~x)        m~x 1.000  0.500  0.190  0.810 #> 2  99 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 4 125 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - 'nls()' estimation failed. Switch to logistic regression. #> - Value with closest power: 99  #> - Estimated power for 99: 0.8000 #> - Power Curve: #> Call: #> power_curve(object = by_x_1, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.35503      0.03717   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    44.99  #> Residual Deviance: 40.4 \tAIC: 44.4 #>  #> - Estimated power is close enough to target power (0.8000). (CI: [0.7141,1.0859]) #>  #>  #> --- Final Stage --- #>  #> - Start at 2025-06-02 11:58:45  #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  64 test_parameters: CIs (pars: m~x)        m~x 1.000  0.500  0.190  0.810 #> 2  99 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 4 125 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.85743      0.03244   #>  #> Degrees of Freedom: 19 Total (i.e. Null);  18 Residual #> Null Deviance:\t    16.91  #> Residual Deviance: 16.51 \tAIC: 20.51 #>  #>  #> - Final Value: 125  #> - Final Estimated Power: 0.9000  #> - Confidence Interval: [0.7141; 1.0859] #> - CI Level: 95.00% plot(power_vs_n)"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Convert YAML string vector list pop_es specification.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"","code":"pop_es_yaml(text)"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"text multiline string parsed specification population values.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Either named vector (single-group model) list named vector (multigroup model).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"allows users specify population values model using one single string, 'lavaan' model syntax.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"","code":"mod_es <- c(\"y ~ m\" = \"l\",             \"m ~ x\" = \"m\",             \"y ~ x\" = \"nil\")  mod_es_yaml <- \" y ~ m: l m ~ x: m y ~ x: nil \"  pop_es_yaml(mod_es_yaml) #> y ~ m m ~ x y ~ x  #>   \"l\"   \"m\" \"nil\""},{"path":"https://sfcheung.github.io/power4mome/reference/power4mome-package.html","id":null,"dir":"Reference","previous_headings":"","what":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","title":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","text":"Power analysis sample size determination moderation, mediation, moderated mediation models fitted structural equation modeling.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4mome-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","text":"Maintainer: Shu Fai Cheung shufai.cheung@gmail.com (ORCID) Authors: Sing-Hang Cheung (ORCID) Wendie Yang (ORCID)","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the Power of a Test — power4test","title":"Estimate the Power of a Test — power4test","text":"--one function receives model specification, generates datasets, fits model, target test, returns test results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the Power of a Test — power4test","text":"","code":"power4test(   object = NULL,   nrep = NULL,   ptable = NULL,   model = NULL,   pop_es = NULL,   standardized = TRUE,   n = NULL,   number_of_indicators = NULL,   reliability = NULL,   x_fun = list(),   fit_model_args = list(),   R = NULL,   ci_type = \"mc\",   gen_mc_args = list(),   gen_boot_args = list(),   test_fun = NULL,   test_args = list(),   map_names = c(fit = \"fit\"),   results_fun = NULL,   results_args = list(),   test_name = NULL,   test_note = NULL,   do_the_test = TRUE,   sim_all = NULL,   iseed = NULL,   parallel = FALSE,   progress = TRUE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5, si = 0.141, mi = 0.316, li = 0.51),   es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15),   es_ind = c(\"si\", \"mi\", \"li\"),   n_std = 1e+05,   std_force_monte_carlo = FALSE )  # S3 method for class 'power4test' print(   x,   what = c(\"data\", \"test\"),   digits = 3,   digits_descriptive = 2,   data_long = FALSE,   test_long = FALSE,   fit_to_all_args = list(),   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the Power of a Test — power4test","text":"object Optional. set power4test object, updated using value(s) n, pop_es, /nrep changed, new test conducted added objet. See help page details. Default NULL. nrep number replications generate simulated datasets. Default NULL. Must set called create power4test object. ptable output ptable_pop(), ptable_pop object, representing population model. NULL, default, ptable_pop() called generate ptable_pop object using model pop_es. model lavaan model syntax population model, used ptable_pop(). See 'Details' specify model. Ignored ptable specified. pop_es character vector multiline string specify population effect sizes (population values parameters). See help page specify argument. Ignored ptable specified. standardized Logical. TRUE, default, variances error variances scaled ensure population variances endogenous variables close one, hence effect sizes (population values) standardized effect sizes variances continuous exogenous variables also equal one. n sample size dataset. Default 100. number_of_indicators named vector specify number indicators factors. See help page set argument. Default NULL variables model syntax observed variables. See help page use argument. reliability named vector (single-group model) named list named vectors (multigroup model) set reliability coefficient set indicators. Default NULL. See help page use argument. x_fun function(s) used generate exogenous variables. supplied, set list(), default, variables generated multivariate normal distribution. See help page use argument. fit_model_args list arguments passed fit_model() fitting model. named list names names arguments. R number replications generate Monte Carlo bootstrapping estimates fit output. Monte Carlo bootstrapping estimates generated R set NULL. ci_type type simulation-based confidence intervals use. Can either \"mc\" Monte Carlo method (default) \"boot\" nonparametric bootstrapping method. Relevant test functions make use estimates generate gen_boot() gen_mc(), test_indirect_effect(). gen_mc_args list arguments passed manymome::do_mc() generating Monte Carlo estimates. named argument names names arguments. Used ci_type \"mc\". gen_boot_args list arguments passed manymome::do_boot() generating bootstrap estimates. named argument names names arguments. Used ci_type `\"boot\". test_fun function test. See 'Details' requirement function. built-test functions power4mome, described 'Details'. test_args list arguments passed test_fun function. Default list(). map_names named character vector specifying content element extra replication sim_all map argument test_fun. Default c(fit = \"fit\"), indicating element fit element extra set argument fit test_fun. , first replication, fit = sim_out[[1]]$extra$fit calling test_fun. results_fun function used extract test results. See Details requirements function. Default NULL, assuming output test_fun can used directly. results_args list arguments passed results_fun function. Default list(). test_name String. name test. Default NULL, name created test_fun. Note sim_out power4test object already test name stored, replaced new results. test_note String. optional note test, stored attribute test_note output do_test(). Default NULL. do_the_test TRUE, do_test() called test specified test_fun fit output dataset. sim_all set either sim_out object (output sim_out() power4test object (output power4test()), stored datasets fit outputs used test. Setting object output power4test() now preferred method, argument kept backward compatibility. iseed seed random number generator. Default NULL seed changed. seed set , calling sim_data(). parallel TRUE, parallel processing used calling functions, appropriate. Default FALSE. progress TRUE, progress step displayed. Default FALSE. ncores number CPU cores use parallel processing used. es1 Set values label effect size (population value) correlations regression paths. Used pop_es named vector multiline string. See help page specify argument. es2 Set values label effect size (population value) product term. Used pop_es named vector multiline string. See help page specify argument. es_ind names labels denoting effect size indirect effect. used determine population values component paths along indirect path. n_std sample size used determine error variances simulation std_force_monte_carlo TRUE. std_force_monte_carlo Logical. FALSE, default, standardization done analytically model product terms, simulation model product terms. , error variances required ensure implied variances equal one determined simulation. TRUE, simulation used whether model product terms . Always fall back simulation analytical standardization failed. x object printed. string vector print, \"data\" simulated data \"test\" stored test(s). Default c(\"data\", \"test\"). digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. data_long TRUE, detailed results printed printing simulated data. test_long TRUE, detailed results printed printing test(s). fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined ... Optional arguments passed print methods","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the Power of a Test — power4test","text":"object class power4test, list two elements: sim_all: output sim_out(). test_all: named list output do_test(). names values test_name. list can one test call power4test() can add new tests power4test object. print method power4test returns x invisibly. Called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate the Power of a Test — power4test","text":"--one function estimating power test model, given sample size effect sizes (population values model parameters).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"workflow","dir":"Reference","previous_headings":"","what":"Workflow","title":"Estimate the Power of a Test — power4test","text":"workflow: object output output previous call power4test() do_the_test set FALSE model simulated data, following steps skipped go directly test. Call sim_data() determine population model generate datasets, using arguments model pop_es. Call fit_model() fit model datasets, population model default. R NULL ci_type = \"mc\", call gen_mc() generate Monte Carlo estimates using manymome::do_mc(). estimates can used supported functions test_indirect_effect(). R NULL ci_type = \"boot\", call gen_boot() generate bootstrap estimates using manymome::do_boot(). estimates can used supported functions test_indirect_effect(). Merge results sim_out object calling sim_out(). do_the_test FALSE, skip remaining steps return power4test object, contains data generated optionally Monte Carlo bootstrap estimates. do_the_test TRUE, test. do_test() called test fit output dataset. Return power4test object include output sim_out , do_the_test TRUE, output do_test(). function used users interested power one several tests particular aspect model, parameter, given specific effect sizes sample sizes. Detailed description major arguments can found sections . NOTE: technical internal workflow power4test() can found page: https://sfcheung.github.io/power4mome/articles/power4test_workflow.html.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"updating-a-condition","dir":"Reference","previous_headings":"","what":"Updating a Condition","title":"Estimate the Power of a Test — power4test","text":"function power4test() can also used update condition selected aspects changed. example, instead calling function arguments set just change sample size, can called supplying existing power4test object set n new sample size. data tests updated automatically. See examples illustration.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"adding-another-test","dir":"Reference","previous_headings":"","what":"Adding Another Test","title":"Estimate the Power of a Test — power4test","text":"function power4test() can also used add test output previous call power4test(). example, simulating datasets one test, output can set object power4test(), set test_fun , optionally, test_fun_args one test generated datasets. output original object results new test added. See examples illustration.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"model-fitting-arguments-fit-model-args-","dir":"Reference","previous_headings":"","what":"Model Fitting Arguments ('fit_model_args')","title":"Estimate the Power of a Test — power4test","text":"power analysis, usually, population model (model) fitted, need set fit_model_args. power analysis conducted fitting model population model, non-default settings desired fitting model, argument fit_model_args needed set customize call fit_model(). example, users may want examine power test misspecified model fitted, power test MLR used estimator calling lavaan::sem(). See help page fit_model() examples.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Estimate the Power of a Test — power4test","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Estimate the Power of a Test — power4test","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Estimate the Power of a Test — power4test","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Estimate the Power of a Test — power4test","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Estimate the Power of a Test — power4test","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Estimate the Power of a Test — power4test","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"set-number-of-indicators-and-reliability-","dir":"Reference","previous_headings":"","what":"Set 'number_of_indicators' and 'reliability'","title":"Estimate the Power of a Test — power4test","text":"arguments number_of_indicators reliability used specify number indicators (e.g., items) factor, population reliability coefficient factor, variables model syntax latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-3","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"variable model replaced indicators generated data, set number_of_indicators named numeric vector. names variables variables indicators, appeared model syntax. value name number indicators. argument reliability set named numeric vector (list, see section multigroup models) specify population reliability coefficient (\"omega\") set indicators. population standardized factor loadings computed ensure population reliability coefficient target value. examples single group model: numbers indicators m, x, y 3, 4, 5, respectively. population reliability coefficients m, x, y .90, .80, .70, respectively.","code":"number of indicator = c(m = 3, x = 4, y = 5) reliability = c(m = .90, x = .80, y = .70)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-models","dir":"Reference","previous_headings":"","what":"Multigroup Models","title":"Estimate the Power of a Test — power4test","text":"Multigroup models supported. number groups inferred pop_es (see help page ptable_pop()), directly ptable. multigroup model, number indicators variable must across groups. However, population reliability coefficients can different across groups. multigroup model k groups, one population reliability coefficients differ across groups, argument reliability set named list. names variables population reliability coefficients set. element name either single value common reliability coefficient, numeric vector reliability coefficient group. example reliability model 2 groups: reliability coefficients x .80 groups, reliability coefficients m .70 one group .80 another.","code":"reliability = list(x = .80, m = c(.70, .80))"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"equal-numbers-of-indicators-and-or-reliability-coefficients","dir":"Reference","previous_headings":"","what":"Equal Numbers of Indicators and/or Reliability Coefficients","title":"Estimate the Power of a Test — power4test","text":"variables model number indicators, number_of_indicators can set one single value. Similarly, sets indicators population reliability groups, reliability can also set one single value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-the-distributions-of-exogenous-variables-using-x-fun-","dir":"Reference","previous_headings":"","what":"Specify The Distributions of Exogenous Variables Using 'x_fun'","title":"Estimate the Power of a Test — power4test","text":"default, variables generated multivariate normal distribution. desired, users can supply function used generate exogenous variables setting x_fun named list. names list variables user function used generate data. element list must also list. first element list, can unnamed, function used. arguments need supplied, included named elements list. example: variables x w generated user-supplied functions. x, function power4mome::rexp_rs. additional argument calling function. w, function power4mome::rbinary_rx. argument p1 = .70 passed function generating values w. requirements user-functions: must return numeric vector. mush argument n number values. population mean standard deviation generated values must 0 1, respectively. package power4mome helper functions generating values common nonnormal distributions scaling population mean standard deviation equal 0 1 (default), respectively. : rbinary_rs(). rexp_rs(). rbeta_rs(). rlnorm_rs(). rpgnorm_rs(). use x_fun, variables must zero covariances variables population. possible generate nonnormal multivariate data believe rarely needed estimating power data.","code":"x_fun = list(x = list(power4mome::rexp_rs),              w = list(power4mome::rbinary_rs,                       p1 = .70)))"},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-test-function-test-fun-","dir":"Reference","previous_headings":"","what":"The test function (test_fun)","title":"Estimate the Power of a Test — power4test","text":"function set test_fun, test function, usually work output lavaan::sem(), lmhelprs::many_lm(), stats::lm(), can also function works output function set fit_function calling fit_model() power4test() (see fit_model_args). function two default requirements. First, argument fit, set output lavaan::sem() another output stored element extra$fit replication sim_all object. (requirement can relaxed; see section map_names.) , function definition : FUN(fit, ...). form test_* functions power4mome. arguments passed test function, can set test_args named list. Second, test function must returns output () can processed results function (see ), (b) required format output results function (see next section). already returns output required format, need set results function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-results-function-results-fun-","dir":"Reference","previous_headings":"","what":"The results function (results_fun)","title":"Estimate the Power of a Test — power4test","text":"test results extracted output test_fun function set results_fun, results function. test_fun already returns output expected format (see ), set results_fun NULL, default. output test_fun used estimating power. function set results_fun must accept output test_fun, first argument, return named list (can data frame) named vector following elements: est: Optional. estimate parameter, applicable. se: Optional. standard error estimate, applicable. cilo: Optional. lower limit confidence interval, applicable. cihi: Optional. upper limit confidence interval, applicable. sig: Required. 1, test significant. 0, test significant. test done reason, NA. results can used estimate power Type error test. example, null hypothesis false, proportion significant, , mean values sig across replications, power.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"built-in-test-functions","dir":"Reference","previous_headings":"","what":"Built-in test functions","title":"Estimate the Power of a Test — power4test","text":"package power4mome ready--use test functions: test_indirect_effect() test_cond_indirect() test_cond_indirect_effects() test_moderation() test_index_of_mome() test_parameters() Please refer help pages examples.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-argument-map-names","dir":"Reference","previous_headings":"","what":"The argument map_names","title":"Estimate the Power of a Test — power4test","text":"argument developers using test function different name argument fit object (\"fit\", default). test_fun set function works output , say, lavaan::sem() argument name output fit, mapping can changed map_names. example, lavaan::parameterEstimates() receives output lavaan::sem() reports test results model parameters. However, argument name lavaan output object. instruct do_test() test correctly setting test_fun lavaan::parameterEstimates, add map_names = c(object = \"fit\"). element fit replication set argument object lavaan::parameterEstimates().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the Power of a Test — power4test","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  out <- power4test(nrep = 50,                   model = model_simple_med,                   pop_es = model_simple_med_es,                   n = 100,                   test_fun = test_parameters,                   test_args = list(pars = \"m~x\"),                   iseed = 1234,                   parallel = FALSE,                   progress = TRUE) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Do the test: test_parameters: CIs (pars: m~x)   print(out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.307 0.095 3.247  0.040 0.121 0.494 0.860 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000   # Change the sample size  out1 <- power4test(out,                    n = 200,                    iseed = 1234,                    parallel = FALSE,                    progress = TRUE) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) :  print(out1,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  200  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           200 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.291 0.067 4.370  0.003 0.160 0.423 0.960 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000   # Add one more test  out2 <- power4test(out,                    test_fun = test_parameters,                    test_args = list(pars = \"y~x\"),                    parallel = FALSE,                    progress = TRUE) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs (pars: y~x)   print(out2,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.307 0.095 3.247  0.040 0.121 0.494 0.860 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000  #>  #> ========== <test_parameters: CIs (pars: y~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        y~x   y  ~   x -0.021 0.091 -0.224  0.441 -0.200 0.158 0.060 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":null,"dir":"Reference","previous_headings":"","what":"Power By Effect Sizes — power4test_by_es","title":"Power By Effect Sizes — power4test_by_es","text":"Estimate power set effect sizes (population values model parameter).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power By Effect Sizes — power4test_by_es","text":"","code":"power4test_by_es(   object,   pop_es_name = NULL,   pop_es_values = NULL,   progress = TRUE,   ...,   by_seed = NULL,   by_nrep = NULL,   save_sim_all = TRUE )  # S3 method for class 'power4test_by_es' c(..., sort = TRUE, skip_checking_models = FALSE)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power By Effect Sizes — power4test_by_es","text":"object power4test object, power4test_by_es object. power4test_by_es object, first element, power4test object, used value argument. pop_es_name name parameter. See help page ptable_pop() names argument pop_es. pop_es_values numeric vector population values parameter specified pop_es_names. progress Logical. Whether progress simulation displayed. ... power4test_by_es(), arguments passed power4test(). c.power4test_by_es(), power4test_by_es() outputs combined together. by_seed set number, used generate seeds call power4test(). NULL, default, seeds still randomly generated results easily reproduced. by_nrep set number, used generate number replications (nrep) call power4test(). set numeric vector length pop_es_values, nrep values calls, allowing different numbers replications population values. NULL, default, original nrep used. argument used x_from_power() efficiency, rarely used calling function directly. save_sim_all FALSE, dataset power4test objects saved, reduce size output. Default TRUE. sort combining objects, whether sorted population values. Default TRUE. skip_checking_models Whether check data generation model checked. Default TRUE. set FALSE users certain based model, model saved (e.g., save_sim_all set FALSE objects generated). argument used x_from_power() efficiency, rarely used calling c method directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power By Effect Sizes — power4test_by_es","text":"function power4test_by_es() returns power4test_by_es object, list power4test objects, one population value parameter. method c.power4test_by_es() returns power4test_by_es object elements (tests different values pop_es_values) combined.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power By Effect Sizes — power4test_by_es","text":"function regenerates datasets set effect sizes (population values model parmeter) stored tests . Optionally, can also run object stored tests. case, additional arguments must set instruct power4test() tests conducted. usually used examine power sets effect sizes (population values). method c.power4test_by_es() used combine tests different runs power4test_by_es().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power By Effect Sizes — power4test_by_es","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  sim_only <- power4test(nrep = 2,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 40,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_indirect: x->m->y   out <- power4test_by_es(test_out,                             pop_es_name = \"y ~ m\",                             pop_es_values = c(.10, .20)) #>  #> Updating the simulation for new value: y ~ m = 0.1  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for new value: y ~ m = 0.2  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : out_reject <- rejection_rates(out) out_reject #>     par    es                   test test_label   p.v reject r.cilo r.cihi #> 1 y ~ m 0.100 test_indirect: x->m->y       Test 1.000  0.000  0.000  0.000 #> 2 y ~ m 0.200 test_indirect: x->m->y       Test 1.000  0.500 -0.193  1.193 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Power By Sample Sizes — power4test_by_n","title":"Power By Sample Sizes — power4test_by_n","text":"Estimate power set sample sizes.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power By Sample Sizes — power4test_by_n","text":"","code":"power4test_by_n(   object,   n = NULL,   progress = TRUE,   ...,   by_seed = NULL,   by_nrep = NULL,   save_sim_all = TRUE )  # S3 method for class 'power4test_by_n' c(..., sort = TRUE, skip_checking_models = FALSE)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power By Sample Sizes — power4test_by_n","text":"object power4test object, power4test_by_n object. power4test_by_n object, first element, power4test object, used value argument. n numeric vector sample sizes simulation conducted. progress Logical. Whether progress simulation displayed. ... power4test_by_n(), arguments passed power4test(). c.power4test_by_n(), power4test_by_n() outputs combined together. by_seed set number, used generate seeds call power4test(). NULL, default, seeds still randomly generated results easily reproduced. by_nrep set number, used generate number replications (nrep) call power4test(). set numeric vector length n, nrep values calls, allowing different numbers replications sample sizes. NULL, default, original nrep used. argument used x_from_power() efficiency, rarely used calling function directly. save_sim_all FALSE, dataset power4test objects saved, reduce size output. Default TRUE. sort combining objects, whether sorted sample sizes. Default TRUE. skip_checking_models Whether check data generation model checked. Default TRUE. set FALSE users certain based model, model saved (e.g., save_sim_all set FALSE objects generated). argument used x_from_power() efficiency, rarely used calling c method directly.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power By Sample Sizes — power4test_by_n","text":"function power4test_by_n() returns power4test_by_n object, list power4test objects, one sample size. method c.power4test_by_n() returns power4test_by_n object elements (tests different sample sizes) combined.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power By Sample Sizes — power4test_by_n","text":"function regenerates datasets set sample sizes stored tests . Optionally, can also run object stored tests. case, additional arguments must set instruct power4test() tests conducted. usually used examine power set sample sizes. method c.power4test_by_n() used combine tests different runs power4test_by_n().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power By Sample Sizes — power4test_by_n","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  sim_only <- power4test(nrep = 2,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 40,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_indirect: x->m->y   out <- power4test_by_n(test_out,                        n = c(100, 110, 120)) #>  #> Updating the simulation for sample size: 100  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for sample size: 110  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for sample size: 120  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : out_reject <- rejection_rates(out) out_reject #>     n                   test test_label   p.v reject r.cilo r.cihi #> 1 100 test_indirect: x->m->y       Test 1.000  0.500 -0.193  1.193 #> 2 110 test_indirect: x->m->y       Test 1.000  1.000  1.000  1.000 #> 3 120 test_indirect: x->m->y       Test 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Power Curve — power_curve","title":"Power Curve — power_curve","text":"Estimate relation power characteristic, sample size population effect size (population value model parameter).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power Curve — power_curve","text":"","code":"power_curve(   object,   formula = NULL,   start = NULL,   lower_bound = NULL,   upper_bound = NULL,   nls_args = list(),   nls_control = list(),   verbose = FALSE )  # S3 method for class 'power_curve' print(x, data_used = FALSE, digits = 3, right = FALSE, row.names = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power Curve — power_curve","text":"object object class power4test_by_n power4test_by_es, output power4test_by_n() power4test_by_es(). formula formula model stats::nls(). can also list formulas, models fitted successively stats::nls(), first model fitted successfully adopted. response variable formula must named reject, predictor named x. Whether x represents n es depends class object. NULL, default, determined internally based type object. start Either named vector start value(s) parameter(s) formula, list named vectors starting value(s) list formula(s). NULL, default, determined internally. lower_bound Either named vector lower bound(s) parameter(s) formula, list named vectors lower bound(s) list formula(s). passed lower stats::nls(). NULL, default, determined internally based type object. upper_bound Either named vector upper bound(s) parameter(s) formula, list named vectors upper bound(s) list formula(s). passed upper stats::nls(). NULL, default, determined internally based type object. nls_args named list arguments used calling stats::nls(). Used override internal default, algorithm (default \"port\"). Use argument cautions. nls_control named list arguments passed control argument stats::nls(). values override internal default values, also override nls_args. Use argument cautions. verbose Logical. Whether messages printed trying different models. x power_curve object. data_used Logical. Whether rejection rates data frame used fit model printed. digits, right, row.names Arguments names used print method data.frame object. Used data_used TRUE rejection rates data frame printed. ... print method power_curve objects, optional arguments passed print.data.frame() printing rejection rates data frame.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power Curve — power_curve","text":"returns list power_curve object, following elements: fit: model fitted, output stats::nls(), stats::glm(), stats::lm(). reject_df: table reject rates characteristics, generated rejection_rates(). predictor: predictor power curve, ether \"n\" (sample size) \"es\" (population effect size). call: call used run function. print method power_curve object returns x invisibly. Called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power Curve — power_curve","text":"retrieves information output power4test_by_n() power4test_by_es(), estimate power curve: relation characteristic varied, sample size power4test_by_n() population effect size power4test_by_es(), rejection rate test conducted power4test_by_n() power4test_by_es(). rejection rate power null hypothesis false (e.g., population value effect size tested nonzero). model fitted intended precise model relation across wide range. crude estimate based limited number values characteristic (e.g., sample size) examined, can small four even smaller. model intended used range covered, estimating probable sample size effect size desirable level power. value studied higher precision simulation using functions power4test(). models tried, following order: One nonlinear models, fitted stats::nls(). several models specified, fitted one smallest deviance used. nonlinear models failed, whatever reason, logistic regression fitted stats::glm() predict binary significant test results. logistic model also failed, whatever reason, simple linear regression model fitted. Although power curve nonlinear across wide range , say, sample size, linear model can still good enough approximation narrow range predictor. output can plotted visualize power curve, using plot method (plot.power_curve()) output power_curve(). function can used directly, also used internally functions x_from_power().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power Curve — power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 100, 200, 1000),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.550280     0.004213   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    54.55  #> Residual Deviance: 38.37 \tAIC: 42.37 plot(pout1)   # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = seq(0, .7, .15),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) pout2 #> Call: #> power_curve(object = out2) #>  #> Predictor: es (Effect Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ 1 - 2/(exp(x/d) + exp(-x/d)) #>    data: \"(Omitted)\" #>     d  #> -0.13  #>  residual sum-of-squares: 0.05021 #>  #> Algorithm \"port\", convergence message: relative convergence (4) plot(pout2)"},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for a 'power_curve' Object — predict.power_curve","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"Compute predicted values model fitted power_curve().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"","code":"# S3 method for class 'power_curve' predict(object, newdata, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"object power_curve object. newdata data frame column named x. can also named list, one element named x vector values. supplied, values x stored object used. ... Additional arguments. Passed corresponding predict method.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"returns numeric vector predicted rejection rates.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"works two modes. new data supplied (newdata), retrieves stored results calls corresponding methods compute predicted values, predicted rejection rates (power levels null hypothesis false, e.g., population effect size equal zero). new data supplied, named list vector sample sizes, used compute predicted rejection rates.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 100, 200, 1000),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.550280     0.004213   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    54.55  #> Residual Deviance: 38.37 \tAIC: 42.37 predict(pout1,         newdata = list(x = c(150, 250, 500))) #>         1         2         3  #> 0.2852909 0.3782246 0.6355494   # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = seq(0, .7, .15),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) pout2 #> Call: #> power_curve(object = out2) #>  #> Predictor: es (Effect Size) #>  #> Model: #> Nonlinear regression model #>   model: reject ~ 1 - 2/(exp(x/d) + exp(-x/d)) #>    data: \"(Omitted)\" #>     d  #> -0.13  #>  residual sum-of-squares: 0.05021 #>  #> Algorithm \"port\", convergence message: relative convergence (4) predict(pout2,         newdata = list(x = c(.25, .55))) #> [1] 0.7136569 0.9708902"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the Population Model — ptable_pop","title":"Generate the Population Model — ptable_pop","text":"Generate complete population model using model syntax user-specified effect sizes (population parameter values).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the Population Model — ptable_pop","text":"","code":"ptable_pop(   model = NULL,   pop_es = NULL,   es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5, si = 0.141, mi = 0.316, li = 0.51),   es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15),   es_ind = c(\"si\", \"mi\", \"li\"),   standardized = TRUE,   n_std = 1e+05,   std_force_monte_carlo = FALSE )  model_matrices_pop(x, ..., drop_list_single_group = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the Population Model — ptable_pop","text":"model String. model defined lavaan model syntax. See 'Details'. pop_es can data frame columns: lhs, op, rhs, pop. first three columns correspond lavaan parameter table. column pop stores population values. column es stores original labels, reference. can also named character vector (named list multigroup models) multiline string, preferred approaches. See help page specify vector. es1 Set values label effect size (population value) correlations regression paths. Used pop_es named vector multiline string. See help page specify argument. es2 Set values label effect size (population value) product term. Used pop_es named vector multiline string. See help page specify argument. es_ind names labels denoting effect size indirect effect. used determine population values component paths along indirect path. standardized Logical. TRUE, default, variances error variances scaled ensure population variances endogenous variables close one, hence effect sizes (population values) standardized effect sizes variances continuous exogenous variables also equal one. n_std sample size used determine error variances simulation std_force_monte_carlo TRUE. std_force_monte_carlo Logical. FALSE, default, standardization done analytically model product terms, simulation model product terms. , error variances required ensure implied variances equal one determined simulation. TRUE, simulation used whether model product terms . Always fall back simulation analytical standardization failed. x can 'lavaan' model syntax, passed ptable_pop(), parameter table column start set population values, output ptable_pop(). ... x model syntax, arguments passed ptable_pop(). drop_list_single_group TRUE number groups equal one, output list matrices one group . Default TRUE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() returns lavaan parameter table model, column start set population values. function model_matrices_pop() returns lavaan LISREL-style model matrices (like output lavaan::lavInspect() set \"free\"), matrix elements set population values. x model syntax, stored attributes model. model multigroup model k groups (k greater 1), returns list k lists lavaan LISREL-style model matrices unless drop_list_single_group TRUE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() generates lavaan parameter table can used generate data based population values model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"the-role-of-ptable-pop-","dir":"Reference","previous_headings":"","what":"The role of ptable_pop()","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Generate the Population Model — ptable_pop","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Generate the Population Model — ptable_pop","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Generate the Population Model — ptable_pop","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Generate the Population Model — ptable_pop","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Generate the Population Model — ptable_pop","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Generate the Population Model — ptable_pop","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"the-role-of-model-matrices-pop-","dir":"Reference","previous_headings":"","what":"The role of model_matrices_pop()","title":"Generate the Population Model — ptable_pop","text":"function model_matrices_pop() generates models matrices population values, used ptable_pop(). Users usually call function directly, though developers can use build workflows generate data.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate the Population Model — ptable_pop","text":"","code":"# Specify the model  model1 <- \" m1 ~ x + c1 m2 ~ m1 + x2 + c1 y ~  m2 + m1 + x + w + x:w + c1 \"  # Specify the population values  model1_es <- c(\"m1 ~ x\" = \"-m\",                \"m2 ~ m1\" = \"s\",                \"y ~ m2\" = \"l\",                \"y ~ x\" = \"m\",                \"y ~ w\" = \"s\",                \"y ~ x:w\" = \"s\",                \"x ~~ w\" = \"s\")  ptable_final1 <- ptable_pop(model1,                             pop_es = model1_es) ptable_final1 #>    id lhs op rhs group user block free ustart exo label plabel      start est #> 1   1  m1  ~   x     1    1     1    1     NA   0         .p1. -0.3000000   0 #> 2   2  m1  ~  c1     1    1     1    2     NA   0         .p2.  0.0000000   0 #> 3   3  m2  ~  m1     1    1     1    3     NA   0         .p3.  0.1000000   0 #> 4   4  m2  ~  x2     1    1     1    4     NA   0         .p4.  0.0000000   0 #> 5   5  m2  ~  c1     1    1     1    5     NA   0         .p5.  0.0000000   0 #> 6   6   y  ~  m2     1    1     1    6     NA   0         .p6.  0.5000000   0 #> 7   7   y  ~  m1     1    1     1    7     NA   0         .p7.  0.0000000   0 #> 8   8   y  ~   x     1    1     1    8     NA   0         .p8.  0.3000000   0 #> 9   9   y  ~   w     1    1     1    9     NA   0         .p9.  0.1000000   0 #> 10 10   y  ~ x:w     1    1     1   10     NA   0        .p10.  0.0500000   0 #> 11 11   y  ~  c1     1    1     1   11     NA   0        .p11.  0.0000000   0 #> 12 12  m1 ~~  m1     1    0     1   12     NA   0        .p12.  0.9102958   1 #> 13 13  m2 ~~  m2     1    0     1   13     NA   0        .p13.  0.9899977   1 #> 14 14   y ~~   y     1    0     1   14     NA   0        .p14.  0.6509400   1 #> 15 15   x ~~   x     1    0     1   15     NA   0        .p15.  1.0000000   1 #> 16 16   x ~~  c1     1    0     1   16     NA   0        .p16.  0.0000000   0 #> 17 17   x ~~  x2     1    0     1   17     NA   0        .p17.  0.0000000   0 #> 18 18   x ~~   w     1    0     1   18     NA   0        .p18.  0.1000000   0 #> 19 19   x ~~ x:w     1    0     1   19     NA   0        .p19.  0.0000000   0 #> 20 20  c1 ~~  c1     1    0     1   20     NA   0        .p20.  1.0000000   1 #> 21 21  c1 ~~  x2     1    0     1   21     NA   0        .p21.  0.0000000   0 #> 22 22  c1 ~~   w     1    0     1   22     NA   0        .p22.  0.0000000   0 #> 23 23  c1 ~~ x:w     1    0     1   23     NA   0        .p23.  0.0000000   0 #> 24 24  x2 ~~  x2     1    0     1   24     NA   0        .p24.  1.0000000   1 #> 25 25  x2 ~~   w     1    0     1   25     NA   0        .p25.  0.0000000   0 #> 26 26  x2 ~~ x:w     1    0     1   26     NA   0        .p26.  0.0000000   0 #> 27 27   w ~~   w     1    0     1   27     NA   0        .p27.  1.0000000   1 #> 28 28   w ~~ x:w     1    0     1   28     NA   0        .p28.  0.0000000   0 #> 29 29 x:w ~~ x:w     1    0     1   29     NA   0        .p29.  1.0000000   1  # Use multiline string, illustrated by a simpler model  model2 <- \" m ~ x y ~ m + x \"  model2_es_a <- c(\"m ~ x\" = \"s\",                \"y ~ m\" = \"m\",                \"y ~ x\" = \"nil\")  model2_es_b <- \" m ~ x: s y ~ m: m y ~ x: nil \"  ptable_model2_a <- ptable_pop(model2,                               pop_es = model2_es_a) ptable_model2_b <- ptable_pop(model2,                               pop_es = model2_es_b)  ptable_model2_a #>   id lhs op rhs group user block free ustart exo label plabel start est #> 1  1   m  ~   x     1    1     1    1     NA   0         .p1.  0.10   0 #> 2  2   y  ~   m     1    1     1    2     NA   0         .p2.  0.30   0 #> 3  3   y  ~   x     1    1     1    3     NA   0         .p3.  0.00   0 #> 4  4   m ~~   m     1    0     1    4     NA   0         .p4.  0.99   1 #> 5  5   y ~~   y     1    0     1    5     NA   0         .p5.  0.91   1 #> 6  6   x ~~   x     1    0     1    6     NA   0         .p6.  1.00   1 ptable_model2_b #>   id lhs op rhs group user block free ustart exo label plabel start est #> 1  1   m  ~   x     1    1     1    1     NA   0         .p1.  0.10   0 #> 2  2   y  ~   m     1    1     1    2     NA   0         .p2.  0.30   0 #> 3  3   y  ~   x     1    1     1    3     NA   0         .p3.  0.00   0 #> 4  4   m ~~   m     1    0     1    4     NA   0         .p4.  0.99   1 #> 5  5   y ~~   y     1    0     1    5     NA   0         .p5.  0.91   1 #> 6  6   x ~~   x     1    0     1    6     NA   0         .p6.  1.00   1  identical(ptable_model2_a,           ptable_model2_b) #> [1] TRUE  # model_matrices_pop  model_matrices_pop(ptable_final1) #> $lambda #>     m1 m2 y x c1 x2 w x:w #> m1   0  0 0 0  0  0 0   0 #> m2   0  0 0 0  0  0 0   0 #> y    0  0 0 0  0  0 0   0 #> x    0  0 0 0  0  0 0   0 #> c1   0  0 0 0  0  0 0   0 #> x2   0  0 0 0  0  0 0   0 #> w    0  0 0 0  0  0 0   0 #> x:w  0  0 0 0  0  0 0   0 #>  #> $theta #>     m1 m2 y x c1 x2 w x:w #> m1   0                    #> m2   0  0                 #> y    0  0 0               #> x    0  0 0 0             #> c1   0  0 0 0  0          #> x2   0  0 0 0  0  0       #> w    0  0 0 0  0  0 0     #> x:w  0  0 0 0  0  0 0   0 #>  #> $psi #>        m1    m2     y     x    c1    x2     w   x:w #> m1  0.910                                           #> m2  0.000 0.990                                     #> y   0.000 0.000 0.651                               #> x   0.000 0.000 0.000 1.000                         #> c1  0.000 0.000 0.000 0.000 1.000                   #> x2  0.000 0.000 0.000 0.000 0.000 1.000             #> w   0.000 0.000 0.000 0.100 0.000 0.000 1.000       #> x:w 0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000 #>  #> $beta #>      m1  m2 y    x c1 x2   w  x:w #> m1  0.0 0.0 0 -0.3  0  0 0.0 0.00 #> m2  0.1 0.0 0  0.0  0  0 0.0 0.00 #> y   0.0 0.5 0  0.3  0  0 0.1 0.05 #> x   0.0 0.0 0  0.0  0  0 0.0 0.00 #> c1  0.0 0.0 0  0.0  0  0 0.0 0.00 #> x2  0.0 0.0 0  0.0  0  0 0.0 0.00 #> w   0.0 0.0 0  0.0  0  0 0.0 0.00 #> x:w 0.0 0.0 0  0.0  0  0 0.0 0.00 #>  #> attr(,\"model\") #> [1] \"\\nm1 ~ x + c1\\nm2 ~ m1 + x2 + c1\\ny ~  m2 + m1 + x + w + x:w + c1\\n\"  model_matrices_pop(model1,                    pop_es = model1_es) #> $lambda #>     m1 m2 y x c1 x2 w x:w #> m1   0  0 0 0  0  0 0   0 #> m2   0  0 0 0  0  0 0   0 #> y    0  0 0 0  0  0 0   0 #> x    0  0 0 0  0  0 0   0 #> c1   0  0 0 0  0  0 0   0 #> x2   0  0 0 0  0  0 0   0 #> w    0  0 0 0  0  0 0   0 #> x:w  0  0 0 0  0  0 0   0 #>  #> $theta #>     m1 m2 y x c1 x2 w x:w #> m1   0                    #> m2   0  0                 #> y    0  0 0               #> x    0  0 0 0             #> c1   0  0 0 0  0          #> x2   0  0 0 0  0  0       #> w    0  0 0 0  0  0 0     #> x:w  0  0 0 0  0  0 0   0 #>  #> $psi #>       m1   m2    y    x   c1   x2    w  x:w #> m1  0.91                                    #> m2  0.00 0.99                               #> y   0.00 0.00 0.65                          #> x   0.00 0.00 0.00 1.00                     #> c1  0.00 0.00 0.00 0.00 1.00                #> x2  0.00 0.00 0.00 0.00 0.00 1.00           #> w   0.00 0.00 0.00 0.10 0.00 0.00 1.00      #> x:w 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1.00 #>  #> $beta #>      m1  m2 y    x c1 x2   w  x:w #> m1  0.0 0.0 0 -0.3  0  0 0.0 0.00 #> m2  0.1 0.0 0  0.0  0  0 0.0 0.00 #> y   0.0 0.5 0  0.3  0  0 0.1 0.05 #> x   0.0 0.0 0  0.0  0  0 0.0 0.00 #> c1  0.0 0.0 0  0.0  0  0 0.0 0.00 #> x2  0.0 0.0 0  0.0  0  0 0.0 0.00 #> w   0.0 0.0 0  0.0  0  0 0.0 0.00 #> x:w 0.0 0.0 0  0.0  0  0 0.0 0.00 #>  #> attr(,\"model\") #> [1] \"\\nm1 ~ x + c1\\nm2 ~ m1 + x2 + c1\\ny ~  m2 + m1 + x + w + x:w + c1\\n\""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Beta Distribution — rbeta_rs","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"Generate random numbers beta distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"","code":"rbeta_rs(n = 10, shape1 = 0.5, shape2 = 0.5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"n number random numbers generate. shape1 shape1 stats::rbeta(). shape2 shape2 stats::rbeta(). pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"First, specify two parameters, shape1 shape2, desired population mean standard deviation. random numbers, drawn beta distribution stats::rbeta() rescaled desired population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"","code":"set.seed(90870962) x <- rbeta_rs(n = 5000,               shape1 = .5,               shape2 = .5,               pmean = 3,               psd = 1) mean(x) #> [1] 3.003229 sd(x) #> [1] 0.9983932 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"Generate random numbers beta distribution, rescaled user-specified population mean standard deviation, within specific range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"","code":"rbeta_rs2(n = 10, bmean, bsd, blow = 0, bhigh = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"n number random numbers generate. bmean population mean. bsd population standard deviation. bsd zero negative, random numbers equal bmean. blow lower bound target range. bhigh upper bound target range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"First, specify two parameters, shape1 shape2, desired population mean standard deviation. random numbers, drawn beta distribution stats::rbeta() rescaled desired population range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"","code":"set.seed(90870962) x <- rbeta_rs2(n = 5000,                bmean = .80,                bsd = .10,                blow = .00,                bhigh = .95) mean(x) #> [1] 0.7991104 sd(x) #> [1] 0.1005175 hist(x)  y <- rbeta_rs2(n = 5000,                bmean = 4,                bsd = 3,                blow = -10,                bhigh = 10) mean(y) #> [1] 4.003419 sd(y) #> [1] 3.045306 hist(y)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Binary Variable — rbinary_rs","title":"Random Binary Variable — rbinary_rs","text":"Generate random numbers distribution 0 1, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Binary Variable — rbinary_rs","text":"","code":"rbinary_rs(n = 10, p1 = 0.5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Binary Variable — rbinary_rs","text":"n number random numbers generate. p1 probability 1, rescaling. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Binary Variable — rbinary_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Binary Variable — rbinary_rs","text":"First, specify probability 1 (p1), desired population mean standard deviation. random numbers, drawn distribution 0 (1 - p1 probability) 1 (p1 probability), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Binary Variable — rbinary_rs","text":"","code":"set.seed(90870962) x <- rbinary_rs(n = 5000,                 p1 = .5,                 pmean = 3,                 psd = 1) mean(x) #> [1] 3.0244 sd(x) #> [1] 0.9998023 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":null,"dir":"Reference","previous_headings":"","what":"Rejection Rates — rejection_rates","title":"Rejection Rates — rejection_rates","text":"Get rejection rates tests stored power4test object supported objects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rejection Rates — rejection_rates","text":"","code":"rejection_rates(object, ...)  # Default S3 method rejection_rates(object, ...)  # S3 method for class 'power4test' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'power4test_by_es' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'power4test_by_n' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'rejection_rates_df' print(x, digits = 3, annotation = TRUE, abbreviate_col_names = TRUE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rejection Rates — rejection_rates","text":"object object rejection rates computed, power4test object, power4test_by_n object, power4test_by_es object. ... Optional arguments. print method, arguments passed print method data.frame objects print.data.frame(). used methods. all_columns TRUE, columns stored test extracted. Default FALSE essential columns related power printed. ci TRUE, confidence intervals rejection rates (column reject sig) computed. Normal approximation used forming confidence intervals. level level confidence confidence intervals, ci TRUE. Default .95, denoting 95%. se TRUE, standard errors rejection rates (column reject sig) computed. Normal approximation used compute standard errors. x rejection_rates_df object printed. digits number digits printed decimal. annotation Logical. Whether additional notes printed. abbreviate_col_names Logical. Whether column names abbreviated.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rejection Rates — rejection_rates","text":"rejection_rates method returns rejection_rates_df object, print method. input (object) power4test object, output data-frame like object number rows equal number tests. Note tests, test test_parameters(), conduct one test parameters. test counted one test. data frame least columns: test: name test. label: label test, \"Test\" test one test (e.g., test_indirect_effect()). pvalid: proportion valid tests across replications. reject: rejection rate test. null hypothesis false, power. rejection_rates method power4test_by_es objects returns object class rejection_rates_df_by_es, subclass rejection_rates_df. data frame similar output rejection_rates(), two columns added effect size (pop_es_name pop_es_values) test. rejection_rates method power4test_by_n objects returns object class rejection_rates_df_by_n, subclass rejection_rates_df. data frame similar output power4test object, column n added sample size test. print method rejection_rates_df object return object invisibly. called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rejection Rates — rejection_rates","text":"power4test object, loops tests stored power4test object retrieves rejection rate test. rejection_rates method power4test_by_es objects used compute rejection rates power4test_by_es object, effect sizes added output. rejection_rates method power4test_by_n objects used compute rejection rates, sample sizes added output.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rejection Rates — rejection_rates","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Generate some datasets to check the model  sim_only <- power4test(nrep = 4,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 50,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  # Do the test 'test_indirect_effect' on each datasets  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_indirect: x->m->y   # Do the test 'test_parameters' on each datasets # and add the results to 'test_out'  test_out <- power4test(object = test_out,                        test_fun = test_parameters) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs    # Compute and print the rejection rates for stored tests  rejection_rates(test_out) #>                     test test_label   p.v reject r.cilo r.cihi #> 1 test_indirect: x->m->y       Test 1.000  1.000  1.000  1.000 #> 2  test_parameters: CIs         m~x 1.000  1.000  1.000  1.000 #> 3  test_parameters: CIs         y~m 1.000  1.000  1.000  1.000 #> 4  test_parameters: CIs         y~x 1.000  0.000  0.000  0.000 #> Notes: #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns.  # See the help pages of power4test_by_n() and power4test_by_es() # for other examples."},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From an Exponential Distribution — rexp_rs","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"Generate random numbers exponential distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"","code":"rexp_rs(n = 10, rate = 1, pmean = 0, psd = 1, rev = FALSE)"},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"n number random numbers generate. rate rate stats::rexp(). pmean Population mean. psd Population standard deviation. rev TRUE, distribution revered generate negatively skewed distribution. Default FALSE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"First, specify parameter, rate, desired population mean standard deviation. random numbers, drawn exponential distribution stats::rexp(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"","code":"set.seed(90870962) x <- rexp_rs(n = 5000,              rate = 4,              pmean = 3,              psd = 1) mean(x) #> [1] 2.999214 sd(x) #> [1] 1.008795 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Lognormal Distribution — rlnorm_rs","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"Generate random numbers lognormal distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"","code":"rlnorm_rs(n = 10, mui = 0, sigma = 1, rev = FALSE, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"n number random numbers generate. mui parameter mui used stats::rlnorm(). sigma parameter sigma used stats::rlnorm(). rev TRUE, distribution revered generate negatively skewed distribution. Default FALSE. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"First, specify parameter, mui sigma, desired population mean standard deviation. random numbers, drawn lognormal distribution stats::rlnorm(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"","code":"set.seed(90870962) x <- rlnorm_rs(n = 5000, mui = 0, sigma = 1, pmean = 0, psd = 1) mean(x) #> [1] -0.005312214 sd(x) #> [1] 0.9400859 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"Generate random numbers generalized normal distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"","code":"rpgnorm_rs(n = 10, p = 2, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"n number random numbers generate. p parameter distribution. Must positive non-zero number. Default 2, resulting normal distribution. Higher 2 results negative excess kurtosis. Lower 2 results positive excess kurtosis. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"First, specify parameter p desired population mean standard deviation. random numbers, drawn generalized normal distribution pgnorm::rpgnorm(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"","code":"set.seed(90870962) x <- rpgnorm_rs(n = 5000,                 p = 2,                 pmean = 0, psd = 1) mean(x) #> [1] -0.01118704 sd(x) #> [1] 1.010004 hist(x)  x_kurt <- function(p) {gamma(5/p)*gamma(1/p)/(gamma(3/p)^2) - 3} p <- 6 x <- rpgnorm_rs(n = 50000, p = p, pmean = 0, psd = 1) mean(x) #> [1] 0.002266498 sd(x) #> [1] 1.001834 x_kurt(p) #> [1] -1 qqnorm(x); qqline(x)  p <- 1 x <- rpgnorm_rs(n = 50000, p = p, pmean = 0, psd = 1) mean(x) #> [1] 0.007350372 sd(x) #> [1] 0.9993787 x_kurt(p) #> [1] 3 qqnorm(x); qqline(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a t Distribution — rt_rs","title":"Random Variable From a t Distribution — rt_rs","text":"Generate random numbers t distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a t Distribution — rt_rs","text":"","code":"rt_rs(n = 10, df = 5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a t Distribution — rt_rs","text":"n number random numbers generate. df df stats::rt(). pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a t Distribution — rt_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a t Distribution — rt_rs","text":"First, specify parameter df desired population mean standard deviation. random numbers, drawn generalized normal distribution stats::rt(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a t Distribution — rt_rs","text":"","code":"set.seed(90870962) x <- rt_rs(n = 5000,            df = 5,            pmean = 3,            psd = 1) mean(x) #> [1] 3.004783 sd(x) #> [1] 0.9926204 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Uniform Distribution — runif_rs","title":"Random Variable From a Uniform Distribution — runif_rs","text":"Generate random numbers uniform distribution, user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Uniform Distribution — runif_rs","text":"","code":"runif_rs(n = 10, min = 0, max = 1, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Uniform Distribution — runif_rs","text":"n number random numbers generate. min min runif. max max runif. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Uniform Distribution — runif_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Uniform Distribution — runif_rs","text":"First, user specifies parameters, min max, desired population mean standard deviation. random numbers generated rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Uniform Distribution — runif_rs","text":"","code":"set.seed(90870962) x <- runif_rs(n = 5000, min = 2, max = 4, pmean = 3, psd = 1) mean(x) #> [1] 2.987606 sd(x) #> [1] 0.9978981 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Datasets Based on a Model — sim_data","title":"Simulate Datasets Based on a Model — sim_data","text":"Get model matrix effect size specification simulate number datasets, along information.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Datasets Based on a Model — sim_data","text":"","code":"sim_data(   nrep = 10,   ptable = NULL,   model = NULL,   pop_es = NULL,   ...,   n = 100,   iseed = NULL,   number_of_indicators = NULL,   reliability = NULL,   x_fun = list(),   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )  # S3 method for class 'sim_data' print(   x,   digits = 3,   digits_descriptive = 2,   data_long = TRUE,   fit_to_all_args = list(),   est_type = \"standardized\",   variances = NULL,   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Datasets Based on a Model — sim_data","text":"nrep number replications generate simulated datasets. Default 10. ptable output ptable_pop(), ptable_pop object, representing population model. NULL, default, ptable_pop() called generate ptable_pop object, using arguments model pop_es. model lavaan model syntax population model. Ignored ptable specified. See ptable_pop specify argument. pop_es character specify population effect sizes. See ptable_pop specify argument. Ignored ptable specified. ... sim_data, parameters passed ptable_pop(). print.sim_data(), arguments ignored. n sample size dataset. Default 100. iseed seed random number generator. Default NULL seed changed. number_of_indicators named vector specify number indicators factors. See help page set argument. Default NULL variables model syntax observed variables. See help page use argument. reliability named vector (single-group model) named list named vectors (multigroup model) set reliability coefficient set indicators. Default NULL. See help page use argument. x_fun function(s) used generate exogenous variables. supplied, set list(), default, variables generated multivariate normal distribution. See help page use argument. parallel TRUE, parallel processing used simulate datasets. Default FALSE. progress TRUE, progress data simulation displayed. Default `FALSE. ncores number CPU cores use parallel processing used. x sim_data object printed. digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. data_long TRUE, detailed information printed. fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined samples stored. est_type type estimates printed. Can character vector one two elements. \"standardized\", standardized estimates printed. \"unstandardized\", unstandardized estimates printed. vector like c(\"standardized\", \"unstandardized\"), unstandardized standardized estimates printed. variances Logical. Whether variances error variances printed. Default depends est_type. \"unstandardized\" est_type, default TRUE \"standardized\" est_type, default FALSE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_out() returns list class sim_data, length nrep. element sim_data_i object, following major elements: ptable: lavaan parameter table model, population values set column start. (output function ptable_pop().) mm_out: population model represented model matrices lavaan. (output function model_matrices_pop().) mm_lm_out: list regression model formula, one endogenous variable. (output internal function mm_lm().) mm_lm_dat_out: simulated dataset generated population model. (output internal function mm_lm_data()). model_original: original model syntax (.e., argument model). model_final: modified model syntax model latent variable model. Indicators added syntax. fit0: output lavaan::sem() ptable model .fit set FALSE. Used easy retrieval information model. print method sim_data returns x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() generates list datasets based population model.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"the-role-of-sim-data-","dir":"Reference","previous_headings":"","what":"The role of sim_data()","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"workflow","dir":"Reference","previous_headings":"","what":"Workflow","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() two tasks: Determine actual population model population values based : model syntax observed variables (path model) latent factors (latent variable model). textual specification effect sizes parameters. number indicators latent factor model latent variable model. reliability latent factor measured indicators model latent factor model. Generate nrep simulated datasets population model. simulated datasets can used fit model, test parameters, estimate power. output usually used fit_model() fit target model, default population model, dataset.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"set-number-of-indicators-and-reliability-","dir":"Reference","previous_headings":"","what":"Set 'number_of_indicators' and 'reliability'","title":"Simulate Datasets Based on a Model — sim_data","text":"arguments number_of_indicators reliability used specify number indicators (e.g., items) factor, population reliability coefficient factor, variables model syntax latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"variable model replaced indicators generated data, set number_of_indicators named numeric vector. names variables variables indicators, appeared model syntax. value name number indicators. argument reliability set named numeric vector (list, see section multigroup models) specify population reliability coefficient (\"omega\") set indicators. population standardized factor loadings computed ensure population reliability coefficient target value. examples single group model: numbers indicators m, x, y 3, 4, 5, respectively. population reliability coefficients m, x, y .90, .80, .70, respectively.","code":"number of indicator = c(m = 3, x = 4, y = 5) reliability = c(m = .90, x = .80, y = .70)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-models","dir":"Reference","previous_headings":"","what":"Multigroup Models","title":"Simulate Datasets Based on a Model — sim_data","text":"Multigroup models supported. number groups inferred pop_es (see help page ptable_pop()), directly ptable. multigroup model, number indicators variable must across groups. However, population reliability coefficients can different across groups. multigroup model k groups, one population reliability coefficients differ across groups, argument reliability set named list. names variables population reliability coefficients set. element name either single value common reliability coefficient, numeric vector reliability coefficient group. example reliability model 2 groups: reliability coefficients x .80 groups, reliability coefficients m .70 one group .80 another.","code":"reliability = list(x = .80, m = c(.70, .80))"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"equal-numbers-of-indicators-and-or-reliability-coefficients","dir":"Reference","previous_headings":"","what":"Equal Numbers of Indicators and/or Reliability Coefficients","title":"Simulate Datasets Based on a Model — sim_data","text":"variables model number indicators, number_of_indicators can set one single value. Similarly, sets indicators population reliability groups, reliability can also set one single value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-the-distributions-of-exogenous-variables-using-x-fun-","dir":"Reference","previous_headings":"","what":"Specify The Distributions of Exogenous Variables Using 'x_fun'","title":"Simulate Datasets Based on a Model — sim_data","text":"default, variables generated multivariate normal distribution. desired, users can supply function used generate exogenous variables setting x_fun named list. names list variables user function used generate data. element list must also list. first element list, can unnamed, function used. arguments need supplied, included named elements list. example: variables x w generated user-supplied functions. x, function power4mome::rexp_rs. additional argument calling function. w, function power4mome::rbinary_rx. argument p1 = .70 passed function generating values w. requirements user-functions: must return numeric vector. mush argument n number values. population mean standard deviation generated values must 0 1, respectively. package power4mome helper functions generating values common nonnormal distributions scaling population mean standard deviation equal 0 1 (default), respectively. : rbinary_rs(). rexp_rs(). rbeta_rs(). rlnorm_rs(). rpgnorm_rs(). use x_fun, variables must zero covariances variables population. possible generate nonnormal multivariate data believe rarely needed estimating power data.","code":"x_fun = list(x = list(power4mome::rexp_rs),              w = list(power4mome::rbinary_rs,                       p1 = .70)))"},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Simulate Datasets Based on a Model — sim_data","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Simulate Datasets Based on a Model — sim_data","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Simulate Datasets Based on a Model — sim_data","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-3","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Simulate Datasets Based on a Model — sim_data","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Simulate Datasets Based on a Model — sim_data","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Simulate Datasets Based on a Model — sim_data","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Datasets Based on a Model — sim_data","text":"","code":"# Specify the model  mod <- \"m ~ x  y ~ m + x\"  # Specify the population values  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate the simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  data_all #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #>  y ~ m + x #> == Model on Variables/Indicators == #> m ~ x #>  y ~ m + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.910   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.090 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars   n  mean   sd  skew kurtosis   se #> m    1 500 -0.03 1.00 -0.09    -0.03 0.04 #> y    2 500 -0.01 0.98  0.03     0.41 0.04 #> x    3 500  0.01 0.94 -0.21     0.17 0.04 #>  #> ===== Parameter Estimates Based on All 5 Samples Combined ===== #>  #> Total Sample Size: 500  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.323 #>   y ~                       #>     m                 0.277 #>     x                -0.098 #>"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a 'sim_out' Object — sim_out","title":"Create a 'sim_out' Object — sim_out","text":"Combine outputs sim_data(), fit_model(), optionally gen_mc() /gen_boot() one single object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a 'sim_out' Object — sim_out","text":"","code":"sim_out(data_all, ...)  # S3 method for class 'sim_out' print(x, digits = 3, digits_descriptive = 2, fit_to_all_args = list(), ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a 'sim_out' Object — sim_out","text":"data_all output sim_data(). ... Named arguments objects added replication element extra. example, set fit = fit_all, fit_all output fit_model(), data_all[[1]]$extra$fit set first output fit_all. x sim_out object printed. digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined ","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a 'sim_out' Object — sim_out","text":"function sim_out() returns sim_out object, list length equal length data_all. element list sim_data object element extra added . named elements added name. example. output fit_model() replication can added fit, extra. See description argument ... details. print method sim_out returns x invisibly. Called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a 'sim_out' Object — sim_out","text":"merges one object output sim_data(), list nrep simulated datasets, fit_model(), list lavaan::sem() output nrep datasets, optionally output gen_mc() gen_boot(), list R sets Monte Carlo bootstrap estimates based results fit_model(). list nrep elements, element data, model fit results, optionally Monte Carlo estimates matched. object can used testing effects interests, processed estimate power test. function sim_out() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a 'sim_out' Object — sim_out","text":"","code":"# Specify the model  mod <- \"m ~ x  y ~ m + x\"  # Specify the population values  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate the simulated datasets  dats <- sim_data(nrep = 5,                  model = mod,                  pop_es = es,                  n = 100,                  iseed = 1234)  # Fit the population model to each dataset  fits <- fit_model(dats)  # Combine the results to one object  sim_out_all <- sim_out(data_all = dats,                        fit = fits) sim_out_all #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #>  y ~ m + x #> == Model on Variables/Indicators == #> m ~ x #>  y ~ m + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.910   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.090 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars   n  mean   sd  skew kurtosis   se #> m    1 500 -0.03 1.00 -0.09    -0.03 0.04 #> y    2 500 -0.01 0.98  0.03     0.41 0.04 #> x    3 500  0.01 0.94 -0.21     0.17 0.04 #>  #> ===== Parameter Estimates Based on All 5 Samples Combined ===== #>  #> Total Sample Size: 500  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.323 #>   y ~                       #>     m                 0.277 #>     x                -0.098 #>   # Verify that the elements of fits are set to extra$fit  library(lavaan) #> This is lavaan 0.6-19 #> lavaan is FREE software! Please report any bugs. parameterEstimates(fits[[1]]) #>   lhs op rhs   est    se     z pvalue ci.lower ci.upper #> 1   m  ~   x 0.382 0.099 3.837  0.000    0.187    0.577 #> 2   y  ~   m 0.266 0.103 2.591  0.010    0.065    0.467 #> 3   y  ~   x 0.108 0.109 0.990  0.322   -0.106    0.322 #> 4   m ~~   m 0.903 0.128 7.071  0.000    0.653    1.153 #> 5   y ~~   y 0.951 0.134 7.071  0.000    0.687    1.214 #> 6   x ~~   x 0.913 0.000    NA     NA    0.913    0.913 parameterEstimates(sim_out_all[[1]]$extra$fit) #>   lhs op rhs   est    se     z pvalue ci.lower ci.upper #> 1   m  ~   x 0.382 0.099 3.837  0.000    0.187    0.577 #> 2   y  ~   m 0.266 0.103 2.591  0.010    0.065    0.467 #> 3   y  ~   x 0.108 0.109 0.990  0.322   -0.106    0.322 #> 4   m ~~   m 0.903 0.128 7.071  0.000    0.653    1.153 #> 5   y ~~   y 0.951 0.134 7.071  0.000    0.687    1.214 #> 6   x ~~   x 0.913 0.000    NA     NA    0.913    0.913 parameterEstimates(fits[[2]]) #>   lhs op rhs    est    se      z pvalue ci.lower ci.upper #> 1   m  ~   x  0.383 0.108  3.559  0.000    0.172    0.594 #> 2   y  ~   m  0.208 0.104  1.995  0.046    0.004    0.413 #> 3   y  ~   x -0.172 0.119 -1.442  0.149   -0.406    0.062 #> 4   m ~~   m  0.988 0.140  7.071  0.000    0.714    1.262 #> 5   y ~~   y  1.078 0.153  7.071  0.000    0.780    1.377 #> 6   x ~~   x  0.854 0.000     NA     NA    0.854    0.854 parameterEstimates(sim_out_all[[2]]$extra$fit) #>   lhs op rhs    est    se      z pvalue ci.lower ci.upper #> 1   m  ~   x  0.383 0.108  3.559  0.000    0.172    0.594 #> 2   y  ~   m  0.208 0.104  1.995  0.046    0.004    0.413 #> 3   y  ~   x -0.172 0.119 -1.442  0.149   -0.406    0.062 #> 4   m ~~   m  0.988 0.140  7.071  0.000    0.714    1.262 #> 5   y ~~   y  1.078 0.153  7.071  0.000    0.780    1.377 #> 6   x ~~   x  0.854 0.000     NA     NA    0.854    0.854"},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Test Results — summarize_tests","title":"Summarize Test Results — summarize_tests","text":"Extract summarize test results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Test Results — summarize_tests","text":"","code":"summarize_tests(object)  # S3 method for class 'test_summary_list' print(x, digits = 3, ...)  # S3 method for class 'test_summary' print(x, digits = 2, ...)  # S3 method for class 'test_out_list' print(x, digits = 3, test_long = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Test Results — summarize_tests","text":"object power4test object element test_all power4test object. x object printed. digits numbers digits decimal printing numeric results. ... Optional arguments. used. test_long TRUE, detailed report printed.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() returns list class test_summary_list. element contains summary test stored. elements class test_summary, elements: test_attributes: stored information test, printing. nrep: number datasets (replications). mean: means numeric information. significance tests, rejection rates. nvalid: number non-NA replications used compute mean. print methods returns x invisibly. called side effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() used extract information test stored power4test object. method print.test_out_list() used print content list test stored power4test object, option print just names tests.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"the-role-of-summarize-tests-and-related-functions","dir":"Reference","previous_headings":"","what":"The role of summarize_tests() and related functions","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() related print methods used --one function power4test() summary method. Users usually call directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Test Results — summarize_tests","text":"","code":"# Specify the model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulated datasets  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s):  # Test the parameters in each dataset  test_out <- power4test(object = sim_only,                        test_fun = test_parameters) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs    # Print the summary  summarize_tests(test_out) #>  #> =============== <test_parameters: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #> 4       m~~m   m ~~   m  0.945 0.134  7.071  0.000  0.683 1.207 1.000 #> 5       y~~y   y ~~   y  0.836 0.118  7.071  0.000  0.604 1.068 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize 'x_from_power' Results — summary.x_from_power","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"summary method output x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"","code":"# S3 method for class 'x_from_power' summary(object, ...)  # S3 method for class 'summary.x_from_power' print(x, digits = 3, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"object x_from_power-class object, output x_from_power(). ... Additional arguments. used now. x output summary.x_from_power(), summary method x_from_power object, output x_from_power(). digits number digits decimal printing results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"returns object class summary.x_from_power, simply output x_from_power(), print method dedicated detailed summary. Please refer x_from_power() contents. print-method summary.x_from_power objects returns object x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"simply prepares results x_from_power() printed details.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 10,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 10,                            xs_per_trial = 1,                            nrep_steps = 1,                            max_trials = 1,                            seed = 4567) #>  #> --- Pre-iteration Search --- #>  #> - Start at 2025-06-02 11:59:14  #> - Value(s) to try:  125  #>  #> Updating the simulation for sample size: 125  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> - Power Curve: #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -75.3328       0.7672   #>  #> Degrees of Freedom: 19 Total (i.e. Null);  18 Residual #> Null Deviance:\t    13  #> Residual Deviance: 10.01 \tAIC: 14.01 #>  #>  #>  #> --- Trial 1 --- #>  #> - Start at 2025-06-02 11:59:18  #> - Value(s) to try: 98, 101  #> - Numbers of replications: 10, 10  #>  #> Updating the simulation for sample size: 98  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Updating the simulation for sample size: 101  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  98 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 101 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> 4 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - 'nls()' estimation failed. Switch to logistic regression. #>  #> Updating the simulation for sample size: 102  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Extrapolated value: 102  #> - Estimated power for 102: 1.0000 #> - 'nls()' estimation failed. Switch to logistic regression. #> - Power Curve: #> Call: #> power_curve(object = by_x_1, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -20.886        0.226   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    30.14  #> Residual Deviance: 26.78 \tAIC: 30.78 #>  #> - Estimated power is close enough to target power (0.8000). (CI: [0.7141,1.0859]) #>  #>  #> --- Final Stage --- #>  #> - Start at 2025-06-02 11:59:30  #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  98 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 101 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> 4 102 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> 5 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #> Call: #> power_curve(object = by_x_1, formula = power_model, start = stats::coef(fit_1),  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -41.3415       0.4333   #>  #> Degrees of Freedom: 49 Total (i.e. Null);  48 Residual #> Null Deviance:\t    32.51  #> Residual Deviance: 28.31 \tAIC: 32.31 #>  #>  #> - Final Value: 101  #> - Final Estimated Power: 0.9000  #> - Confidence Interval: [0.7141; 1.0859] #> - CI Level: 95.00% summary(power_vs_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = test_out, x = \"n\", target_power = 0.8,  #>     xs_per_trial = 1, progress = TRUE, max_trials = 1, final_nrep = 10,  #>     nrep_steps = 1, seed = 4567) #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #>  #> === Major Results === #>  #> - Final Value: 101  #> - Final Estimated Power: 0.900  #> - Confidence Interval: [0.714; 1.086] #> - Level of confidence: 95.0% #> - Based on 10 replications. #>  #> === Technical Information === #>  #> - The range of values explored: 98 to 125  #> - Time spent in the search: 15.42 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = stats::coef(fit_1),  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -41.3415       0.4333   #>  #> Degrees of Freedom: 49 Total (i.e. Null);  48 Residual #> Null Deviance:\t    32.51  #> Residual Deviance: 28.31 \tAIC: 32.31 #>  #> - Detailed Results: #>  #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  98 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 101 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> 4 102 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> 5 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a Conditional Indirect Effect — test_cond_indirect","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"Test conditional indirect effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"","code":"test_cond_indirect(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   wvalues = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"fit fit object, passed manymome::cond_indirect(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. wvalues numeric vector named elements. names variable names moderators, values values moderators set . Default NULL. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. ... Additional arguments passed manymome::cond_indirect(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"function used power4test() testing conditional indirect effect, setting test_fun argument. uses manymome::cond_indirect() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm(). can also used test conditional effect direct path mediator. Just omit m calling function.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"","code":"# Specify the model  model_simple_mod <- \" m ~ x + w + x:w y ~ m + x \"  # Specify the population values  model_simple_mod_es <- \" y ~ m: l y ~ x: n m ~ x: m m ~ w: n m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_mod,                        pop_es = model_simple_mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_cond_indirect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         wvalues = c(w = 1),                                         mc_ci = TRUE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_cond_indirect: x->m->y (w = 1)  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.000   #>     x:w               0.150   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.886   #>    .y                 0.750   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #> w -> m -> y 0.000 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.530 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.104 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ======== <test_cond_indirect: x->m->y (w = 1)> ======== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.206 0.066 0.376 0.800 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 5  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"Test several conditional indirect effects power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"","code":"test_cond_indirect_effects(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   wlevels = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"fit fit object, passed manymome::cond_indirect_effects(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. wlevels output manymome::merge_mod_levels(), moderator(s) passed manymome::mod_levels_list(). moderators can represented one variable, , moderator () numeric variable, (b) dichotomous categorical variable, (c) factor string variable used stats::lm() fit, vector names moderators appeared data frame. least one moderators categorical variable represented one variable, user-created dummy variables used lavaan::sem(), must list names moderators, moderators represented vector names. example: list(\"w1\", c(\"gpgp2\", \"gpgp3\"), first moderator w1 second moderator three-category variable represented gpgp2 gpgp3. See help page manymome::cond_indirect_effects() details. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. ... Additional arguments passed manymome::cond_indirect_effects(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"normal usage, returns output returned manymome::cond_indirect_effects(), following modifications: est: estimated conditional indirect effects. cilo cihi: lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated label conditional effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"function used power4test() testing several conditional indirect effects, setting test_fun argument. uses manymome::cond_indirect_effects() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm(). can also used test conditional effects direct path mediator. Just omit m calling function.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"","code":"# Specify the model  model_simple_mod <- \" m ~ x + w + x:w y ~ m + x \"  # Specify the population values  model_simple_mod_es <- \" y ~ m: l y ~ x: n m ~ x: m m ~ w: n m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_mod,                        pop_es = model_simple_mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the tests in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_cond_indirect_effects,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         wlevels = c(\"w\"),                                         mc_ci = TRUE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_cond_indirect_effects: x->m->y  print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.000   #>     x:w               0.150   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.886   #>    .y                 0.750   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #> w -> m -> y 0.000 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.530 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.104 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ======== <test_cond_indirect_effects: x->m->y> ======== #>  #> Mean(s) across replication: #>             test_label     [w]    (w)   est   cilo  cihi   sig   m~x   y~m #> 1 x->m->y | w: M+1.0SD M+1.0SD  1.060 0.212  0.067 0.385 0.800 0.438 0.474 #> 2    x->m->y | w: Mean    Mean  0.061 0.132  0.036 0.250 0.800 0.275 0.474 #> 3 x->m->y | w: M-1.0SD M-1.0SD -0.939 0.053 -0.086 0.202 0.000 0.112 0.474 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 5  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a Moderated Mediation Effect — test_index_of_mome","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"Test moderated mediation effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"","code":"test_index_of_mome(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   w = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"fit fit object, passed manymome::index_of_mome(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. w name moderator. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. ... Additional arguments passed manymome::index_of_mome(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"function used power4test() testing moderated mediation effect, setting test_fun argument. uses manymome::index_of_mome() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"","code":"# Specify the model  mod <- \" m ~ x + w + x:w y ~ m \"  # Specify the population values  mod_es <- \" m ~ x: n y ~ x: m m ~ w: l m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_index_of_mome,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         w = \"w\",                                         mc_ci = TRUE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_index_of_mome: x->m->y, moderated by w   print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.000   #>     w                 0.500   #>     x:w               0.150   #>   y ~                         #>     m                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.726   #>    .y                 1.000   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>             ind #> x -> m -> y   0 #> w -> m -> y   0 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         6 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 5.501 #>   Degrees of freedom                                 3 #>   P-value (Chi-square)                           0.139 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ==== <test_index_of_mome: x->m->y, moderated by w> ==== #>  #> Mean(s) across replication: #>     est   cilo  cihi   sig #>  -0.006 -0.049 0.027 0.000 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 2  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Test an Indirect Effect — test_indirect_effect","title":"Test an Indirect Effect — test_indirect_effect","text":"Test indirect effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test an Indirect Effect — test_indirect_effect","text":"","code":"test_indirect_effect(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test an Indirect Effect — test_indirect_effect","text":"fit fit object, passed manymome::indirect_effect(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. ... Additional arguments passed manymome::indirect_effect(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test an Indirect Effect — test_indirect_effect","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test an Indirect Effect — test_indirect_effect","text":"function used power4test() testing indirect effect, setting test_fun argument. uses manymome::indirect_effect() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test an Indirect Effect — test_indirect_effect","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         mc_ci = TRUE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_indirect: x->m->y  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.163 0.051 0.296 1.000 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 5  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test All Moderation Effects — test_moderation","title":"Test All Moderation Effects — test_moderation","text":"Test moderation effects testing product terms power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test All Moderation Effects — test_moderation","text":"","code":"test_moderation(   fit = fit,   standardized = FALSE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test All Moderation Effects — test_moderation","text":"fit fit object, passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). standardized Logical. TRUE, lavaan::standardizedSolution() used. Can used models fitted lavaan. ... Additional arguments passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). fit_name name fit results parameter names displayed. Default \"fit\". get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test All Moderation Effects — test_moderation","text":"normal usage, returns output returned lavaan::parameterEstimates() lmhelprs::lm_list_to_partable(), following modifications: est: parameter estimates, even standardized estimates requested (est.std). cilo cihi: lower upper limits confidence interval (95% default), respectively (ci.lower ci.upper). sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated lavaan::lav_partable_labels(), usually labels used coef() label parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test All Moderation Effects — test_moderation","text":"function used power4test() testing product terms, setting test_fun argument. just wrapper test_parameters(). first identifies product terms (terms : names), call test_parameters(), pars set select regression coefficients terms.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test All Moderation Effects — test_moderation","text":"","code":"# Specify the model  mod <- \" m ~ x + w1 + x:w1 y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: n y ~ x: m m ~ w1: n m ~ x:w1: l \"  # Simulate the data  sim_only <- power4test(nrep = 4,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s):  # Do the test in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_moderation) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_moderation: CIs    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w1 + x:w1 #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w1 + x:w1 #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.000   #>     w1                0.000   #>     x:w1              0.150   #>   y ~                         #>     m                 0.000   #>     x                 0.300   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w1                0.000   #>     x:w1              0.000   #>   w1 ~~                       #>     x:w1              0.000   #>  #> Variances: #>                    Population #>    .m                 0.977   #>    .y                 0.909   #>     x                 1.000   #>     w1                1.000   #>     x:w1              1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>              ind #> x -> m -> y    0 #> w1 -> m -> y   0 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  4  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.537 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.103 #>  #> =============== <test_moderation: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op  rhs   est    se     z pvalue   cilo  cihi   sig #> 1     m~x:w1   m  ~ x:w1 0.150 0.101 1.557  0.160 -0.047 0.348 0.250 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 4  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Test All Free Parameters — test_parameters","title":"Test All Free Parameters — test_parameters","text":"Test free parameters, including user-defined parameters, power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test All Free Parameters — test_parameters","text":"","code":"test_parameters(   fit = fit,   standardized = FALSE,   pars = NULL,   op = NULL,   remove.nonfree = TRUE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )  find_par_names(object, fit_name = \"fit\")"},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test All Free Parameters — test_parameters","text":"fit fit object, passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). standardized Logical. TRUE, lavaan::standardizedSolution() used. Can used models fitted lavaan. pars Optional. set character vector, parameters test_label equal values pars returned. See help page valid names. op Optional. set character vector, parameters operators (e.g., \"~\", \"=~\") returned. pars op specified, parameters meeting requirements returned. remove.nonfree Logical. TRUE, default, free parameters returned. Ignored standardized TRUE model fitted lavaan. ... Additional arguments passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). fit_name name fit results parameter names displayed. Default \"fit\". get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument. object power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test All Free Parameters — test_parameters","text":"normal usage, returns output returned lavaan::parameterEstimates() lmhelprs::lm_list_to_partable(), following modifications: est: parameter estimates, even standardized estimates requested (est.std). cilo cihi: lower upper limits confidence interval (95% default), respectively (ci.lower ci.upper). sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated lavaan::lav_partable_labels(), usually labels used coef() label parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test All Free Parameters — test_parameters","text":"function used power4test() testing free user-defined model parameters, setting test_fun argument. models fitted lavaan, uses lavaan::parameterEstimates() test. bootstrapping requested (setting se = \"boot\"), supports bootstrap confidence intervals returned lavaan::parameterEstimates(). preliminary, though limited, supported models fitted stats::lm() (lmhelprs::many_lm()). Tests conducted ordinary least squares confidence intervals based t statistic, reported stats::confint() applied output stats::lm().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"find-the-names-of-parameters","dir":"Reference","previous_headings":"","what":"Find the names of parameters","title":"Test All Free Parameters — test_parameters","text":"use argument pars, names appeared function coef() must used. output lavaan, can usually inferred parameter syntax (e.g., y~x, space). sure, call coef() output lavaan. parameter labelled, label used par. sure, function find_par_names() can used find valid names.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test All Free Parameters — test_parameters","text":"","code":"# Specify the model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s):  # Do the tests in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_parameters) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =============== <test_parameters: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #> 4       m~~m   m ~~   m  0.945 0.134  7.071  0.000  0.683 1.207 1.000 #> 5       y~~y   y ~~   y  0.836 0.118  7.071  0.000  0.604 1.068 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000   # Do the tests in each replication: Standardized solution # Delta method SEs will be used to do the tests  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(standardized = TRUE)) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs (standardized)    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ======== <test_parameters: CIs (standardized) > ======== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.347 0.085  4.069  0.000  0.180 0.514 1.000 #> 2        y~m   y  ~   m  0.446 0.086  5.190  0.000  0.277 0.615 1.000 #> 3        y~x   y  ~   x -0.024 0.094 -0.233  0.232 -0.209 0.160 0.000 #> 4       m~~m   m ~~   m  0.880 0.059 14.888  0.000  0.764 0.995 1.000 #> 5       y~~y   y ~~   y  0.791 0.071 11.181  0.000  0.652 0.931 1.000 #> 6       x~~x   x ~~   x  1.000 0.000    NaN    NaN  1.000 1.000 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000   # Do the tests in each replication: Parameters with the selected operator  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(op = \"~\")) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs (op: ~)   print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ============ <test_parameters: CIs (op: ~)> ============ #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000    # Finding valid parameter names  find_par_names(sim_only) #> [1] \"m~x\"  \"y~m\"  \"y~x\"  \"m~~m\" \"y~~y\""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Size and Effect Size Determination — x_from_power","title":"Sample Size and Effect Size Determination — x_from_power","text":"searches simulation sample size (given factors, effect sizes) effect size (given factors, sample size) power detect effect close target value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Size and Effect Size Determination — x_from_power","text":"","code":"x_from_power(   object,   x,   pop_es_name = NULL,   target_power = 0.8,   xs_per_trial = 3,   ci_level = 0.95,   power_min = 0.01,   power_max = 0.9,   x_interval = switch(x, n = c(50, 2000), es = c(0, 0.7)),   extendInt = NULL,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   initial_nrep = 100,   final_nrep = 400,   initial_R = 250,   final_R = 1000,   nrep_steps = 1,   seed = NULL,   x_include_interval = FALSE,   power_model = NULL,   start = NULL,   lower_bound = NULL,   upper_bound = NULL,   nls_control = list(),   nls_args = list(),   save_sim_all = FALSE )  # S3 method for class 'x_from_power' print(x, digits = 3, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Size and Effect Size Determination — x_from_power","text":"object power4test object, output power4test(). Can also power4test_by_n object, output power4test_by_n(), power4test_by_es object, output power4test_by_es(). two types objects, attempt power closest target_power used object, attempts included estimation subsequent attempts final output. Last, can also output previous call x_from_power(), stored trials retrieved. x x_from_power(), x set value searched. Can \"n\", sample size, \"es\", population value parameter (set pop_es_name). print method x_from_power objects, output x_from_power(). pop_es_name name parameter. Required x \"es\". See help page ptable_pop() names argument pop_es. target_power target power, value greater 0 less one. xs_per_trial initial number values (sample sizes population values) consider trial. integer least Rounded integer. ci_level level confidence confidence intervals computed estimated power. Default .95, denoting 95%. power_min, power_max minimum maximum values, respectively, power determining values try trail. Default .01. x_interval vector two values, minimum value maximum values x, search values (sample sizes population values). extendInt Whether x_interval can expanded estimating values try. value passed argument name stats::uniroot(). x \"n\", default value \"upX\". , value higher maximum x_interval allowed, predicted tentative model. Otherwise, default value \"\". See help page stats::uniroot() information. progress Logical. Whether searching progress reported. simulation_progress Logical. Whether progress call power4test(), power4test_by_n(), power4test_by_es() shown. passed progress argument functions. max_trials maximum number trials searching value target power. Rounded integer. initial_nrep initial number replications. set NULL, nrep used object used. higher final_nrep, converted one-fourth final_nrep. lower nrep object conversion, set nrep object. final_nrep number replications final stage, also maximum number replications call power4test(), power4test_by_n(), power4test_by_es(). initial_R initial number Monte Carlo simulation bootstrapping samples. R calling power4test(), power4test_by_n(), power4test_by_es(). set NULL, R used object used. higher final_R, converted one-fourth final_R. lower R object conversion, set R `object“. final_R number Monte Carlo simulation bootstrapping samples final stage. R calling power4test(), power4test_by_n(), power4test_by_es() stepped value approaching target power. need large goal estimate power replications, high precision one single replication. nrep_steps many steps number replications increased final_nrep, initial number replications (nrep power4test()) less final_nrep. number replications successively increased number steps increase precision estimating power. least 1. Increasing number result trials take longer run, try values. Rounded integer. seed NULL, set.seed() used make process reproducible. always possible many stages parallel processing involved. x_include_interval Logical. Whether minimum maximum values x_interval mandatory included values searched. power_model nonlinear model used estimating relation power x. formula acceptable stats::nls(), reject left-hand side, x right-hand side, one parameters. Can also set list models. Users rarely need change default value. NULL, default, default model(s) determined power_curve(). start named numeric vector starting values power_model fitted stats::nls(). power_model list, list length. Users rarely need change default values. lower_bound named numeric vector lower bounds parameters power_model fitted stats::nls(). power_model list, list length. Users rarely need change default values. upper_bound named numeric vector upper bounds parameters power_model fitted stats::nls(). power_model list, list length. Users rarely need change default values. nls_control named list arguments passed control argument stats::nls() estimating relation power x. values override internal default values, also override nls_args. Use argument cautions. nls_args named list arguments used calling stats::nls(). Used override internal default, algorithm (default \"port\"). Use argument cautions. save_sim_all FALSE, default, data power4test object value x saved, reduce size output. set TRUE, size output can large size. digits number digits decimal printing results. ... Optional arguments. used now.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Size and Effect Size Determination — x_from_power","text":"function x_from_power() returns x_from_power object, list following elements: power4test_trials: output power4test_by_n() sample sizes examined, power4test_by_es() population values selected parameter examined. rejection_rates: output rejection_rates(). x_tried: sample sizes population values examined. power_tried: estimated rejection rates values examined. x_final: sample size population value solution. NA solution found. power_final: estimated power value solution. NA solution found. i_final: position solution power4test_trials. NA solution found. ci_final: confidence interval estimated power solution, formed normal approximation. NA solution found. ci_level: level confidence ci_final. nrep_final: number replications (nrep) estimating power solution. power_curve: output power_curve() estimating power curve. target_power: requested target power. power_tolerance: allowed difference solution's estimated power target power. Determined number replications level confidence confidence intervals. x_estimated: value (sample size population value) target power, estimated power_curve. used, solution found, determine range values search calling function . start: time date process started. end: time date process ended. time_spent: time spent search. args: named list arguments x_from_power() used search. call: call function called. print-method x_from_power objects returns object x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Size and Effect Size Determination — x_from_power","text":"use function: Specify model power4test(), do_the_test = FALSE, set magnitude effect sizes minimum levels detect. Add test using power4test() using test_fun test_args (see help page power4test() details). Run starting sample size effect size. Call x_from_power() output power4test() returned previous step. function iteratively repeat analysis either sample sizes, values selected model parameter (effect sizes), trying find value (sample size, population value selected model parameter) power level close enough target power. several values x (sample size population value model parameter) already examined power4test_by_n() power4test_by_es(), output two functions can also used object x_from_power(). Usually, default values arguments sufficient. results can viewed using summary(), output plot method (plot.x_from_power()) plot relation power values (x) examined. detailed illustration use function can found pages: example sizes: https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html effect sizes: https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html technical internal workflow x_from_power() can found page: https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html. print method print basic information. Call summary method x_from_power objects (summary.x_from_power()) print method detailed results","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Size and Effect Size Determination — x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 10,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  # In real analysis, to have more stable results: # - Use a larger final_nrep (e.g., 400). # - Use the default xs_per_trial of 3, or just remove it.  # If the default values are OK, this call is sufficient: # power_vs_n <- x_from_power(test_out, #                            x = \"n\", #                            seed = 4567) power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 10,                            xs_per_trial = 1,                            nrep_steps = 1,                            max_trials = 1,                            seed = 4567) #>  #> --- Pre-iteration Search --- #>  #> - Start at 2025-06-02 11:59:42  #> - Value(s) to try:  125  #>  #> Updating the simulation for sample size: 125  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> - Power Curve: #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -75.3328       0.7672   #>  #> Degrees of Freedom: 19 Total (i.e. Null);  18 Residual #> Null Deviance:\t    13  #> Residual Deviance: 10.01 \tAIC: 14.01 #>  #>  #>  #> --- Trial 1 --- #>  #> - Start at 2025-06-02 11:59:46  #> - Value(s) to try: 98, 101  #> - Numbers of replications: 10, 10  #>  #> Updating the simulation for sample size: 98  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Updating the simulation for sample size: 101  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  98 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 101 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> 4 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - 'nls()' estimation failed. Switch to logistic regression. #>  #> Updating the simulation for sample size: 102  #> Displaying progress enabled. Set 'progress = FALSE' to hide the progress. #> Re-simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates: #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #> - Extrapolated value: 102  #> - Estimated power for 102: 1.0000 #> - 'nls()' estimation failed. Switch to logistic regression. #> - Power Curve: #> Call: #> power_curve(object = by_x_1, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -20.886        0.226   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    30.14  #> Residual Deviance: 26.78 \tAIC: 30.78 #>  #> - Estimated power is close enough to target power (0.8000). (CI: [0.7141,1.0859]) #>  #>  #> --- Final Stage --- #>  #> - Start at 2025-06-02 11:59:58  #> - Rejection Rates: #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  98 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 101 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> 4 102 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> 5 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #> Call: #> power_curve(object = by_x_1, formula = power_model, start = stats::coef(fit_1),  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -41.3415       0.4333   #>  #> Degrees of Freedom: 49 Total (i.e. Null);  48 Residual #> Null Deviance:\t    32.51  #> Residual Deviance: 28.31 \tAIC: 32.31 #>  #>  #> - Final Value: 101  #> - Final Estimated Power: 0.9000  #> - Confidence Interval: [0.7141; 1.0859] #> - CI Level: 95.00% summary(power_vs_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = test_out, x = \"n\", target_power = 0.8,  #>     xs_per_trial = 1, progress = TRUE, max_trials = 1, final_nrep = 10,  #>     nrep_steps = 1, seed = 4567) #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #>  #> === Major Results === #>  #> - Final Value: 101  #> - Final Estimated Power: 0.900  #> - Confidence Interval: [0.714; 1.086] #> - Level of confidence: 95.0% #> - Based on 10 replications. #>  #> === Technical Information === #>  #> - The range of values explored: 98 to 125  #> - Time spent in the search: 16 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = stats::coef(fit_1),  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -41.3415       0.4333   #>  #> Degrees of Freedom: 49 Total (i.e. Null);  48 Residual #> Null Deviance:\t    32.51  #> Residual Deviance: 28.31 \tAIC: 32.31 #>  #> - Detailed Results: #>  #>     n                             test test_label   p.v reject r.cilo r.cihi #> 1  98 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 2 100 test_parameters: CIs (pars: m~x)        m~x 1.000  0.800  0.552  1.048 #> 3 101 test_parameters: CIs (pars: m~x)        m~x 1.000  0.900  0.714  1.086 #> 4 102 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> 5 125 test_parameters: CIs (pars: m~x)        m~x 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate.If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  plot(power_vs_n)"},{"path":"https://sfcheung.github.io/power4mome/news/index.html","id":"power4mome-00148","dir":"Changelog","previous_headings":"","what":"power4mome 0.0.1.48","title":"power4mome 0.0.1.48","text":"Initialized package. (0.0.0.9000) Major functions drafted main workflows finalized. Ready documenting changes. (0.0.0.9001) Documented set pop_es. (0.0.0.9002) Added preliminary support covariance-models (regression path) confirmatory factor analytic models (CFA). (0.0.0.9003) Added support multigroup models. (0.0.0.9004) sim_data(), number_of_indicators reliability can set one single values. (0.0.0.9005) Added check negative variances variances greater one model. (0.0.0.9006) warning raised ptable_pop() pop_es one variables model. (0.0.0.9007) Added error warning checking code fit_model(). (0.0.0.9008) Added error checking code gen_mc(). (0.0.0.9009) Added tests sim_out() do_test(). (0.0.0.9010) Updated help do_test() requirement results test functions. (0.0.0.9011) Updated fit_model() support user-supplied models. (0.0.0.9012) Updated do_test() sim_out() arbitrary number models arbitrary elements used test_fun(). (0.0.0.9013) Updated do_test() sim_out() support tests compare two models. (0.0.0.9014) Added tests power4test(). (0.0.0.9015) Removed redundant arguments tests power4test(). (0.0.0.9016) Updated power4test() store one test. (0.0.0.9017) Updated fit_model() support fitting model another function (0.0.0.9018) Added argument x_fun() sim_data() generating nonnormal exogenous variables. (0.0.0.9019) Updated power4test() related functions support updating power4test object different population effect sizes sample size(s). (0.0.0.9020) Added option generate nonparametric bootstrap estimates. Slow lavaan can used models fitted lm(). (0.0.0.9021) Added test_indirect_effect() testing indirect effect calling power4test(). (0.0.0.9022) Added test_index_mome() testing moderated mediation effect (testing index moderated mediation) calling power4test(). (0.0.0.9023) Added test_parameters() testing free parameters calling power4test(). (0.0.0.9024) Added test_moderation() testing product terms calling power4test(). (0.0.0.9024) test functions can support models fitted lmhelprs::many_lm(). (0.0.0.9024) Simplified argument fit_function fit_model(). can now strings, lavaan lm. (0.0.0.9025) Added summarize_tests(), along print method, summarize te test results power4test object. (0.0.0.9026) Added print method power4test objects. (0.0.0.9027) sim_out can now used update sim_out object adding elements extra. (0.0.0.9028) power4test() can updata power4test object using new nrep. (0.0.0.9029) Added get_rejection_rates() extract rejection rates stored tests. (0.0.0.9030) Added power4test_by_n() power4test_by_pop_es() finding power range sample sizes effect sizes. (0.0.0.9031) Update help pages examples. (0.0.0.9032) Minor fixes boot_ci mc_ci arguments test_indirect_effect() test_index_of_mome(). (0.0.0.9033) Revised fit_model() can used refit model new set data. (0.0.0.9034) Revised power4test() support fitting one model datasets. test_ functions also updated allow users specifying model uesd tests. (0.0.0.9035) Drafted pkgdown site. (0.0.0.9036) Added pop_es_yaml() revised ptable_pop() support method specify population values. (0.0.0.9037) Added option disable computation implied statistics. Default FALSE becasue required testing unstandardized effects. Require manymome 0.2.7.1 . (0.0.0.9038) Finalized internal testing. (0.0.1) Fixed bug using x_fun. (0.0.1.1) Added temporary check package versions. (0.0.1.2) Fixed issue printing boot_out mc_out objects print.sim_data(). (0.0.1.3) Revised get_rejection_rates_* functions add option return columns stored test. (0.0.1.4) Added version requirements lmhelprs manymome. (0.0.1.5) Added test_cond_indirect() test_cond_indirect_effects(). (0.0.1.7) Fixed issues column names. (0.0.1.8) Added es1 es2 power4test(), allow users change effect sizes labels. (0.0.1.9) Added c() method output power4test_by_n(). (0.0.1.10) Added c() method output power4test_by_pop_es(). (0.0.1.11) Added by_seed power4test_by_n() power4test_by_pop_es() reproducible results. (0.0.1.12) Results now reproducible parallel TRUE. (0.0.1.13) Updated power4test_by_pop_es() power4test_by_n() accept output two functions. (0.0.1.14) Added by_nrep power4test_by_n(). (0.0.1.15) Added columns results functions returning rejection rates. (0.0.1.16) Added n_from_power() search sample size target power. (0.0.1.17) Updated psi_std() skip checking variances product terms. (0.0.1.18) Improved rejection_rates_add_ci() usable functions. (0.0.1.19) Updated get_rejection_rates() report confidence intervals standard errors rejection rates. (0.0.1.20) Revised get_rejection_rates() related functions. column rejection rates now always named \"reject\". (0.0.1.21) Added ptable_pop() arguments power4test(). (0.0.1.22) Added power_curve() estimate relation rejection rates predictor. Updated n_from_power() use power_curve() internally. (0.0.1.23) print method sim_out objects can print standardized /unstandardized estimates fitting model merged data. (0.0.1.24) Renamed power4test_by_pop_es() power4test_by_es(), \"n\" \"es\" (\"pop_es\") used functions distinguish predictor used. (0.0.1.25) Renamed get_rejection_rates_by_pop_es() get_rejection_rates_by_es(), consistent name power4test_by_es(). (0.0.1.26) Replaced n_from_power() general version x_from_power(), updated related functions. (0.0.1.27) Updated x_from_power() fully support x = \"es\". (0.0.1.28) Minor changes printout progress power4test_by_n() power4test_by_es(). (0.0.1.29) Fixed minor bug internal function fix_nls_args(). (0.0.1.30) Renamed get_rejection_rates* rejection_rates* looks consistent common naming convention. (0.0.1.31) Convert rejection_rates() S3 generic method. (0.0.1.32) Add rejection_rates methods power4test_by_n power4test_by_es objects. original functions rejection_rates_by_n() rejection_rates_by_es() longer exported. relevant functions revised use rejection_rates method instead two functions. (0.0.1.33) Created class output rejection_rates added print method. (0.0.1.34) Updated arguments print method rejection_rate() output power4test_by_es power4test_by_es objects. (0.0.1.35) Removed power_curve_by_n() power_curve_by_es(). longer needed. (0.0.1.36) Updated power_by_n() power_by_es() option save data model sim_all, updated c() method skip testing model. option used x_from_power(). (0.0.1.37) Updated x_from_power() save data model default. Dramatically reduce size output. (0.0.1.37) Updated doc do_test(). (0.0.1.38) Updated doc test_parameters() valid parameter names. Also added helper find_par_names() finding valid names power4test object. (0.0.1.39) Updated help pages. (0.0.1.40) Added initial_R initial_nrep x_from_power(). (0.0.1.41) Changed default value final_nrep x_from_power() 400. (0.0.1.41) Updated x_from_power() use outputs power4test_by_n() power4test_by_es(). (0.0.1.42) Updated x_from_power() reuse outputs x_from_power(). (0.0.1.43) Fixed issues related R CMD Check. (0.0.1.44) Fixed typo help page power4test(). (0.0.1.45) Fixed bug handling .cov. pop_es. (0.0.1.46) Added tag .ind. setting values component paths along indirect path. tag also supported power4test_by_es() x_from_power(). (0.0.1.47) print method sim_data print population indirect effect(s), . (0.0.1.48)","code":""}]
