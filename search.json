[{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"article brief illustration use power4test() package power4mome power analysis mediation, moderation, moderated-mediation model fitted structural equation model modeling using lavaan.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Basic knowledge fitting models lavaan required. Readers also expected basic knowledge mediation, moderation, /moderated mediation.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"brief illustration. complicated scenarios features power4mome described vignettes.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"introduction needs following package:","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Two functions sufficient estimating power given model, population values, sample size, test used. basic workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified. Call rejection_rates() compute power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Let’s consider simple mediation model. like estimate power testing mediation effect Monte Carlo confidence interval.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"model syntax Note , even going test mediation, moderation, moderated-mediation effects, need add labels model. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) product term moderation, convention: Small: .05 (-.05) Medium: .10 (-.10) Large: .15 (-.15) values standardized solution (correlations -called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : string denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified string, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size many replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown printing object: default, population model fitted dataset, hence section <fit>. Perfect fit expected population model saturated model. check section Population Values see whether values expected. example, population values regression paths specified. different expect, check string pop_es see whether set population values correctly. necessary, can check data generation adding data_long = TRUE printing output: section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. results show specified population model correctly. can proceed specify test estimate power.","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can now simulation estimate power. large number datasets (e.g., 500) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect x y m, sample size 50. call: new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. real studies, number 10000 even 20000 Monte Carlo confidence intervals. However, 2000 sufficient goal estimate power generating many intervals, rather one single stable interval. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-functions common tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case tests done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 nrep = 400, 95% confidence limits power .80 .04 .80. precise enough determining whether sample size sufficient power. default printout: test_long = TRUE added printing output print(), summary test also printed. summary test: mean estimates across replications 0.152, close population value.","code":"out <- power4test(nrep = 400,                   model = mod,                   pop_es = mod_es,                   n = 50,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. print(out,       test_long = TRUE) #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power","dir":"Articles","previous_headings":"Mediation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"power estimate simply proportion significant results, rejection rate, null hypothesis false. addition using test_long = TRUE print(), rejection rate can also retrieved rejection_rates(). example , estimated power test indirect effect, conducted Monte Carlo confidence interval, 0.468, column reject. p.v proportion valid results across replications. 1.000 means test conducted normally replications. default, 95% confidence interval rejection rate (power) based normal approximation also printed, column r.cilo r.cihi. example, 95% confidence interval [0.419; 0.516].","code":"out_power <- rejection_rates(out) out_power #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.152 1.000  0.468  0.419  0.516 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"moderation","dir":"Articles","previous_headings":"","what":"Moderation","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Let’s consider moderation model, control variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"pop_es_xw","dir":"Articles","previous_headings":"Moderation","what":"Specify the Population Model and Values","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"model moderation, predictor x moderator w. product term included lavaan style, x:w. unrealistic specific population values control variables. Therefore, can just add proxy, control represent set control variables may included. syntax population values: example introduces one useful tag, .beta. model many paths, inconvenient specify manually. tag .beta. specify default value regression paths specified explicitly, small (.10) example. path explicitly included (y ~ control y ~ x:w), manually specified value used instead .beta.. example also illustrates can set population values correlations (covariances standardized solution). Control variables included usually may correlate predictors. Therefore, example, hypothesized small correlation x proxy control variable (x ~~ control: s). Last, recall section convention product term values different: l denotes .15 product terms.","code":"mod2 <- \" y ~ x + w + x:w + control \" mod2_es <- \" .beta.: s x ~~ control: s y ~ control: s y ~ x:w: l \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model-1","dir":"Articles","previous_headings":"Moderation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"check model first: population values regression paths specified, estimates based 5 × 104 2 100000 support dataset generated correctly. NOTE: product term involved, component terms (x w example) correlated, population standard deviation product term may equal one (Bohrnstedt & Goldberger, 1969). Therefore, model can specified correctly even standard deviations product terms section Descriptive Statistics close one.","code":"out2 <- power4test(nrep = 2,                    model = mod2,                    pop_es = mod2_es,                    n = 50000,                    iseed = 1234) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> y ~ x + w + x:w + control #>  #> == Model on Variables/Indicators == #>  #> y ~ x + w + x:w + control #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   y ~                         #>     x                 0.100   #>     w                 0.100   #>     x:w               0.150   #>     control           0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>     control           0.100   #>   w ~~                        #>     x:w               0.000   #>     control           0.000   #>   x:w ~~                      #>     control           0.000   #>  #> Variances: #>                    Population #>    .y                 0.946   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>     control           1.000   #>  #> (Computing indirect effects for 0 paths ...) #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>         vars     n mean sd  skew kurtosis se #> y          1 1e+05 0.00  1  0.02     0.01  0 #> x          2 1e+05 0.00  1  0.01     0.01  0 #> w          3 1e+05 0.00  1  0.00    -0.02  0 #> x:w        4 1e+05 0.00  1 -0.03     6.01  0 #> control    5 1e+05 0.01  1  0.00     0.00  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   y ~                       #>     x                 0.097 #>     w                 0.104 #>     x:w               0.152 #>     control           0.099 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                -0.003 #>     x:w               0.002 #>     control           0.101 #>   w ~~                      #>     x:w              -0.004 #>     control           0.001 #>   x:w ~~                    #>     control           0.004 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-test-the-moderation-effect","dir":"Articles","previous_headings":"Moderation","what":"Call power4test() to Test The Moderation Effect","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can now simulation estimate power. simple model, test just test product term, x:w. model can fitted linear regression using lm(). Let’s estimate power sample size 50 model fitted lm(): new arguments used: fit_model_args: named list stores additional arguments fit_model(). default, lavaan::sem() used. fit model linear regression using lm(), add fit_function = \"lm\" list.6 test_fun: set test_moderation, provided power4mome. function automatically identifies product terms model test . test used depends method used fit model. lm() used, usual t test used.7","code":"out2 <- power4test(nrep = 400,                    model = mod2,                    pop_es = mod2_es,                    n = 100,                    fit_model_args = list(fit_function = \"lm\"),                    test_fun = test_moderation,                    iseed = 1234,                    parallel = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power-1","dir":"Articles","previous_headings":"Moderation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can ues rejection_rates() estimate power: estimated power test product term, x:w, 0.347, 95% confidence interval [0.301; 0.394].","code":"out2_power <- rejection_rates(out2) out2_power #> [test]: test_moderation: CIs   #> [test_label]: y~x:w  #>     est   p.v reject r.cilo r.cihi #> 1 0.158 1.000  0.347  0.301  0.394 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"moderated-mediation","dir":"Articles","previous_headings":"","what":"Moderated-Mediation","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Let’s consider moderated mediation model.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"specify-the-population-model-and-values","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Specify the Population Model and Values","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"model mediation model -path, m ~ x, moderated w. explained , need use label define parameters. handled test function used. syntax population values: Please refer previous section setting syntax.","code":"mod3 <- \" m ~ x + w + x:w y ~ m + x \" mod3_es <- \" .beta.: s m ~ x: m y ~ m: m m ~ x:w: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-check-the-model-2","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"check model first: population values estimates based 5 × 104 2 100000 expect.","code":"out3 <- power4test(nrep = 2,                    model = mod3,                    pop_es = mod3_es,                    n = 50000,                    iseed = 1234) print(out3,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.100   #>     x:w               0.050   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.898   #>    .y                 0.881   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.090 #> w -> m -> y 0.030 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>     vars     n mean sd skew kurtosis se #> m      1 1e+05    0  1 0.03     0.03  0 #> y      2 1e+05    0  1 0.01    -0.01  0 #> x      3 1e+05    0  1 0.00    -0.02  0 #> w      4 1e+05    0  1 0.00     0.01  0 #> x:w    5 1e+05    0  1 0.04     5.92  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.303 #>     w                 0.099 #>     x:w               0.052 #>   y ~                       #>     m                 0.299 #>     x                 0.098 #>  #> Covariances: #>                     est.std #>   x ~~                      #>     w                 0.003 #>     x:w              -0.001 #>   w ~~                      #>     x:w               0.008 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.007 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.997"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"call-power4test-to-test-the-moderated-mediation-effect","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Call power4test() to Test The Moderated-Mediation Effect","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"estimate power moderated-mediation effect, can test index moderated-mediation (Hayes, 2015). example, product coefficient m ~ x:w coefficient y ~ m. can done test function test_index_of_mome(), provided power4mome. , Monte Carlo confidence interval used. Let’s estimate power sample size 100. call similar one used testing mediation. new argument used: test_fun: set test_index_of_mome() example. function similar test_indirect_effect(), one argument, w, moderator. Although example one mediator, support number mediators along path.8","code":"out3 <- power4test(nrep = 400,                    model = mod3,                    pop_es = mod3_es,                    n = 100,                    R = 2000,                    ci_type = \"mc\",                    test_fun = test_index_of_mome,                    test_args = list(x = \"x\",                                     m = \"m\",                                     y = \"y\",                                     w = \"w\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"compute-the-power-2","dir":"Articles","previous_headings":"Moderated-Mediation","what":"Compute the Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"can ues rejection_rates() estimate power: estimated power test moderated mediation effect, conducted test index moderated mediation, 0.050, 95% confidence interval [0.029; 0.071]. Unlike previous example moderation tested regression, estimating power Monte Carlo confidence intervals substantially slower. However, necessary Monte Carlo nonparametric bootstrapping confidence interval test usually used moderated-mediation (mediation).","code":"out3_power <- rejection_rates(out3) out3_power #> [test]: test_index_of_mome: x->m->y, moderated by w  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.016 1.000  0.050  0.029  0.071 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"new_n","dir":"Articles","previous_headings":"","what":"Repeating a Simulation With A Different Sample Size","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"function power4test() also supports redoing analysis using new value sample size (population effect sizes set pop_es). Simply set output power4test first argument, set new value n. example, can repeat simulation test moderation , sample size 200. simply call power4test() , set previous output (out2 example moderation) first argument, set n new value (200 example): estimated power sample size 200. estimated power 0.527, 95% confidence interval [0.479; 0.576], sample size 200. technique can repeated find required sample size target power, can used scenarios covered , mediation moderated-mediation.","code":"out2_new_n <- power4test(out2,                          n = 200) out2_new_n out2_new_n_reject <- rejection_rates(out2_new_n) out2_new_n_reject #> [test]: test_moderation: CIs   #> [test_label]: y~x:w  #>     est   p.v reject r.cilo r.cihi #> 1 0.148 1.000  0.527  0.479  0.576 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"find-the-sample-size-with-desired-power","dir":"Articles","previous_headings":"","what":"Find the Sample Size With Desired Power","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"two efficient ways find sample size desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"using-power4test_by_n","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using power4test_by_n()","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"First, function power4test_by_n() can used estimate power sequence sample sizes. example, can estimate power moderation model sample sizes: 250, 300, 350, 400. first argument output power4test() arbitrary sample size. argument n numeric vector sample sizes examine. argument by_seed, set integer, try make results reproducible. call take times run equivalent calling power4test() sample size. rejection rates sample size can retrieved rejection_rates() : results show , power .800 detect moderation effect, sample size 350 needed. Please refer help page power4test_by_n() examples.","code":"out2_several_ns <- power4test_by_n(out2,                                    n = c(250, 300, 350, 400),                                    by_seed = 4567) rejection_rates(out2_several_ns) #> [test]: test_moderation: CIs   #> [test_label]: y~x:w  #>     n   est   p.v reject r.cilo r.cihi #> 1 250 0.149 1.000  0.660  0.614  0.706 #> 2 300 0.150 1.000  0.733  0.689  0.776 #> 3 350 0.151 1.000  0.810  0.772  0.848 #> 4 400 0.150 1.000  0.850  0.815  0.885 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"using-x_from_power","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using x_from_power()","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Second, function x_from_power() can used systematically search within interval sample size target power. takes longer run , instead manually trying different sample size, function search automatically. See article illustration use x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"other-advanced-features","dir":"Articles","previous_headings":"","what":"Other Advanced Features","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"brief illustration covers basic features power4mome. advanced features covered articles: inherent restriction form model. Typical models can specified lavaan model syntax can population model, although may special models power4test yet support. population model can model latent factors indicators. Nevertheless, users can specify relation among factors. need include indicators model syntax, also need manually specify factor loadings. number indicators factor factor loadings set argument number_of_indicators reliability (see help page sim_data() set ). model syntax used fit data automatically include indicators. Though illustrated , estimating power tests conducted nonparametric bootstrapping supported, although take longer run. Although package focuses moderation, mediation, moderated-mediation, principle, power test can estimated, long test function test_fun available. functions provided power4mome (e.g., test_parameters() testing free model parameters). See help page do_test() write function test available power4mome. estimating power, usually population model fitted data. However, possible fit model generated data. can done using argument fit_model_args set argument model fit_model(). Preliminary support multigroup model available. See help pages ptable_pop() pop_es_yaml() specify population value syntax. Functions added tests relevant multigroup models (e.g., testing -group difference indirect effect). Although illustrated rerunning analysis new sample size (n), also possible rerun analysis using new population value parameter. can done using previous output power4test() first argument, setting pop_es named vector: Basic support generating nonnormal variables, including dichotomous variables available. See argument x_fun power4test() details.","code":"out2_new_xw <- power4test(out2,                           pop_es = c(\"y ~ x:w\" = \".30\"))"},{"path":"https://sfcheung.github.io/power4mome/articles/power4mome.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Power Analysis for Moderation, Mediation, and Moderated-Mediation","text":"Monte Carlo confidence interval supported models fitted lm() (regression). estimate power testing mediation moderated-mediation effects models fitted lm(), ci_type = \"boot\" needed.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Power Analysis for Latent Variable Mediation","text":"article brief illustration use power4test() package power4mome power analysis mediation effect among latent factors model fitted structural equation model modeling using lavaan.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Power Analysis for Latent Variable Mediation","text":"Basic knowledge fitting models lavaan required. Readers also expected basic knowledge mediation structural equation modeling.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Power Analysis for Latent Variable Mediation","text":"make vignette self-contained, sections vignette(\"power4mome\") repeated . power analysis mediation effect path model latent factors, please refer vignette(\"power4mome\").","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Power Analysis for Latent Variable Mediation","text":"introduction needs following package:","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Power Analysis for Latent Variable Mediation","text":"Two functions sufficient estimating power given model, population values, sample size, test used. basic workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified. Call rejection_rates() compute power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Power Analysis for Latent Variable Mediation","text":"Let’s consider simple mediation model three factors. like estimate power testing mediation effect Monte Carlo confidence interval.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Power Analysis for Latent Variable Mediation","text":"model latent factor, need specify model syntax factors. need include measurement part indicators. model syntax: latent variables fx, fm, fy. indirect path fx fy, fm. Note , even going test mediation effect, need add labels model. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" fm ~ fx fy ~ fm + fx \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Power Analysis for Latent Variable Mediation","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path fx fm “large” strength. path fm fy “large” strength. path fx fm “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (correlations -called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : string denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified string, set zero.","code":"mod_es <- \" fm ~ fx: l fy ~ fm: l fy ~ fx: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"measurement","dir":"Articles","previous_headings":"Mediation","what":"Specify the Measurement Part","title":"Power Analysis for Latent Variable Mediation","text":"Power analysis usually conducted data collection. rarely know advance factor loadings items. purpose power analysis, intended conducted knowledge factor loadings, believe , instead specify explicitly loadings, sufficient specify two values factor: number indicators. population reliability. approach used power4mome. factor, population standardized factor loadings indicator derived automatically hypothesized (expected) population reliability number indicators, assuming indicators equal loadings. Although equal-loading unrealistic, priori power analysis, difficult, impossible, specify pattern factor loadings. level details also necessary power estimated merely used guide planning data collection, instead estimating “true” power data collected. Two argument used set number indicators reliability. number_of_indicators: named vector number indicators factor. names names factors appeared model syntax, values number indicators. reliability: named vector reliability factor. names names factors appeared model syntax, values population reliability. example, suppose use following vectors: numbers indicators fx, fm, fy 4, 3, 5, respectively. population reliability coefficients fx, fm, fy .50, .60, .70, respectively. real research, reliability low .50 can problematic. chose values merely illustration orders intentionally arbitrary, demonstrate order matter. names used interpret numbers correctly.","code":"k <- c(fm = 3, fx = 4, fy = 5) mod_rel <- c(fy = .70, fm = .60, fx = .50)"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Power Analysis for Latent Variable Mediation","text":"set can call power4test() check model: arguments used: nrep: number replications. stage, small number can used. important large sample size many replications. model: model syntax. pop_es: string setting population values. number_of_indicators: named vector number indicators factor, described previous section. reliability: named vector population reliability factor, described previous section. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown printing object: default, population model fitted dataset, hence section <fit>. fit “perfect” model saturated model. However, p-value high significant (, population model fitted, chance significant close .05). Although specify structure latent factors, can see automatically generated measurement part syntax section Model Variables/Indicators: confirmed specified measurement part correctly. check section Population Values see whether values expected. example, population values regression paths specified. different expect, check string pop_es see whether set population values correctly. section Variances: shows variances error variances latent factors. fm fy endogenous factors, values presented, next .fm .fy, error variances, ’s 1, unlike fx. section Population Reliability shows population reliability coefficients: values set reliability. section Population Standardized Loadings shows standardized factor loadings factor. one value factor loadings assumed items: necessary, can check data generation adding data_long = TRUE printing output: Two new sections printed. first one: section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics indicators. expected, means close zero standard deviations close one, datasets generated using standardized model. second one: section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. results show specified population model correctly. can proceed specify test estimate power.","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   number_of_indicators = k,                   reliability = mod_rel,                   n = 50000,                   iseed = 1234) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> == Model on Variables/Indicators == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   fm ~                        #>     fx                0.500   #>   fy ~                        #>     fm                0.500   #>     fx                0.100   #>  #> Variances: #>                    Population #>    .fm                0.750   #>    .fy                0.690   #>     fx                1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>                  ind #> fx -> fm -> fy 0.250 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #>  #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 44 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        27 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                38.042 #>   Degrees of freedom                                51 #>   P-value (Chi-square)                           0.910 #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 print(out,       data_long = TRUE) #> ==== Descriptive Statistics ==== #>  #>     vars     n mean   sd  skew kurtosis se #> fm1    1 1e+05 0.00 1.00  0.01     0.00  0 #> fm2    2 1e+05 0.01 1.00  0.01    -0.01  0 #> fm3    3 1e+05 0.00 1.01  0.00    -0.02  0 #> fx1    4 1e+05 0.00 1.00  0.00     0.00  0 #> fx2    5 1e+05 0.00 1.00 -0.01     0.00  0 #> fx3    6 1e+05 0.00 1.00 -0.01    -0.02  0 #> fx4    7 1e+05 0.00 1.00  0.00     0.00  0 #> fy1    8 1e+05 0.00 1.00  0.01     0.01  0 #> fy2    9 1e+05 0.00 1.00  0.01     0.00  0 #> fy3   10 1e+05 0.00 1.00  0.00     0.01  0 #> fy4   11 1e+05 0.01 1.00  0.01     0.00  0 #> fy5   12 1e+05 0.00 1.00  0.02    -0.01  0 #> fy5   12 1e+05 0.00 1.00  0.02    -0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Latent Variables: #>                     est.std #>   fm =~                     #>     fm1               0.578 #>     fm2               0.579 #>     fm3               0.578 #>   fx =~                     #>     fx1               0.445 #>     fx2               0.443 #>     fx3               0.445 #>     fx4               0.445 #>   fy =~                     #>     fy1               0.559 #>     fy2               0.560 #>     fy3               0.563 #>     fy4               0.565 #>     fy5               0.569 #>  #> Regressions: #>                     est.std #>   fm ~                      #>     fx                0.504 #>   fy ~                      #>     fm                0.505 #>     fx                0.097"},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Power Analysis for Latent Variable Mediation","text":"can now simulation estimate power. large number datasets (e.g., 400) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect fx fy fm, sample size 150. call: new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. real studies, number 10000 even 20000 Monte Carlo confidence intervals. However, 2000 sufficient goal estimate power generating many intervals, rather one single stable interval. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-functions common tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case tests done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 nrep = 400, 95% confidence limits power .80 .04 .80. precise enough determining whether sample size sufficient power. default printout:","code":"out <- power4test(nrep = 400,                   model = mod,                   pop_es = mod_es,                   number_of_indicators = k,                   reliability = mod_rel,                   n = 150,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"fx\",                                    m = \"fm\",                                    y = \"fy\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) out #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> == Model on Variables/Indicators == #>  #> fm ~ fx #> fy ~ fm + fx #>  #> fm =~ fm1 + fm2 + fm3 #> fx =~ fx1 + fx2 + fx3 + fx4 #> fy =~ fy1 + fy2 + fy3 + fy4 + fy5 #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   fm ~                        #>     fx                0.500   #>   fy ~                        #>     fm                0.500   #>     fx                0.100   #>  #> Variances: #>                    Population #>    .fm                0.750   #>    .fy                0.690   #>     fx                1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>                  ind #> fx -> fm -> fy 0.250 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ==== Population Reliability ==== #>  #>   fy  fm  fx #>  0.7 0.6 0.5 #>  #> == Population Standardized Loadings == #>  #>     fm    fx    fy #>  0.661 0.522 0.408 #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  150  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 38 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        27 #>  #>   Number of observations                           150 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                69.181 #>   Degrees of freedom                                51 #>   P-value (Chi-square)                           0.046 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: fx->fm->fy #>  #> Call print() and set 'test_long = TRUE' for a detailed report."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"compute-the-power","dir":"Articles","previous_headings":"Mediation","what":"Compute the Power","title":"Power Analysis for Latent Variable Mediation","text":"power estimate simply proportion significant results, rejection rate, null hypothesis false. rejection rate can retrieved rejection_rates(). example , estimated power test indirect effect, conducted Monte Carlo confidence interval, 0.492, column reject. p.v proportion valid results across replications. 1.000 means test conducted normally replications. default, 95% confidence interval rejection rate (power) based normal approximation also printed, column r.cilo r.cihi. example, 95% confidence interval [0.444; 0.541].","code":"out_power <- rejection_rates(out) out_power #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.336 1.000  0.492  0.444  0.541 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"new_n","dir":"Articles","previous_headings":"","what":"Repeat a Simulation With A Different Sample Size","title":"Power Analysis for Latent Variable Mediation","text":"function power4test() also supports redoing analysis using new value sample size (population effect sizes set pop_es). Simply set output power4test first argument, set new value n. example, can repeat simulation test indirect effect, smaller sample size 100. simply call power4test() , set previous output (example moderation) first argument, set n new value (100 example): estimated power sample size 200. estimated power 0.815, 95% confidence interval [0.777; 0.853], sample size 200. technique can repeated find required sample size target power.","code":"out_new_n <- power4test(out,                         n = 200) out_new_n out_new_n_reject <- rejection_rates(out_new_n) out_new_n_reject #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.352 1.000  0.815  0.777  0.853 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"repeat-a-simulation-with-different-numbers-of-indicators-or-reliability","dir":"Articles","previous_headings":"","what":"Repeat a Simulation With Different Numbers of Indicators or Reliability","title":"Power Analysis for Latent Variable Mediation","text":"can also redo analysis using new values reliability. know power low 150 cases. may want see whether can higher power use reliable scales. previous example, just call power4test() one original output, set reliability new vector. Assume want know power scenario, scales population reliability .80: estimated power higher population reliability: estimated power 0.985, 95% confidence interval [0.973; 0.997], much higher original scenario.","code":"out_new_rel <- power4test(out,                           reliability = c(fx = .80,                                           fm = .80,                                           fy = .80)) out_new_rel out_new_rel_reject <- rejection_rates(out_new_rel) out_new_rel_reject #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.235 1.000  0.985  0.973  0.997 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"find-the-sample-size-with-desired-power","dir":"Articles","previous_headings":"","what":"Find the Sample Size With Desired Power","title":"Power Analysis for Latent Variable Mediation","text":"two efficient ways find sample size desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"using-power4test_by_n","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using power4test_by_n()","title":"Power Analysis for Latent Variable Mediation","text":"First, function power4test_by_n() can used estimate power sequence sample sizes. example, suppose know power .80 sample size 200. can estimate power mediation model sample sizes: 175, 200, 225, 250. first argument output power4test() arbitrary sample size. argument n numeric vector sample sizes examine. n, nrep datasets generated. Although limit number sample sizes try, recommended restrict number sample sizes 5 less. argument by_seed, set integer, try make results reproducible. call take times run equivalent calling power4test() sample size. rejection rates sample size can retrieved rejection_rates() : results show , power .800 detect mediation effect, sample size 200 needed. Please refer help page power4test_by_n() examples.","code":"out_several_ns <- power4test_by_n(out,                                   n = c(175, 200, 225, 250),                                   by_seed = 4567) rejection_rates(out_several_ns) #> [test]: test_indirect: fx->fm->fy  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 175 0.327 1.000  0.703  0.658  0.747 #> 2 200 0.329 1.000  0.830  0.793  0.867 #> 3 225 0.340 1.000  0.892  0.862  0.923 #> 4 250 0.330 1.000  0.902  0.873  0.932 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"using-x_from_power","dir":"Articles","previous_headings":"Find the Sample Size With Desired Power","what":"Using x_from_power()","title":"Power Analysis for Latent Variable Mediation","text":"Second, function x_from_power() can used systematically search within interval sample size target power. takes longer run , instead manually trying different sample size, function search automatically. See article illustration use x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_latent_mediation.html","id":"other-scenarios","dir":"Articles","previous_headings":"","what":"Other Scenarios","title":"Power Analysis for Latent Variable Mediation","text":"scenarios, moderation moderated-mediation, please refer vignette(\"power4mome\").","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflow of `power4test()`","text":"technical appendix describes workflow power4test() power4mome.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/power4test_workflow.html","id":"from-population-to-power-power4test","dir":"Articles","previous_headings":"","what":"From Population to Power (power4test())","title":"Workflow of `power4test()`","text":"main power4test() can tasks one call: Generate nrep datasets (nrep replications) based population model values population parameters (“effect sizes”) (conducted sim_data()). Fit one models datasets (conducted fit_model()). (Optional) Generate Monte Carlo bootstrap estimates based fitted model(s), tests methods Monte Carlo bootstrap confidence intervals (conducted gen_mc() gen_boot()). (Optional) one tests model fit results (conducted do_test()). Return power4test() object. Power can estimated conducted tests functions rejection_rates(). following workflow: Population Power","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/sim_data_i_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflows of `sim_data_i()","text":"technical appendix describes workflow internal function sim_data_i() power4mome.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/sim_data_i_workflow.html","id":"generate-simulated-data-sim_data_i","dir":"Articles","previous_headings":"","what":"Generate Simulated Data (sim_data_i())","title":"Workflows of `sim_data_i()","text":"internal function sim_data_i() called m times sim_data() generate m datasets. workflow sim_data_i(): Workflow sim_data_i() generating many datasets, steps need repeated. Therefore, required objects (e.g., parameter table) supplied sim_data(), sim_data_i() data generation.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Mediation with Observed Variables","text":"“Quick Template” vignettes examples R code power analysis determine sample size typical models using power4mome. Users can quickly adapt scenarios.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), power4test_by_n(), x_from_power(), refer Get-Started article, article finding sample size given desired power using x_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Mediation with Observed Variables","text":"file simple mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Mediation with Observed Variables","text":"Estimate power sample size. code: results:","code":"library(power4mome) # # ====== Model: Form ====== model <- \" m ~ x y ~ m + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) model_es <- \" m ~ x: s y ~ m: l y ~ x: m \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.100   #>   y ~                         #>     m                 0.500   #>     x                 0.300   #>  #> Variances: #>                    Population #>    .m                 0.990   #>    .y                 0.630   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.050 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01    -0.01 0.01 #> y    2 40000 -0.01  1 -0.02    -0.03 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.099 #>   y ~                       #>     m                 0.499 #>     x                 0.305 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.049 1.000  0.195  0.156  0.234 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-another-n","dir":"Articles","previous_headings":"","what":"Try Another N","title":"Quick Template: Mediation with Observed Variables","text":"rerun simulation estimate power another sample size. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 150 # Set n to 150 out_new_n <- power4test(out,                         n = 150) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.053 1.000  0.290  0.246  0.334 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"try-several-ns","dir":"Articles","previous_headings":"","what":"Try Several N’s","title":"Quick Template: Mediation with Observed Variables","text":"Rerun simulation estimate power several sample sizes. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 200, 250, 300 # Use power4test_by_n() out_ns <- power4test_by_n(out,                           n = c(200, 250, 300),                           by_seed = 5789) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_ns) rejection_rates(out_ns) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 200 0.053 1.000  0.323  0.277  0.368 #> 2 250 0.047 1.000  0.323  0.277  0.368 #> 3 300 0.052 1.000  0.445  0.396  0.494 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"search-n-with-target-power","dir":"Articles","previous_headings":"","what":"Search N With Target Power","title":"Quick Template: Mediation with Observed Variables","text":"Search, simulation, sample size estimated either: Case 1: Sample size 95% confidence interval estimated power just target level (e.g., .80). , upper bound (ub) close target level. Sample sizes lower sample size power levels significantly lower target level. Case 2: Sample size 95% confidence interval estimated power just target level (e.g., .80). , lower bound (lb) close target level. Sample sizes higher sample size power levels significantly higher target level.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"use-the-output-of-power4test","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test()","title":"Quick Template: Mediation with Observed Variables","text":"step calling power4test() sample size. can take time run estimated power sample size different target power. consider Case 1 first: Sample sizes power significantly lower target level. code: results: Power Curve Case 2: Sample sizes power significantly higher target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ub <- n_from_power(out,                               what = \"ub\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ub) # # ===== Print the Summary ===== summary(n_power_80_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 654 #>  #> - Final Estimated Power: 0.738  #> - Confidence Interval: [0.694; 0.781] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 897  #> - Time spent in the search: 54.66 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.641485     0.003979   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       2178  #> Residual Deviance: 1756  AIC: 1760 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.049 1.000  0.195  0.156  0.234 #> 2 410 0.049 1.000  0.537  0.489  0.586 #> 3 654 0.050 1.000  0.738  0.694  0.781 #> 4 897 0.049 1.000  0.848  0.812  0.883 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ub) # # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_lb <- n_from_power(out,                               what = \"lb\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_lb) # # ===== Print the Summary ===== summary(n_power_80_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 891 #>  #> - Final Estimated Power: 0.840  #> - Confidence Interval: [0.804; 0.876] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 891  #> - Time spent in the search: 1.231 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.599650     0.003733   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2602  #> Residual Deviance: 2007  AIC: 2011 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1  100 0.049 1.000  0.195  0.156  0.234 #> 2  410 0.049 1.000  0.537  0.489  0.586 #> 3  731 0.049 1.000  0.745  0.702  0.788 #> 4  891 0.049 1.000  0.840  0.804  0.876 #> 5 1051 0.050 1.000  0.907  0.879  0.936 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"use-the-output-of-power4test_by_n","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test_by_n()","title":"Quick Template: Mediation with Observed Variables","text":"step calling power4test_by_n() sample size. Continue search using output several sample sizes calling n_from_power() output power4test_by_n(). can take time run estimated levels power sample sizes different target power. code Case 1: Sample sizes power significantly lower target level. results: Power Curve code Case 2: Sample sizes power significantly higher target level. results: Power Curve","code":"# # ===== Reuse the output of power4test_by_n() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ns_ub <- n_from_power(out_ns,                                  what = \"ub\",                                  seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ns_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_ub) # # ===== Print the Summary ===== summary(n_power_80_ns_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out_ns, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 750 #>  #> - Final Estimated Power: 0.740  #> - Confidence Interval: [0.697; 0.783] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 300 to 961  #> - Time spent in the search: 55.49 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.125137     0.003117   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       2003  #> Residual Deviance: 1821  AIC: 1825 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 300 0.052 1.000  0.445  0.396  0.494 #> 2 539 0.051 1.000  0.662  0.616  0.709 #> 3 750 0.049 1.000  0.740  0.697  0.783 #> 4 961 0.050 1.000  0.877  0.845  0.910 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_ub) # # ===== Reuse the output of power4test_by_n() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ns_lb <- n_from_power(out_ns,                                  what = \"lb\",                                  seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ns_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_lb) # # ===== Print the Summary ===== summary(n_power_80_ns_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out_ns, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 842 #>  #> - Final Estimated Power: 0.838  #> - Confidence Interval: [0.801; 0.874] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 1109 to 967  #> - Time spent in the search: 1.978 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.261561     0.003498   #>  #> Degrees of Freedom: 3199 Total (i.e. Null);  3198 Residual #> Null Deviance:       3289  #> Residual Deviance: 2894  AIC: 2898 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1  300 0.052 1.000  0.445  0.396  0.494 #> 2  539 0.051 1.000  0.662  0.616  0.709 #> 3  824 0.048 1.000  0.812  0.774  0.851 #> 4  842 0.050 1.000  0.838  0.801  0.874 #> 5  860 0.050 1.000  0.875  0.843  0.907 #> 6  896 0.051 1.000  0.865  0.832  0.898 #> 7  967 0.049 1.000  0.877  0.845  0.910 #> 8 1109 0.051 1.000  0.945  0.923  0.967 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, set m ~ x path y ~ m path medium (.30) (population indirect effect .09). code: results: illustration, go directly searching n_from_power(): code Case 1: Sample sizes power significantly lower target level. results: Power Curve code Case 2: Sample sizes power significantly higher target level. results: Power Curve","code":"model_es2 <- \" m ~ x: m y ~ m: m y ~ x: m \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effect,                    test_args = list(x = \"x\",                                     m = \"m\",                                     y = \"y\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.300   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.766   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.090 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01     0.00 0.01 #> y    2 40000 -0.01  1 -0.01    -0.01 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.299 #>   y ~                       #>     m                 0.298 #>     x                 0.306 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.089 1.000  0.745  0.702  0.788 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Reuse the output of power4test() ===== n2_power_80_ub <- n_from_power(out2,                             what = \"ub\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_80_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_ub) # # ===== Print the Summary ===== summary(n2_power_80_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 100 #>  #> - Final Estimated Power: 0.745  #> - Confidence Interval: [0.702; 0.788] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 107  #> - Time spent in the search: 17.23 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    0.116390     0.009557   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       897.5  #> Residual Deviance: 897.4     AIC: 901.4 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.089 1.000  0.745  0.702  0.788 #> 2 107 0.088 1.000  0.757  0.715  0.800 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_ub) # # ===== Reuse the output of power4test() ===== n2_power_80_lb <- n_from_power(out2,                             what = \"lb\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_80_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_lb) # # ===== Print the Summary ===== summary(n2_power_80_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 115 #>  #> - Final Estimated Power: 0.848  #> - Confidence Interval: [0.812; 0.883] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 228  #> - Time spent in the search: 1.731 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -2.18323      0.03245   #>  #> Degrees of Freedom: 2799 Total (i.e. Null);  2798 Residual #> Null Deviance:       2183  #> Residual Deviance: 1967  AIC: 1971 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.089 1.000  0.745  0.702  0.788 #> 2 107 0.088 1.000  0.757  0.715  0.800 #> 3 115 0.090 1.000  0.848  0.812  0.883 #> 4 123 0.089 1.000  0.865  0.832  0.898 #> 5 138 0.091 1.000  0.905  0.876  0.934 #> 6 168 0.091 1.000  0.965  0.947  0.983 #> 7 228 0.089 1.000  0.993  0.984  1.001 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Serial Mediation with Observed Variables","text":"“Quick Template” vignettes examples R code power analysis determine sample size typical models using power4mome. Users can quickly adapt scenarios.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Serial Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), power4test_by_n(), x_from_power(), refer Get-Started article, article finding sample size given desired power using x_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Serial Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Serial Mediation with Observed Variables","text":"file serial mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Serial Mediation with Observed Variables","text":"Estimate power sample size. code: results:","code":"library(power4mome) # # ====== Model: Form ====== # Omit any paths hypothesized to be zero model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # -l, -m, and -s denote negative values # Can also set to a number directly # Set each path to the hypothesized magnitude model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 50,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.500   #>   m2 ~                        #>     m1                0.500   #>     x                 0.000   #>   m3 ~                        #>     m2                0.500   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.750   #>    .m2                0.750   #>    .m3                0.750   #>    .y                 0.893   #>     x                 1.000   #>  #> (Computing indirect effects for 7 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.037 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd skew kurtosis   se #> m1    1 20000 -0.01 1.00 0.03    -0.04 0.01 #> m2    2 20000  0.00 1.00 0.01     0.06 0.01 #> m3    3 20000 -0.01 1.00 0.01    -0.05 0.01 #> y     4 20000 -0.01 1.00 0.01    -0.03 0.01 #> x     5 20000  0.00 1.01 0.00    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 20000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.493 #>   m2 ~                      #>     m1                0.498 #>     x                 0.010 #>   m3 ~                      #>     m2                0.499 #>     m1               -0.001 #>     x                 0.011 #>   y ~                       #>     m3                0.296 #>     m2               -0.002 #>     m1                0.014 #>     x                 0.086 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        14 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.036 1.000  0.372  0.325  0.420 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"try-another-n","dir":"Articles","previous_headings":"","what":"Try Another N","title":"Quick Template: Serial Mediation with Observed Variables","text":"rerun simulation estimate power another sample size. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 60 # Set n to 60 out_new_n <- power4test(out,                         n = 60) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.037 1.000  0.507  0.459  0.556 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"try-several-ns","dir":"Articles","previous_headings":"","what":"Try Several N’s","title":"Quick Template: Serial Mediation with Observed Variables","text":"Rerun simulation estimate power several sample sizes. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 70, 80, 90 # Use power4test_by_n() out_ns <- power4test_by_n(out,                           n = c(70, 80, 90),                           by_seed = 5789) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_ns) rejection_rates(out_ns) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>    n   est   p.v reject r.cilo r.cihi #> 1 70 0.038 1.000  0.615  0.567  0.663 #> 2 80 0.038 1.000  0.688  0.642  0.733 #> 3 90 0.037 1.000  0.723  0.679  0.766 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"search-n-with-target-power","dir":"Articles","previous_headings":"","what":"Search N With Target Power","title":"Quick Template: Serial Mediation with Observed Variables","text":"Search, simulation, sample size estimated power close target level (e.g., .80).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"use-the-output-of-power4test","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test()","title":"Quick Template: Serial Mediation with Observed Variables","text":"step calling power4test() sample size. can take time run estimated power sample size different target power. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call x_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80 <- x_from_power(out,                            x = \"n\",                            seed = 1357) # # ===== Print the Summary ===== summary(n_power_80) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80) # # ===== Print the Summary ===== summary(n_power_80) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"n\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 107 #>  #> - Final Estimated Power: 0.767  #> - Confidence Interval: [0.726; 0.809] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 107 to 50  #> - Time spent in the search: 23.6 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -2.0266       0.0301   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       1093  #> Residual Deviance: 962   AIC: 966 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.036 1.000  0.372  0.325  0.420 #> 2 107 0.036 1.000  0.767  0.726  0.809 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"use-the-output-of-power4test_by_n","dir":"Articles","previous_headings":"Search N With Target Power","what":"Use the Output of power4test_by_n()","title":"Quick Template: Serial Mediation with Observed Variables","text":"step calling power4test_by_n() sample size. Continue search using output several sample sizes calling x_from_power() output power4test_by_n(). can take time run estimated levels power sample sizes different target power. code: results: Power Curve","code":"# # ===== Reuse the output of power4test_by_n() ===== # Call x_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_80_ns <- x_from_power(out_ns,                               x = \"n\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_80_ns) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns) # # ===== Print the Summary ===== summary(n_power_80_ns) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out_ns, x = \"n\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 119 #>  #> - Final Estimated Power: 0.835  #> - Confidence Interval: [0.799; 0.871] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 90  #> - Time spent in the search: 1.39 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -1.0876       0.0223   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       1861  #> Residual Deviance: 1763  AIC: 1767 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  90 0.037 1.000  0.723  0.679  0.766 #> 2 100 0.037 1.000  0.752  0.710  0.795 #> 3 119 0.037 1.000  0.835  0.799  0.871 #> 4 137 0.039 1.000  0.860  0.826  0.894 #> 5 174 0.038 1.000  0.950  0.929  0.971 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_80_ns)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_mediation_obs_serial.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Serial Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, set paths along indirect effect medium (.30). code: results: illustration, go directly searching x_from_power(): code: results: Power Curve","code":"model_es2 <- \" m1 ~ x: m m2 ~ m1: m m3 ~ m2: m y ~ m3: m y ~ x: s \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effect,                    test_args = list(x = \"x\",                                     m = c(\"m1\", \"m2\", \"m3\"),                                     y = \"y\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     m1                0.300   #>     x                 0.000   #>   m3 ~                        #>     m2                0.300   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .m3                0.910   #>    .y                 0.898   #>     x                 1.000   #>  #> (Computing indirect effects for 7 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.008 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd  skew kurtosis   se #> m1    1 40000 -0.01 1.00  0.00     0.01 0.01 #> m2    2 40000  0.00 1.01 -0.01    -0.01 0.01 #> m3    3 40000  0.00 1.01  0.02     0.03 0.01 #> y     4 40000  0.00 1.00 -0.01    -0.01 0.00 #> x     5 40000 -0.01 1.00  0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.306 #>   m2 ~                      #>     m1                0.303 #>     x                -0.001 #>   m3 ~                      #>     m2                0.305 #>     m1                0.001 #>     x                -0.005 #>   y ~                       #>     m3                0.300 #>     m2               -0.005 #>     m1                0.006 #>     x                 0.105 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        14 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.009 1.000  0.460  0.411  0.509 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Reuse the output of power4test() ===== n2_power_80 <- x_from_power(out2,                             x = \"n\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_80) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80) # # ===== Print the Summary ===== summary(n2_power_80) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out2, x = \"n\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 147 #>  #> - Final Estimated Power: 0.810  #> - Confidence Interval: [0.772; 0.848] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 174  #> - Time spent in the search: 1.361 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -3.6239       0.0345   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2218  #> Residual Deviance: 1957  AIC: 1961 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.009 1.000  0.460  0.411  0.509 #> 2 137 0.008 1.000  0.745  0.702  0.788 #> 3 147 0.008 1.000  0.810  0.772  0.848 #> 4 156 0.008 1.000  0.850  0.815  0.885 #> 5 174 0.008 1.000  0.920  0.893  0.947 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_80)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Mediation with Observed Variables","text":"“Quick Template” articles examples R code determine sample size target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), n_from_power(), refer Get-Started article, article finding sample size given desired power using n_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Mediation with Observed Variables","text":"file simple mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Mediation with Observed Variables","text":"Estimate power sample size. code: results:","code":"library(power4mome) # # ====== Model: Form ====== model <- \" m ~ x y ~ m + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) model_es <- \" m ~ x: s y ~ m: l y ~ x: m \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.100   #>   y ~                         #>     m                 0.500   #>     x                 0.300   #>  #> Variances: #>                    Population #>    .m                 0.990   #>    .y                 0.630   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.050 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01    -0.01 0.01 #> y    2 40000 -0.01  1 -0.02    -0.03 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.099 #>   y ~                       #>     m                 0.499 #>     x                 0.305 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.049 1.000  0.195  0.156  0.234 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"try-another-n","dir":"Articles","previous_headings":"Try One N","what":"Try Another N","title":"Quick Template: Mediation with Observed Variables","text":"can rerun simulation estimate power another sample size going next step. can useful estimated power initial attempt different target power. However, step optional next step, though may take longer, still able find desired region. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 150 # Set n to 150 out_new_n <- power4test(out,                         n = 150) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.053 1.000  0.290  0.246  0.334 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Mediation with Observed Variables","text":"Search, simulation, sample size estimated either: Case 1: Sample size 95% confidence interval estimated power just target level (e.g., .80). , upper bound (ub) close target level. Sample sizes lower sample size power levels significantly lower target level. Case 2: Sample size 95% confidence interval estimated power just target level (e.g., .80). , lower bound (lb) close target level. Sample sizes higher sample size power levels significantly higher target level. step calling power4test() sample size. can take time run estimated power sample size different target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"case-1-significantly-lower-than-the-target","dir":"Articles","previous_headings":"Find the Regions of N Based on the Target Power","what":"Case 1: Significantly Lower Than The Target","title":"Quick Template: Mediation with Observed Variables","text":"consider Case 1 first. goal find region sample sizes power significantly lower target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_ub <- n_from_power(out,                               what = \"ub\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_ub) # # ===== Print the Summary ===== summary(n_power_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 654 #>  #> - Final Estimated Power: 0.738  #> - Confidence Interval: [0.694; 0.781] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 897  #> - Time spent in the search: 47.71 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.641485     0.003979   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       2178  #> Residual Deviance: 1756  AIC: 1760 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.049 1.000  0.195  0.156  0.234 #> 2 410 0.049 1.000  0.537  0.489  0.586 #> 3 654 0.050 1.000  0.738  0.694  0.781 #> 4 897 0.049 1.000  0.848  0.812  0.883 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_ub)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"case-2-significantly-higher-than-the-target","dir":"Articles","previous_headings":"Find the Regions of N Based on the Target Power","what":"Case 2: Significantly Higher Than The Target","title":"Quick Template: Mediation with Observed Variables","text":"goal Case 2 find region sample sizes power significantly higher target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_lb <- n_from_power(out,                               what = \"lb\",                               seed = 1357) # # ===== Print the Summary ===== summary(n_power_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_lb) # # ===== Print the Summary ===== summary(n_power_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 891 #>  #> - Final Estimated Power: 0.840  #> - Confidence Interval: [0.804; 0.876] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 891  #> - Time spent in the search: 1.072 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.599650     0.003733   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2602  #> Residual Deviance: 2007  AIC: 2011 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1  100 0.049 1.000  0.195  0.156  0.234 #> 2  410 0.049 1.000  0.537  0.489  0.586 #> 3  731 0.049 1.000  0.745  0.702  0.788 #> 4  891 0.049 1.000  0.840  0.804  0.876 #> 5 1051 0.050 1.000  0.907  0.879  0.936 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, set y ~ m path medium (.30) (population indirect effect increased .03). code: results:","code":"model_es2 <- \" m ~ x: s y ~ m: m y ~ x: m \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effect,                    test_args = list(x = \"x\",                                     m = \"m\",                                     y = \"y\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.100   #>   y ~                         #>     m                 0.300   #>     x                 0.300   #>  #> Variances: #>                    Population #>    .m                 0.990   #>    .y                 0.802   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.030 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n  mean sd  skew kurtosis   se #> m    1 40000  0.00  1  0.01    -0.01 0.01 #> y    2 40000 -0.01  1 -0.01    -0.01 0.01 #> x    3 40000  0.00  1  0.01    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.099 #>   y ~                       #>     m                 0.298 #>     x                 0.306 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.029 1.000  0.160  0.124  0.196 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"case-1-significantly-lower-than-the-target-1","dir":"Articles","previous_headings":"Change Population Values and Repeat","what":"Case 1: Significantly Lower Than The Target","title":"Quick Template: Mediation with Observed Variables","text":"Fine region sample sizes power significantly lower target level. results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== n2_power_ub <- n_from_power(out2,                                what = \"ub\",                                seed = 1357) # # ===== Print the Summary ===== summary(n2_power_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_ub) # # ===== Print the Summary ===== summary(n2_power_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 720 #>  #> - Final Estimated Power: 0.777  #> - Confidence Interval: [0.737; 0.818] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 939  #> - Time spent in the search: 47.46 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.952254     0.004445   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       2144  #> Residual Deviance: 1607  AIC: 1611 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.029 1.000  0.160  0.124  0.196 #> 2 500 0.030 1.000  0.608  0.560  0.655 #> 3 720 0.030 1.000  0.777  0.737  0.818 #> 4 939 0.030 1.000  0.882  0.851  0.914 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_ub)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"case-2-significantly-higher-than-the-target-1","dir":"Articles","previous_headings":"Change Population Values and Repeat","what":"Case 2: Significantly Higher Than The Target","title":"Quick Template: Mediation with Observed Variables","text":"Fine region sample sizes power significantly higher target level. results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== n2_power_lb <- n_from_power(out2,                                what = \"lb\",                                seed = 1357) # # ===== Print the Summary ===== summary(n2_power_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_lb) # # ===== Print the Summary ===== summary(n2_power_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 864 #>  #> - Final Estimated Power: 0.853  #> - Confidence Interval: [0.818; 0.887] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 937  #> - Time spent in the search: 1.373 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.879973     0.004162   #>  #> Degrees of Freedom: 2399 Total (i.e. Null);  2398 Residual #> Null Deviance:       2929  #> Residual Deviance: 2161  AIC: 2165 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>      n   est   p.v reject r.cilo r.cihi #> 1  100 0.029 1.000  0.160  0.124  0.196 #> 2  500 0.030 1.000  0.608  0.560  0.655 #> 3  791 0.030 1.000  0.785  0.745  0.825 #> 4  864 0.030 1.000  0.853  0.818  0.887 #> 5  937 0.030 1.000  0.873  0.840  0.905 #> 6 1082 0.030 1.000  0.927  0.902  0.953 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Mediation with Observed Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m ~ x y ~ m + x \" model_es <- \" m ~ x: s y ~ m: l y ~ x: m \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) rejection_rates(out)  # ====== Case 1: Regions of Ns Significantly Lower Than the Target ======  # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_ub <- n_from_power(out,                            what = \"ub\",                            seed = 1357) summary(n_power_ub) plot(n_power_ub)  # ====== Case 2: Regions of Ns Significantly Higher Than the Target ======  n_power_lb <- n_from_power(out,                            what = \"lb\",                            seed = 1357) summary(n_power_lb) plot(n_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Mediation with Observed Variables","text":"options power4test() n_from_power(), please refer help pages, well Get-Started article article n_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Parallel Mediation with Observed Variables","text":"“Quick Template” articles examples R code determine sample size target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), n_from_power(), refer Get-Started article, article finding sample size given desired power using n_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Parallel Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Parallel Mediation with Observed Variables","text":"file parallel mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Estimate power sample size. parallel mediation model several parallel paths (three following example). test function test_indirect_effects() can used estimate power indirect paths significant omnibus set \"all_sig\". code: results: (est NaN test three paths single point estimate test.)","code":"library(power4mome) # # ====== Model: Form ====== # Omit any paths hypothesized to be zero model <- \" m1 ~ x m2 ~ x m3 ~ x y ~ m1 + m2 + m3 + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # -l, -m, and -s denote negative values # Can also set to a number directly # Set each path to the hypothesized magnitude model_es <- \" m1 ~ x: m m2 ~ x: m m3 ~ x: m y ~ m1: s y ~ m2: m y ~ m3: l y ~ x: s \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 100, # when testing all indirect effects by # Monte Carlo confidence intervals out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effects,                   test_args = list(x = \"x\",                                    y = \"y\",                                    mc_ci = TRUE,                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.300   #>   m3 ~                        #>     x                 0.300   #>   y ~                         #>     m1                0.100   #>     m2                0.300   #>     m3                0.500   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .m3                0.910   #>    .y                 0.545   #>     x                 1.000   #>  #> (Computing indirect effects for 3 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.030 #> x -> m2 -> y 0.090 #> x -> m3 -> y 0.150 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean sd  skew kurtosis   se #> m1    1 40000 -0.01  1  0.00     0.01 0.01 #> m2    2 40000  0.00  1 -0.01     0.01 0.01 #> m3    3 40000  0.00  1  0.02     0.03 0.01 #> y     4 40000  0.00  1  0.00     0.00 0.01 #> x     5 40000 -0.01  1  0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.306 #>   m2 ~                      #>     x                 0.300 #>   m3 ~                      #>     x                 0.295 #>   y ~                       #>     m1                0.103 #>     m2                0.296 #>     m3                0.500 #>     x                 0.106 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 2 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        11 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.950 #>   Degrees of freedom                                 3 #>   P-value (Chi-square)                           0.175 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirects: x-...->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.172  0.135  0.210 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"try-another-n","dir":"Articles","previous_headings":"Try One N","what":"Try Another N","title":"Quick Template: Parallel Mediation with Observed Variables","text":"can rerun simulation estimate power another sample size going next step. can useful estimated power initial attempt different target power. However, step optional next step, though may take longer, still able find desired region. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 150 # Set n to 150 out_new_n <- power4test(out,                         n = 150) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.302  0.257  0.348 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Search, simulation, sample size estimated either: Case 1: Sample size 95% confidence interval estimated power just target level (e.g., .80). , upper bound (ub) close target level. Sample sizes lower sample size power levels significantly lower target level. Case 2: Sample size 95% confidence interval estimated power just target level (e.g., .80). , lower bound (lb) close target level. Sample sizes higher sample size power levels significantly higher target level. step calling power4test() sample size. can take time run estimated power sample size different target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"case-1-significantly-lower-than-the-target","dir":"Articles","previous_headings":"Find the Regions of N Based on the Target Power","what":"Case 1: Significantly Lower Than The Target","title":"Quick Template: Parallel Mediation with Observed Variables","text":"consider Case 1 first. goal find region sample sizes power significantly lower target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_ub <- n_from_power(out,                            what = \"ub\",                            seed = 1357) # # ===== Print the Summary ===== summary(n_power_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_ub) # # ===== Print the Summary ===== summary(n_power_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 464 #>  #> - Final Estimated Power: 0.767  #> - Confidence Interval: [0.726; 0.809] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 464  #> - Time spent in the search: 35.99 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -2.326875     0.007589   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       1106  #> Residual Deviance: 801.7     AIC: 805.7 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 100  NaN 1.000  0.172  0.135  0.210 #> 2 464  NaN 1.000  0.767  0.726  0.809 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_ub)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"case-2-significantly-higher-than-the-target","dir":"Articles","previous_headings":"Find the Regions of N Based on the Target Power","what":"Case 2: Significantly Higher Than The Target","title":"Quick Template: Parallel Mediation with Observed Variables","text":"goal Case 2 find region sample sizes power significantly higher target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_lb <- n_from_power(out,                            what = \"lb\",                            seed = 1357) # # ===== Print the Summary ===== summary(n_power_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_lb) # # ===== Print the Summary ===== summary(n_power_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 502 #>  #> - Final Estimated Power: 0.840  #> - Confidence Interval: [0.804; 0.876] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 765  #> - Time spent in the search: 2.848 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -2.112645     0.006998   #>  #> Degrees of Freedom: 2399 Total (i.e. Null);  2398 Residual #> Null Deviance:       2736  #> Residual Deviance: 1977  AIC: 1981 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 100  NaN 1.000  0.172  0.135  0.210 #> 2 464  NaN 1.000  0.767  0.726  0.809 #> 3 502  NaN 1.000  0.840  0.804  0.876 #> 4 540  NaN 1.000  0.868  0.834  0.901 #> 5 615  NaN 1.000  0.875  0.843  0.907 #> 6 765  NaN 1.000  0.935  0.911  0.959 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Parallel Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, change paths mediators (m1, m2, m3) medium (m). code: results:","code":"model_es2 <- \" m1 ~ x: m m2 ~ x: m m3 ~ x: m y ~ m1: m y ~ m2: m y ~ m3: m y ~ x: s \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effects,                    test_args = list(x = \"x\",                                     y = \"y\",                                     mc_ci = TRUE,                                     omnibus = \"all_sig\"),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> m3 ~ x #> y ~ m1 + m2 + m3 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.300   #>   m3 ~                        #>     x                 0.300   #>   y ~                         #>     m1                0.300   #>     m2                0.300   #>     m3                0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .m3                0.910   #>    .y                 0.617   #>     x                 1.000   #>  #> (Computing indirect effects for 3 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                ind #> x -> m1 -> y 0.090 #> x -> m2 -> y 0.090 #> x -> m3 -> y 0.090 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean sd  skew kurtosis   se #> m1    1 40000 -0.01  1  0.00     0.01 0.01 #> m2    2 40000  0.00  1 -0.01     0.01 0.01 #> m3    3 40000  0.00  1  0.02     0.03 0.01 #> y     4 40000  0.00  1  0.00     0.00 0.01 #> x     5 40000 -0.01  1  0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.306 #>   m2 ~                      #>     x                 0.300 #>   m3 ~                      #>     x                 0.295 #>   y ~                       #>     m1                0.303 #>     m2                0.296 #>     m3                0.299 #>     x                 0.106 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        11 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.950 #>   Degrees of freedom                                 3 #>   P-value (Chi-square)                           0.175 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirects: x-...->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>    est   p.v reject r.cilo r.cihi #> 1  NaN 1.000  0.545  0.496  0.594 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"case-1-significantly-lower-than-the-target-1","dir":"Articles","previous_headings":"Change Population Values and Repeat","what":"Case 1: Significantly Lower Than The Target","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Fine region sample sizes power significantly lower target level. results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== n2_power_ub <- n_from_power(out2,                             what = \"ub\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_ub) # # ===== Print the Summary ===== summary(n2_power_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 124 #>  #> - Final Estimated Power: 0.762  #> - Confidence Interval: [0.721; 0.804] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 147  #> - Time spent in the search: 1.064 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -3.56874      0.03771   #>  #> Degrees of Freedom: 1199 Total (i.e. Null);  1198 Residual #> Null Deviance:       1408  #> Residual Deviance: 1296  AIC: 1300 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 100  NaN 1.000  0.545  0.496  0.594 #> 2 124  NaN 1.000  0.762  0.721  0.804 #> 3 147  NaN 1.000  0.873  0.840  0.905 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_ub)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"case-2-significantly-higher-than-the-target-1","dir":"Articles","previous_headings":"Change Population Values and Repeat","what":"Case 2: Significantly Higher Than The Target","title":"Quick Template: Parallel Mediation with Observed Variables","text":"Fine region sample sizes power significantly higher target level. results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== n2_power_lb <- n_from_power(out2,                             what = \"lb\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_lb) # # ===== Print the Summary ===== summary(n2_power_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 136 #>  #> - Final Estimated Power: 0.828  #> - Confidence Interval: [0.790; 0.865] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 147  #> - Time spent in the search: 1.581 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -3.57693      0.03779   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       1793  #> Residual Deviance: 1663  AIC: 1667 #>  #> - Detailed Results: #>  #> [test]: test_indirects: x-...->y  #> [test_label]: x-...->y (All sig)  #>     n  est   p.v reject r.cilo r.cihi #> 1 100  NaN 1.000  0.545  0.496  0.594 #> 2 124  NaN 1.000  0.762  0.721  0.804 #> 3 136  NaN 1.000  0.828  0.790  0.865 #> 4 147  NaN 1.000  0.873  0.840  0.905 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Parallel Mediation with Observed Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m1 ~ x m2 ~ x m3 ~ x y ~ m1 + m2 + m3 + x \"  model_es <- \" m1 ~ x: m m2 ~ x: m m3 ~ x: m y ~ m1: s y ~ m2: m y ~ m3: l y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing all indirect effects by # Monte Carlo confidence intervals  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effects,                   test_args = list(x = \"x\",                                    y = \"y\",                                    mc_ci = TRUE,                                    omnibus = \"all_sig\"),                   iseed = 1234,                   parallel = TRUE) rejection_rates(out)  # ====== Case 1: Regions of Ns Significantly Lower Than the Target ======  # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_ub <- n_from_power(out,                            what = \"ub\",                            seed = 1357) summary(n_power_ub) plot(n_power_ub)  # ====== Case 2: Regions of Ns Significantly Higher Than the Target ======  n_power_lb <- n_from_power(out,                            what = \"lb\",                            seed = 1357) summary(n_power_lb) plot(n_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_parallel.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Parallel Mediation with Observed Variables","text":"options power4test() n_from_power(), please refer help pages, well Get-Started article article n_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Template: Serial Mediation with Observed Variables","text":"“Quick Template” articles examples R code determine sample size target level power typical models using power4mome. Users can quickly adapt scenarios. summary code examples can found section Code Template end document.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Quick Template: Serial Mediation with Observed Variables","text":"Basic knowledge fitting models lavaan power4mome required. file intended introduction use functions power4mome. details use power4test(), n_from_power(), refer Get-Started article, article finding sample size given desired power using n_from_power(), well help pages functions.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"common-flow","dir":"Articles","previous_headings":"","what":"Common Flow","title":"Quick Template: Serial Mediation with Observed Variables","text":"following chart summarizes steps covered . Common Workflow practice, steps can repeated, population values changed, desired goal achieved (e.g., sample size power close target power found).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Quick Template: Serial Mediation with Observed Variables","text":"file serial mediation models.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"try-one-n","dir":"Articles","previous_headings":"","what":"Try One N","title":"Quick Template: Serial Mediation with Observed Variables","text":"Estimate power sample size. code: results:","code":"library(power4mome) # # ====== Model: Form ====== # Omit any paths hypothesized to be zero model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \" # # ====== Model: Population Values ====== # l: large (.50 by default) # m: medium (.30 by default) # s: small (.10 by default) # -l, -m, and -s denote negative values # Can also set to a number directly # Set each path to the hypothesized magnitude model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \" # # ====== Test the Model Specification ====== out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234) # # ====== Check the Data Generated ====== print(out,       data_long = TRUE) # # ====== Estimate the Power ====== # For n = 50, # when testing the indirect effect by # Monte Carlo confidence interval out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 50,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.500   #>   m2 ~                        #>     m1                0.500   #>     x                 0.000   #>   m3 ~                        #>     m2                0.500   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.750   #>    .m2                0.750   #>    .m3                0.750   #>    .y                 0.893   #>     x                 1.000   #>  #> (Computing indirect effects for 7 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.037 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  50  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd skew kurtosis   se #> m1    1 20000 -0.01 1.00 0.03    -0.04 0.01 #> m2    2 20000  0.00 1.00 0.01     0.06 0.01 #> m3    3 20000 -0.01 1.00 0.01    -0.05 0.01 #> y     4 20000 -0.01 1.00 0.01    -0.03 0.01 #> x     5 20000  0.00 1.01 0.00    -0.02 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 20000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.493 #>   m2 ~                      #>     m1                0.498 #>     x                 0.010 #>   m3 ~                      #>     m2                0.499 #>     m1               -0.001 #>     x                 0.011 #>   y ~                       #>     m3                0.296 #>     m2               -0.002 #>     m1                0.014 #>     x                 0.086 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        14 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.036 1.000  0.372  0.325  0.420 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"try-another-n","dir":"Articles","previous_headings":"Try One N","what":"Try Another N","title":"Quick Template: Serial Mediation with Observed Variables","text":"can rerun simulation estimate power another sample size going next step. can useful estimated power initial attempt different target power. However, step optional next step, though may take longer, still able find desired region. code: results:","code":"# # ===== Reuse the output of power4test() ===== # Estimate power for n = 150 # Set n to 150 out_new_n <- power4test(out,                         n = 150) # # ===== Compute Rejection Rate (Power) ===== rejection_rates(out_new_n) rejection_rates(out_new_n) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.038 1.000  0.927  0.902  0.953 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"find-the-regions-of-n-based-on-the-target-power","dir":"Articles","previous_headings":"","what":"Find the Regions of N Based on the Target Power","title":"Quick Template: Serial Mediation with Observed Variables","text":"Search, simulation, sample size estimated either: Case 1: Sample size 95% confidence interval estimated power just target level (e.g., .80). , upper bound (ub) close target level. Sample sizes lower sample size power levels significantly lower target level. Case 2: Sample size 95% confidence interval estimated power just target level (e.g., .80). , lower bound (lb) close target level. Sample sizes higher sample size power levels significantly higher target level. step calling power4test() sample size. can take time run estimated power sample size different target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"case-1-significantly-lower-than-the-target","dir":"Articles","previous_headings":"Find the Regions of N Based on the Target Power","what":"Case 1: Significantly Lower Than The Target","title":"Quick Template: Serial Mediation with Observed Variables","text":"consider Case 1 first. goal find region sample sizes power significantly lower target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_ub <- n_from_power(out,                            what = \"ub\",                            seed = 1357) # # ===== Print the Summary ===== summary(n_power_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_ub) # # ===== Print the Summary ===== summary(n_power_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 107 #>  #> - Final Estimated Power: 0.767  #> - Confidence Interval: [0.726; 0.809] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 107 to 50  #> - Time spent in the search: 24 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>     -2.0266       0.0301   #>  #> Degrees of Freedom: 799 Total (i.e. Null);  798 Residual #> Null Deviance:       1093  #> Residual Deviance: 962   AIC: 966 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.036 1.000  0.372  0.325  0.420 #> 2 107 0.036 1.000  0.767  0.726  0.809 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_ub)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"case-2-significantly-higher-than-the-target","dir":"Articles","previous_headings":"Find the Regions of N Based on the Target Power","what":"Case 2: Significantly Higher Than The Target","title":"Quick Template: Serial Mediation with Observed Variables","text":"goal Case 2 find region sample sizes power significantly higher target level. code: results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted) n_power_lb <- n_from_power(out,                            what = \"lb\",                            seed = 1357) # # ===== Print the Summary ===== summary(n_power_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n_power_lb) # # ===== Print the Summary ===== summary(n_power_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 125 #>  #> - Final Estimated Power: 0.850  #> - Confidence Interval: [0.815; 0.885] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 107 to 50  #> - Time spent in the search: 1.568 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.78062      0.02668   #>  #> Degrees of Freedom: 1999 Total (i.e. Null);  1998 Residual #> Null Deviance:       2211  #> Residual Deviance: 1809  AIC: 1813 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.036 1.000  0.372  0.325  0.420 #> 2 107 0.036 1.000  0.767  0.726  0.809 #> 3 125 0.037 1.000  0.850  0.815  0.885 #> 4 142 0.036 1.000  0.865  0.832  0.898 #> 5 177 0.037 1.000  0.938  0.914  0.961 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"change-population-values-and-repeat","dir":"Articles","previous_headings":"","what":"Change Population Values and Repeat","title":"Quick Template: Serial Mediation with Observed Variables","text":"necessary, change population value(s) repeat steps. example, set paths along indirect effect medium (.30). code: results:","code":"model_es2 <- \" m1 ~ x: m m2 ~ m1: m m3 ~ m2: m y ~ m3: m y ~ x: s \" # # ====== Estimate the Power ====== out2 <- power4test(nrep = 400,                    model = model,                    pop_es = model_es2,                    n = 100,                    R = 1000,                    ci_type = \"mc\",                    test_fun = test_indirect_effect,                    test_args = list(x = \"x\",                                     m = c(\"m1\", \"m2\", \"m3\"),                                     y = \"y\",                                     mc_ci = TRUE),                    iseed = 1234,                    parallel = TRUE) # # ====== Compute the Rejection Rate ====== rejection_rates(out2) print(out2,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ m1 + x #> m3 ~ m2 + m1 + x #> y ~ m3 + m2 + m1 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     m1                0.300   #>     x                 0.000   #>   m3 ~                        #>     m2                0.300   #>     m1                0.000   #>     x                 0.000   #>   y ~                         #>     m3                0.300   #>     m2                0.000   #>     m1                0.000   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.910   #>    .m3                0.910   #>    .y                 0.898   #>     x                 1.000   #>  #> (Computing indirect effects for 7 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>                            ind #> x -> m1 -> m2 -> m3 -> y 0.008 #> x -> m1 -> m2 -> y       0.000 #> x -> m1 -> m3 -> y       0.000 #> x -> m1 -> y             0.000 #> x -> m2 -> m3 -> y       0.000 #> x -> m2 -> y             0.000 #> x -> m3 -> y             0.000 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  400  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>    vars     n  mean   sd  skew kurtosis   se #> m1    1 40000 -0.01 1.00  0.00     0.01 0.01 #> m2    2 40000  0.00 1.01 -0.01    -0.01 0.01 #> m3    3 40000  0.00 1.01  0.02     0.03 0.01 #> y     4 40000  0.00 1.00 -0.01    -0.01 0.00 #> x     5 40000 -0.01 1.00  0.00    -0.03 0.01 #>  #> ==== Parameter Estimates Based on All 400 Samples Combined ==== #>  #> Total Sample Size: 40000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m1 ~                      #>     x                 0.306 #>   m2 ~                      #>     m1                0.303 #>     x                -0.001 #>   m3 ~                      #>     m2                0.305 #>     m1                0.001 #>     x                -0.005 #>   y ~                       #>     m3                0.300 #>     m2               -0.005 #>     m1                0.006 #>     x                 0.105 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                        14 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 1000  #>  #>  #> ====================== Test(s) Conducted ====================== #>  #> - test_indirect: x->m1->m2->m3->y #>  #> Call print() and set 'test_long = TRUE' for a detailed report. rejection_rates(out2) #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     est   p.v reject r.cilo r.cihi #> 1 0.009 1.000  0.460  0.411  0.509 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"case-1-significantly-lower-than-the-target-1","dir":"Articles","previous_headings":"Change Population Values and Repeat","what":"Case 1: Significantly Lower Than The Target","title":"Quick Template: Serial Mediation with Observed Variables","text":"Fine region sample sizes power significantly lower target level. results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== n2_power_ub <- n_from_power(out2,                             what = \"ub\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_ub) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_ub) # # ===== Print the Summary ===== summary(n2_power_ub) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"ub\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 137 #>  #> - Final Estimated Power: 0.745  #> - Confidence Interval: [0.702; 0.788] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 174  #> - Time spent in the search: 48.97 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -3.64706      0.03472   #>  #> Degrees of Freedom: 1199 Total (i.e. Null);  1198 Residual #> Null Deviance:       1449  #> Residual Deviance: 1229  AIC: 1233 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.009 1.000  0.460  0.411  0.509 #> 2 137 0.008 1.000  0.745  0.702  0.788 #> 3 174 0.008 1.000  0.920  0.893  0.947 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_ub)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"case-2-significantly-higher-than-the-target-1","dir":"Articles","previous_headings":"Change Population Values and Repeat","what":"Case 2: Significantly Higher Than The Target","title":"Quick Template: Serial Mediation with Observed Variables","text":"Fine region sample sizes power significantly higher target level. results: Power Curve","code":"# # ===== Reuse the output of power4test() ===== n2_power_lb <- n_from_power(out2,                             what = \"lb\",                             seed = 1357) # # ===== Print the Summary ===== summary(n2_power_lb) # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_lb) # # ===== Print the Summary ===== summary(n2_power_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out2, x = \"n\", what = \"lb\",  #>     goal = \"close_enough\", seed = 1357) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 156 #>  #> - Final Estimated Power: 0.850  #> - Confidence Interval: [0.815; 0.885] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 100 to 174  #> - Time spent in the search: 1.126 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -3.62266      0.03448   #>  #> Degrees of Freedom: 1599 Total (i.e. Null);  1598 Residual #> Null Deviance:       1821  #> Residual Deviance: 1568  AIC: 1572 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m1->m2->m3->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.009 1.000  0.460  0.411  0.509 #> 2 137 0.008 1.000  0.745  0.702  0.788 #> 3 156 0.008 1.000  0.850  0.815  0.885 #> 4 174 0.008 1.000  0.920  0.893  0.947 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. # # ===== Plot the (Crude) Power Curve ===== plot(n2_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"code_template","dir":"Articles","previous_headings":"","what":"Code Template","title":"Quick Template: Serial Mediation with Observed Variables","text":"code used :","code":"library(power4mome)  # ====== Model and Effect Size (Population Values) ======  model <- \" m1 ~ x m2 ~ m1 + x m3 ~ m2 + m1 + x y ~ m3 + m2 + m1 + x \"  model_es <- \" m1 ~ x: l m2 ~ m1: l m3 ~ m2: l y ~ m3: m y ~ x: s \"  # Test the Model Specification  out <- power4test(nrep = 2,                   model = model,                   pop_es = model_es,                   n = 50000,                   iseed = 1234)  # Check the Data Generated  print(out,       data_long = TRUE)  # ====== Try One N and Estimate the Power ======  # For n = 100, # when testing the indirect effect by # Monte Carlo confidence interval  out <- power4test(nrep = 400,                   model = model,                   pop_es = model_es,                   n = 100,                   R = 1000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = c(\"m1\", \"m2\", \"m3\"),                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) rejection_rates(out)  # ====== Case 1: Regions of Ns Significantly Lower Than the Target ======  # Call n_from_power() # - Set target power: target_power = .80 (Default, can be omitted) # - Set the seed for the simulation: Integer. Should always be set. # To set desired precision: # - Set final number of R: final_R = 1000 (Default, can be omitted) # - Set final number of replications: final_nrep = 400 (Default, can be omitted)  n_power_ub <- n_from_power(out,                            what = \"ub\",                            seed = 1357) summary(n_power_ub) plot(n_power_ub)  # ====== Case 2: Regions of Ns Significantly Higher Than the Target ======  n_power_lb <- n_from_power(out,                            what = \"lb\",                            seed = 1357) summary(n_power_lb) plot(n_power_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/template_n_from_power_mediation_obs_serial.html","id":"final-remarks","dir":"Articles","previous_headings":"","what":"Final Remarks","title":"Quick Template: Serial Mediation with Observed Variables","text":"options power4test() n_from_power(), please refer help pages, well Get-Started article article n_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Effect Size Given Desired Power","text":"article brief illustration use x_from_power() power4test() package power4mome find simulation, given sample size factors, given desired power, minimum effect size detected level power (see note “minimum”). illustration use indirect effect tested Monte Carlo confidence interval example, though procedure similar tests supported power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Effect Size Given Desired Power","text":"Basic knowledge fitting models lavaan required. Readers also expected know use power4test() (see get-started introduction).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Effect Size Given Desired Power","text":"brief illustration. complicated scenarios features x_from_power() described vignettes. sections repeated vignettes make vignette self-contained.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Effect Size Given Desired Power","text":"illustration needs following package(s):","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Effect Size Given Desired Power","text":"Three functions, along methods, sufficient estimating sample size, given desired power, along factors test, model, sample size. basic workflow: Specify model syntax population model, lavaan style, set initial population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified, using sample size examined. Call rejection_rates() compute power verify test setup correctly. Call x_from_power() estimated minimum effect size can detected, given factors, including sample size examined target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Effect Size Given Desired Power","text":"Let’s consider simple mediation model, effect concern indirect effect tested Monte Carlo confidence interval. special consideration regarding indirect effect: effect function two model parameters. example, simple mediation -path predictor mediator, b-path mediator outcome variable, indirect effect ab. found power detect particular value ab, say 0.25, combinations b. example, Kenny & Judd (2014) found required sample size power .80 detect ab .0225 can vary 450 large 5000, depending values b. Therefore, even like find minimum ab can detected power .80 given sample size, still manipulate one parameter (e.g., b) one time. Two additional notes notion “minimum”. First, simplicity, positive population values considered. However, may cases population values consideration negative. cases, “minimum” refers minimum magnitude. Second, may cases , even keeping values considered positive, relation power parameter varied U-shaped. cases, two values selected parameters may target power. plot relation (described lated) examined see whether solution likely minimum value range examined. illustrated vignette.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Effect Size Given Desired Power","text":"model syntax Note , even going test mediation, need add labels defined user-parameters. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Effect Size Given Desired Power","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (-called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : word denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Effect Size Given Desired Power","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown print object: argument data_long = TRUE used verify simulation. population values regression paths section Population Values specified. model specified correctly. section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. default, population model fitted dataset, hence section <fit>. section just verifies population can fitted results show population model desired one. can proceed next stage","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) print(out,       data_long = TRUE) #>  #> ============================== Model Information ============================== #>  #> ====== Model on Factors/Variables ====== #>  #> m ~ x #> y ~ m + x #>  #> ==== Model on Variables/Indicators ==== #>  #> m ~ x #> y ~ m + x #>  #> ========== Population Values ========== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> ==== Population Indirect Effect(s) ==== #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> =============================== Data Information =============================== #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ======== Descriptive Statistics ======== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ============= Parameter Estimates Based on All 2 Samples Combined ============= #>  #> Total Sample Size: 100000  #>  #> ======== Standardized Estimates ======== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ============================ Extra Element(s) Found ============================ #>  #> - fit #>  #> ======== Element(s) of the First Dataset ======== #>  #> ================ <fit> ================ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Effect Size Given Desired Power","text":"can now simulation estimate power initial values (m ~ x) b (y ~ m), given target sample size verify test want . large number datasets (e.g., 500) target sample size initial population values model generated, target test conducted datasets. Suppose start hold b medium (.30) direct effect (y ~ x) small (.10), sample size 100, like estimate power using Monte Carlo confidence interval test indirect effect x y m, also medium. call, based previous one: goal find value parameter, case, specific level power sample size, sufficient precision, need large number replications (nrep) stage. can use 50. can set target number replications calling function x_from_power(). successively increase nrep search, accepts solution based target number replications. new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-function tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case test done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 Note simulation can take time run (3 4 minutes using 20 cores). Progress printed run interactive session. default printout: argument test_long = TRUE added verify test set . shown , setup correct. can now call x_from_power() search.","code":"out <- power4test(nrep = 50,                   model = mod,                   pop_es = mod_es,                   n = 100,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 1234,                   parallel = TRUE) print(out,       test_long = TRUE) #>  #> ============================== Model Information ============================== #>  #> ====== Model on Factors/Variables ====== #>  #> m ~ x #> y ~ m + x #>  #> ==== Model on Variables/Indicators ==== #>  #> m ~ x #> y ~ m + x #>  #> ========== Population Values ========== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> ==== Population Indirect Effect(s) ==== #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> =============================== Data Information =============================== #>  #> Number of Replications:  50  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ============================ Extra Element(s) Found ============================ #>  #> - fit #> - mc_out #>  #> ======== Element(s) of the First Dataset ======== #>  #> ================ <fit> ================ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =============== <mc_out> =============== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> ====================== <test_indirect: x->m->y> ====================== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.145 0.036 0.273 0.820 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 50  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"call-x_from_power-to-estimate-the-minimum-value-of-a","dir":"Articles","previous_headings":"Mediation","what":"Call x_from_power() to Estimate the Minimum Value of a","title":"Effect Size Given Desired Power","text":"simplified description x_from_power() works: rerun simulation test output power4test() different values selected parameter, estimate power levels . try estimate relation power value selected parameter, select next value(s) try. adopt value solution () confidence interval estimated power includes target power (default level 95%), (b) number replications used estimation target one (ensure standard error desired level). argument used : x: want find, \"es\" stands effect sizes. pop_es_name: name parameter value varied. name one used lavaan using coef(). See power4test_by_es() setting name. target_power: target power. Default .80. final_nrep: number replications desired solution. using normal approximation form 95% confidence interval sample proportion (power case). nrep = 400, 95% confidence limits power .80 .04 .80. precise enough estimating sample size required. seed: make search reproducible, possible, set seed integer.","code":"out_es_a <- x_from_power(out,                          x = \"es\",                          pop_es_name = \"m~x\",                          target_power = .80,                          final_nrep = 400,                          seed = 4567)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"examine-the-output","dir":"Articles","previous_headings":"Mediation","what":"Examine the Output","title":"Effect Size Given Desired Power","text":"basic output: estimated value power close .80 power detect indirect effect (ab, b equal .30 population) Monte Carlo interval 0.494. estimated power based simulation 0.802. , given model sample size 100, population value b medium (.30), test approximate power .80 population value 0.494. corresponding indirect effect 0.148 obtain detailed results search, can use summary() method: reports 95% confidence interval estimated power, [0.763; 0.842]. also reports major technical information regarding search, range values tried, time spent, table values examined, along estimated power levels confidence intervals. also prints model, “power curve”, used estimate relation power value selected parameter. Note crude model intended values examined. intended estimate power values outside range studied. Even though model crude one, can still give rough idea relation. simple plot can requested plot(): Power Curve black line plot sample sizes studied, along estimated power levels 95% confidence intervals. intervals vary width different number replications. red line plot based model (logistic model case), along range sample sizes examined.","code":"out_es_a #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"m~x\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #>  #>                          Setting #> Predictor(x):        Effect Size #> Parameter:                   m~x #> goal:                     ci_hit #> what:                      point #> algorithm:           power_curve #> Level of confidence:      95.00% #> Target Power:              0.800 #>  #> - Final Value of'm~x': 0.494 #>  #> - Final Estimated Power (CI): 0.802 [0.763, 0.842] #>  #> Call `summary()` for detailed results. summary(out_es_a) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"m~x\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #>  #> Predictor (x): Effect Size  #> Parameter Name (pop_es_name): m~x  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power enclosing the target #>   power. #>  #> === Major Results === #>  #> - Final Value (m~x): 0.494 #>  #> - Final Estimated Power: 0.802  #> - Confidence Interval: [0.763; 0.842] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: power_curve  #> - The range of values explored: 0.488 to 0.519  #> - Time spent in the search: 1.214 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress, models = c(\"glm\",  #>         \"lm\")) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      -7.903       18.428   #>  #> Degrees of Freedom: 249 Total (i.e. Null);  248 Residual #> Null Deviance:       270.8  #> Residual Deviance: 270.6     AIC: 274.6 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>    par    es   est   p.v reject r.cilo r.cihi #> 1  m~x 0.488 0.151 1.000  0.760  0.642  0.878 #> 2  m~x 0.491 0.147 1.000  0.780  0.665  0.895 #> 3  m~x 0.492 0.150 1.000  0.790  0.710  0.870 #> 4  m~x 0.494 0.140 1.000  0.720  0.596  0.844 #> 5  m~x 0.494 0.148 1.000  0.802  0.763  0.842 #> 6  m~x 0.497 0.150 1.000  0.760  0.642  0.878 #> 7  m~x 0.500 0.145 1.000  0.820  0.714  0.926 #> 8  m~x 0.501 0.150 1.000  0.767  0.726  0.809 #> 9  m~x 0.504 0.150 1.000  0.772  0.720  0.824 #> 10 m~x 0.519 0.155 1.000  0.740  0.654  0.826 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the rejection rate. If #>   the null hypothesis is true, this is the Type I error rate. If the null hypothesis is #>   false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based on normal #>   approximation. #> - Refer to the tests for the meanings of other columns. plot(out_es_a)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"finding-the-minimum-value-of-b-when-holding-a-to--30","dir":"Articles","previous_headings":"Mediation","what":"Finding the Minimum Value of b When Holding a to .30","title":"Effect Size Given Desired Power","text":"can also find minimum value b holding medium (.30). Just call x_from_power() , setting pop_es_name \"y~m\". estimated value b power close .80 power detect indirect effect (ab, equal .30 population) Monte Carlo interval 0.307. estimated power based simulation 0.823. , given model sample size 100, population value medium (.30), test approximate power .80 population value b 0.307. corresponding indirect effect 0.092, slightly lower indirect effect b hold .30. detailed results search b varied: reports 95% confidence interval estimated power, [0.785; 0.860]. Power Curve (b varied)","code":"out_es_b <- x_from_power(out,                          x = \"es\",                          pop_es_name = \"y~m\",                          target_power = .80,                          final_nrep = 400,                          seed = 4567) summary(out_es_b) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = out, x = \"es\", pop_es_name = \"y~m\", target_power = 0.8,  #>     final_nrep = 400, seed = 4567) #>  #> Predictor (x): Effect Size  #> Parameter Name (pop_es_name): y~m  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power enclosing the target #>   power. #>  #> === Major Results === #>  #> - Final Value (y~m): 0.307 #>  #> - Final Estimated Power: 0.823  #> - Confidence Interval: [0.785; 0.860] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: power_curve  #> - The range of values explored: 0.293 to 0.343  #> - Time spent in the search: 1.286 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_i, formula = power_model, start = start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress, models = c(\"glm\",  #>         \"lm\")) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      -2.366       11.727   #>  #> Degrees of Freedom: 249 Total (i.e. Null);  248 Residual #> Null Deviance:       280.1  #> Residual Deviance: 280   AIC: 284 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>    par    es   est   p.v reject r.cilo r.cihi #> 1  y~m 0.293 0.151 1.000  0.780  0.665  0.895 #> 2  y~m 0.295 0.147 1.000  0.760  0.642  0.878 #> 3  y~m 0.296 0.140 1.000  0.680  0.551  0.809 #> 4  y~m 0.298 0.150 1.000  0.720  0.596  0.844 #> 5  y~m 0.300 0.145 1.000  0.820  0.714  0.926 #> 6  y~m 0.300 0.153 1.000  0.780  0.699  0.861 #> 7  y~m 0.307 0.153 1.000  0.823  0.785  0.860 #> 8  y~m 0.317 0.158 1.000  0.820  0.782  0.858 #> 9  y~m 0.320 0.158 1.000  0.836  0.790  0.882 #> 10 y~m 0.343 0.171 1.000  0.870  0.804  0.936 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the rejection rate. If #>   the null hypothesis is true, this is the Type I error rate. If the null hypothesis is #>   false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based on normal #>   approximation. #> - Refer to the tests for the meanings of other columns. plot(out_es_b)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_es.html","id":"advanced-features","dir":"Articles","previous_headings":"","what":"Advanced Features","title":"Effect Size Given Desired Power","text":"brief illustration covers basic features x_from_power(). ways customize search, range values parameter examine (default 0 0.7), level confidence confidence interval, number trials (10 default). Please refer help page x_from_power() options.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sample Size Given Desired Power","text":"article brief illustration use n_from_power() power4test() package power4mome find simulation sample size power close desired level detect effect, given level population effect size. illustration use indirect effect tested Monte Carlo confidence interval example, though procedure similar tests supported power4test().","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"prerequisite","dir":"Articles","previous_headings":"","what":"Prerequisite","title":"Sample Size Given Desired Power","text":"Basic knowledge fitting models lavaan required. Readers also expected know use power4test() (see get-started introduction).","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"scope","dir":"Articles","previous_headings":"","what":"Scope","title":"Sample Size Given Desired Power","text":"brief illustration. complicated scenarios features x_from_power() described vignettes articles. sections repeated vignettes articles make vignette self-contained.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Sample Size Given Desired Power","text":"illustration needs following package(s):","code":"library(power4mome)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Sample Size Given Desired Power","text":"Three functions, along methods, sufficient estimating sample size, given desired power, along factors test, model, population values. basic workflow: Specify model syntax population model, lavaan style, set population values model parameters. Call power4test() examine setup datasets generated. Repeat previous steps model specified correctly. Call power4test() , test specified, using initial sample size. Call rejection_rates() compute power verify test setup correctly. Call n_from_power() estimate sample size required desired power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"mediation","dir":"Articles","previous_headings":"","what":"Mediation","title":"Sample Size Given Desired Power","text":"Let’s consider simple mediation model. like estimate sample size required detect mediation effect Monte Carlo confidence interval, 95% level significance. sampling (simulation) error involved analytic solution find sample size, instead estimating unknown sample size, can also estimate, approximately, region sample sizes levels power significantly lower target power, significantly higher target power. , find sample size confidence interval, 95% default, just (Case 1) just (Case 2) target power, approximately. consider Case 1 first.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"specify-the-population-model","dir":"Articles","previous_headings":"Mediation","what":"Specify the Population Model","title":"Sample Size Given Desired Power","text":"model syntax Note , even going test mediation, need label parameters define indirect effect usuall lavaan. taken care test functions, use package manymome (Cheung & Cheung, 2024).","code":"mod <- \" m ~ x y ~ m + x \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"es_convention","dir":"Articles","previous_headings":"Mediation","what":"Specify The Population Values","title":"Sample Size Given Desired Power","text":"two approaches : using named vectors lists, using long string similar lavaan model syntax. second approach demonstrated . Suppose want estimate power : path x m “large” strength. path m y “medium” strength. path x m “small” strength. default, power4mome use convention regression path correlation:1 Small: .10 (-.10) Medium: .30 (-.30) Large: .50 (-.50) values standardized solution (-called “betas”). following string denotes desired values: line starts tag, parameter presented lavaan syntax. tag ends colon, :. colon population value, can : word denoting value. default: s: Small. (-s small negative.) m: Medium. (-m medium negative.) l: Large. (-l large negative.) nil: Zero. regression coefficients covariances, specified, set zero.","code":"mod_es <- \" m ~ x: l y ~ m: m y ~ x: s \""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"call-power4test-to-check-the-model","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Check the Model","title":"Sample Size Given Desired Power","text":"arguments used: nrep: number replications. stage, small number can used. important large sample size replications. model: model syntax. pop_es: string setting population values. n: sample size replications. stage, just checking model data generation, number can set large one unless model slow fit sample size large. iseed: supplied, used set seed random number generator. advised always set arbitrary integer, make results reproducible.2 population values can shown print object: argument data_long = TRUE used verify simulation. population values regression paths section Population Values specified. model specified correctly. section Descriptive Statistics, generated psych::describe(), shows basic descriptive statistics observed variables. expected, means close zero standard deviations close one, datasets generated using standardized model. section Parameter Estimates Based shows parameter estimates population model fitted datasets combined. total sample size large, estimates close population values. default, population model fitted dataset, hence section <fit>. section just verifies population can fitted results show population model desired one. can proceed next stage","code":"out <- power4test(nrep = 2,                   model = mod,                   pop_es = mod_es,                   n = 50000,                   iseed = 1234) print(out,       data_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  50000  #>  #> ==== Descriptive Statistics ==== #>  #>   vars     n mean sd skew kurtosis se #> m    1 1e+05 0.00  1 0.01     0.03  0 #> y    2 1e+05 0.01  1 0.01     0.00  0 #> x    3 1e+05 0.00  1 0.01     0.01  0 #>  #> ===== Parameter Estimates Based on All 2 Samples Combined ===== #>  #> Total Sample Size: 100000  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.500 #>   y ~                       #>     m                 0.295 #>     x                 0.102 #>  #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                         50000 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"med_power","dir":"Articles","previous_headings":"Mediation","what":"Call power4test() to Do the Target Test","title":"Sample Size Given Desired Power","text":"can now simulation estimate power initial sample size, verify test wan . large number datasets (e.g., 500) target sample size generated, target test conducted datasets. Suppose like estimate power using Monte Carlo confidence interval test indirect effect x y m, sample size 50. call, based previous one: goal find sample size specific level power, sufficient precision, need large number replications (nrep) stage. can use 50. can set target number replications calling function n_from_power(), wrapper general function x_from_power(). new arguments used: R: number replications used generate Monte Carlo simulated estimates, 2000 example. ci_type: method used generate estimates. Support Monte Carlo (\"mc\") nonparametric bootstrapping (\"boot\").3 Although bootstrapping usually used test indirect effect, slow R bootstrapping nrep datasets (model fitted R * nrep times). Therefore, preferable use Monte Carlo initial estimation. test_fun: function used test replication. function following specific requirement can used, power4mome comes several built-function tests. function test_indirect_effect() used test indirect effect model. test_args: named list arguments supplied test_fun. test_indirect_effect(), named list specifying predictor (x), mediator(s) (m), outcome (y). path number mediators can supported. Please refer help page test_indirect_effect().4 parallel: test conducted slow, case test done Monte Carlo nonparametric bootstrapping confidence interval, advised enable parallel processing setting parallel TRUE.5 Note simulation can take time run. Progress printed run interactive session. default printout: argument test_long = TRUE added verify test set . shown , setup correct. can now call n_from_power() search.","code":"out <- power4test(nrep = 50,                   model = mod,                   pop_es = mod_es,                   n = 50,                   R = 2000,                   ci_type = \"mc\",                   test_fun = test_indirect_effect,                   test_args = list(x = \"x\",                                    m = \"m\",                                    y = \"y\",                                    mc_ci = TRUE),                   iseed = 2345,                   parallel = TRUE) print(out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.500   #>   y ~                         #>     m                 0.300   #>     x                 0.100   #>  #> Variances: #>                    Population #>    .m                 0.750   #>    .y                 0.870   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> == Indirect Effect(s) == #>  #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effect(s). #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  50  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                            50 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 2000  #>  #>  #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.167 0.003 0.367 0.520 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 50  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"call-n_from_power-to-estimate-the-sample-size","dir":"Articles","previous_headings":"Mediation","what":"Call n_from_power() to Estimate the Sample Size","title":"Sample Size Given Desired Power","text":"simplified description n_from_power() works goal find sample size 95% confidence interval power just target power. , sample size upper bound 95% confidence interval power just target power. practice, rarely need precise estimate goal sample size planning. Therefore, sample size upper bound 95% confidence interval power “close enough” target power sufficient. now, bisection method used. method slow. However, experience, goal approximation, “close enough” solution, method usually sufficient. Last, bisection method may fail find solution know form function simulation used. However, simple method usually good enough finding approximation. function call: argument used : target_power: target power. Default .80. final_nrep: number replications desired solution, using normal approximation form 95% confidence interval sample proportion (power case). nrep = 400, 95% confidence limits power .80 .04 .80. precise enough estimating sample size required. higher precision desired computation power available, number can increased , say, 500 1000. : goal find sample size upper bound confidence interval power close enough target power, set \"ub\". seed: make search reproducible, possible, set seed integer. goal: get “close enough” solution, set goal \"close_enough\" (goal = \"close_enough\"). However, goal lower upper bounds (= \"ub\" = \"lb\") \"close_enough\", argument can omitted. default, “close enough” defined “within .02 target power”. (can controlled argument tolerance).","code":"out_n <- n_from_power(out,                       target_power = .80,                       final_nrep = 400,                       what = \"ub\",                       seed = 4567)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"examine-the-output","dir":"Articles","previous_headings":"Mediation","what":"Examine the Output","title":"Sample Size Given Desired Power","text":"example needs attempts arrive approximation. basic output: estimated sample size 91. estimated power based simulation 0.748, confidence interval equal [0.705, 0.790]. upper bound, 0.790, .02 within target power (.80). words, 400 replications, estimated sample sizes less 91 power significantly less .80 used target power .80. obtain detailed results search, can use summary() method: also reports major technical information regarding search, range sample sizes tried, time spent, table sample sizes examined, along estimated power levels confidence intervals. also prints model, “power curve”, used estimate relation power sample size. Note crude model intended values sample size examined (5 example). intended estimate power sample sizes outside range studied. Even though model crude one, can still give rough idea relation. simple plot can requested plot(): Power Curve black line plot sample sizes studied, along estimated power levels 95% confidence intervals. intervals may vary width numbers replications sample sizes examined. red line plot based model (logistic model case), along range sample sizes examined. area left solution region power estimated significantly less target power.","code":"out_n #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"ub\", goal = \"close_enough\", final_nrep = 400, seed = 4567) #>  #>                           Setting #> Predictor(x):         Sample Size #> Parameter:                    N/A #> goal:                close_enough #> what:                          ub #> algorithm:              bisection #> Level of confidence:       95.00% #> Target Power:               0.800 #>  #> - Final Value of Sample Size (n): 91 #>  #> - Final Estimated Power (CI): 0.748 [0.705, 0.790] #>  #> Call `summary()` for detailed results. summary(out_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"ub\", goal = \"close_enough\", final_nrep = 400, seed = 4567) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated upper confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 91 #>  #> - Final Estimated Power: 0.748  #> - Confidence Interval: [0.705; 0.790] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 105 to 91  #> - Time spent in the search: 1.548 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.07476      0.02389   #>  #> Degrees of Freedom: 1649 Total (i.e. Null);  1648 Residual #> Null Deviance:       1759  #> Residual Deviance: 1686  AIC: 1690 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.167 1.000  0.520  0.382  0.658 #> 2  77 0.147 1.000  0.685  0.639  0.731 #> 3  91 0.145 1.000  0.748  0.705  0.790 #> 4 105 0.153 1.000  0.810  0.772  0.848 #> 5 133 0.152 1.000  0.890  0.859  0.921 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. plot(out_n)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"case-2","dir":"Articles","previous_headings":"Mediation","what":"Case 2","title":"Sample Size Given Desired Power","text":"Let’s consider Case 2, finding sample size 95% confidence interval power approximately target power. , lower bound confidence interval close enough target power. function call: change , set \"lb\" (lower bound). example needs attempts arrive approximation. output: estimated sample size 114. estimated power based simulation 0.845, confidence interval equal [0.810, 0.790]. upper bound, 0.810, .02 within target power (.80). 400 replications, estimated sample sizes greater 114 power significantly greater .80 can used target power .80. summary results: plot search: Power Curve","code":"out_n_lb <- n_from_power(out,                          target_power = .80,                          final_nrep = 400,                          what = \"lb\",                          seed = 2345) out_n_lb #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"lb\", goal = \"close_enough\", final_nrep = 400, seed = 2345) #>  #>                           Setting #> Predictor(x):         Sample Size #> Parameter:                    N/A #> goal:                close_enough #> what:                          lb #> algorithm:              bisection #> Level of confidence:       95.00% #> Target Power:               0.800 #>  #> - Final Value of Sample Size (n): 114 #>  #> - Final Estimated Power (CI): 0.845 [0.810, 0.880] #>  #> Call `summary()` for detailed results. summary(out_n_lb) #>  #> ====== x_from_power Results ====== #>  #> Call: #> power4mome::x_from_power(object = out, x = \"n\", target_power = 0.8,  #>     what = \"lb\", goal = \"close_enough\", final_nrep = 400, seed = 2345) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with estimated lower confidence bound close enough to #>   the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 114 #>  #> - Final Estimated Power: 0.845  #> - Confidence Interval: [0.810; 0.880] #> - Level of confidence: 95.0% #> - Based on 400 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - Tolerance for 'close enough': Within 0.02000 of 0.800  #> - The range of values explored: 109 to 98  #> - Time spent in the search: 2.289 mins  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.10411      0.02393   #>  #> Degrees of Freedom: 2449 Total (i.e. Null);  2448 Residual #> Null Deviance:       2381  #> Residual Deviance: 2254  AIC: 2258 #>  #> - Detailed Results: #>  #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1  50 0.167 1.000  0.520  0.382  0.658 #> 2  77 0.151 1.000  0.672  0.627  0.718 #> 3  98 0.147 1.000  0.775  0.734  0.816 #> 4 109 0.151 1.000  0.815  0.777  0.853 #> 5 114 0.151 1.000  0.845  0.810  0.880 #> 6 119 0.149 1.000  0.855  0.820  0.890 #> 7 161 0.150 1.000  0.935  0.911  0.959 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. plot(out_n_lb)"},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"case-1-case-2-or-both","dir":"Articles","previous_headings":"","what":"Case 1, Case 2, or Both?","title":"Sample Size Given Desired Power","text":"Similar Johnson-Neyman method moderation, two sample sizes found can used together estimate range sample sizes power significantly different form target power. , results , can conclude , 400 replications, sample sizes 91 114 power levels significantly different .80. However, believe researchers rarely need find “” sample exactly “” target power sample size planning. Therefore, resource concern important sample size power low, Case 1 sufficient know range sample sizes definitely used. sufficient power important associated resource available, Case 2 appropriate can find minimum sample size power significantly higher target power.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html","id":"advanced-features","dir":"Articles","previous_headings":"","what":"Advanced Features","title":"Sample Size Given Desired Power","text":"brief illustration covers basic features n_from_power(). ways customize search, range sample sizes examine, level confidence confidence interval, number trials (10 default). Please refer help page x_from_power(), n_from_power() calls, options.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Workflow of 'x_from_power()' Using the 'power_curve' Algorithm","text":"technical appendix describes workflow x_from_power() power4mome using \"power_curve\" algorithm.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"x_from_power","dir":"Articles","previous_headings":"","what":"x_from_power()","title":"Workflow of 'x_from_power()' Using the 'power_curve' Algorithm","text":"following workflow x_from_power(), algorithm \"power_curve\" used. Simulation done value x, can slow Monte Carlo bootstrapping confidence intervals involved test. feasible, also necessary, accurately estimate levels power along many values across range x, goal find value x target power. Therefore, steps taken balance speed precision finding solution. Power x (Sample Size Effect Size [Parameter Value]) x_from_power, x can sample size (n) population value (es, “effect size”) selected model parameter.","code":""},{"path":"https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html","id":"annotation","dir":"Articles","previous_headings":"","what":"Annotation","title":"Workflow of 'x_from_power()' Using the 'power_curve' Algorithm","text":"by_x_1 collection values tried results. updated whenever new value(s) /tried. fit_1 latest power curve estimated power_curve, using values tried, stored by_x_1. updated whenever by_x_1 updated. x_j value(s) power levels estimated trial. nrep_j number replications used estimate power level value x. trial, numbers replications can different different values, efficiency. by_x_j results power4test_by_n() power4test_by_es() given x_j trial. x_out value x candidate solution (e.g., estimated power closest target value). power_out, nrep_out, ci_out, by_x_out Results based x_out. ci_hit Logical. Set TRUE least one value x confidence interval estimated power including target power. final_nrep desired number replications solution. value determines desired level precision (width confidence interval) solution. sequences values nrep, R, number x trial. initial number replications (nrep) can smaller final_nrep, initial trials, though lower precision (wider confidence intervals), faster run. solution likely found (values x estimated power close target value found), nrep increased successively final_nrep, trial slower run higher precision. values affect speed, number values x (xs_per_trial) number iterations (R) Monte Carlo confidence intervals bootstrapping, also increased successively. x_final value x solution (e.g., estimated power closest target value), found. power_final, nrep_final, ci_final, by_x_final Results based x_final. Main functions used power4test_by_n() power4test_by_es(), estimating power levels set values x. power_curve(), estimating relation power value x, based values x examined. internal function estimate_x_range(), determining value(s) x examined trial, given value(s) examined far tentative power curve.","code":""},{"path":"https://sfcheung.github.io/power4mome/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Shu Fai Cheung. Author, maintainer. Sing-Hang Cheung. Author. Wendie Yang. Author.","code":""},{"path":"https://sfcheung.github.io/power4mome/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cheung S, Cheung S, Yang W (2025). power4mome: Power Analysis Moderation Mediation. R package version 0.0.1.85, https://sfcheung.github.io/power4mome/.","code":"@Manual{,   title = {power4mome: Power Analysis for Moderation and Mediation},   author = {Shu Fai Cheung and Sing-Hang Cheung and Wendie Yang},   year = {2025},   note = {R package version 0.0.1.85},   url = {https://sfcheung.github.io/power4mome/}, }"},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"power4mome-","dir":"","previous_headings":"","what":"Power Analysis for Moderation and Mediation","title":"Power Analysis for Moderation and Mediation","text":"package power analysis sample size determination moderation, mediation, moderated-mediation. includes functions power analysis sample size determination moderation, mediation, moderated-mediation effects models fitted structural equation modeling (SEM) multiple linear regression. SEM, latent variable models path models observed variables supported. information package, please visit GitHub page: https://sfcheung.github.io/power4mome/ get-started guide illustrates use package: https://sfcheung.github.io/power4mome/articles/power4mome.html","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"philosophy","dir":"","previous_headings":"","what":"Philosophy","title":"Power Analysis for Moderation and Mediation","text":"package developed philosophy: Easy specify population models, even latent variables. manually-set numbers possible specifying population models, convenient default values. restrictions possible form models, even models latent factors. automatic possible finding sample size target power. achieve comes costs, goals conflict goals: flexible usually means less user-friendly, easy specify model usually means supporting models. Therefore, also try balance goals, allow functions used different ways, accommodate scenarios prioritize goals differently.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Power Analysis for Moderation and Mediation","text":"latest developmental version package can installed remotes::install_github:","code":"remotes::install_github(\"sfcheung/power4mome\")"},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"background","dir":"","previous_headings":"","what":"Background","title":"Power Analysis for Moderation and Mediation","text":"us developers developed package manymome (Cheung & Cheung, 2024) computing testing effects models mediation, mediation, moderated-mediation. tests usually done simulation-based methods Monte Carlo bootstrap confidence intervals, due complicated sampling distributions effects. Therefore, simple ways determine power test analytically accurately. computation becomes complicated latent variables involved, necessitating simulation-based method estimate sample size. already many excellent packages estimating power structural equation modeling general, also specifically mediation moderated-mediation. intended replace reinvent wheel. just want tool meet needs: leverages flexibility manymome testing indirect effect conditional effect little limitations model. allows users (us collaborators) specify population model easy (quickly) typical power analysis programs. know power estimation simulation, necessary. However, time concern like tool , though specifically designed mediation, moderation, moderated-mediation mind may limited scope (though “big” scope), easy daily use estimating power. , power4mome, developed users, believe also useful others need power analysis mediation, moderation, moderated-mediation.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"not-just-that-","dir":"","previous_headings":"","what":"Not Just That …","title":"Power Analysis for Moderation and Mediation","text":"power4mome just mediation, moderation, moderated-mediation. avoided hardcoding functions just effects, left room testing effects, hinted examples help pages. may introduced later. now, supporting effects can tested manymome priority.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Power Analysis for Moderation and Mediation","text":"suggestions found bugs, please feel feel open GitHub issue: https://github.com/sfcheung/power4mome/issues Thanks.","code":""},{"path":"https://sfcheung.github.io/power4mome/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"Power Analysis for Moderation and Mediation","text":"Cheung, S. F., & Cheung, S.-H. (2024). manymome: R package computing indirect effects, conditional effects, conditional indirect effects, standardized unstandardized, bootstrap confidence intervals, many (though ) models. Behavior Research Methods, 56(5), 4862–4882. https://doi.org/10.3758/s13428-023-02224-z","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Do a Test on Each Replication — do_test","title":"Do a Test on Each Replication — do_test","text":"test replication output sim_out().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do a Test on Each Replication — do_test","text":"","code":"do_test(   sim_all,   test_fun,   test_args = list(),   map_names = c(fit = \"fit\"),   results_fun = NULL,   results_args = list(),   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )"},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do a Test on Each Replication — do_test","text":"sim_all output sim_out(). test_fun function test. See 'Details' requirement function. built-test functions power4mome, described 'Details'. test_args list arguments passed test_fun function. Default list(). map_names named character vector specifying content element extra replication sim_all map argument test_fun. Default c(fit = \"fit\"), indicating element fit element extra set argument fit test_fun. , first replication, fit = sim_out[[1]]$extra$fit calling test_fun. results_fun function used extract test results. See Details requirements function. Default NULL, assuming output test_fun can used directly. results_args list arguments passed results_fun function. Default list(). parallel TRUE, parallel processing used tests. Default FALSE. progress TRUE, progress tests displayed. Default `FALSE. ncores number CPU cores use parallel processing used.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do a Test on Each Replication — do_test","text":"object class test_out, list length equal sim_all, one element replication. element list two elements: test: output function set test_fun. test_results: output function set results_fun.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Do a Test on Each Replication — do_test","text":"arbitrary test replication using function set test_fun.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-role-of-do-test-","dir":"Reference","previous_headings":"","what":"The role of do_test()","title":"Do a Test on Each Replication — do_test","text":"function do_test() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-test-function-test-fun-","dir":"Reference","previous_headings":"","what":"The test function (test_fun)","title":"Do a Test on Each Replication — do_test","text":"function set test_fun, test function, usually work output lavaan::sem(), lmhelprs::many_lm(), stats::lm(), can also function works output function set fit_function calling fit_model() power4test() (see fit_model_args). function two default requirements. First, argument fit, set output lavaan::sem() another output stored element extra$fit replication sim_all object. (requirement can relaxed; see section map_names.) , function definition : FUN(fit, ...). form test_* functions power4mome. arguments passed test function, can set test_args named list. Second, test function must returns output () can processed results function (see ), (b) required format output results function (see next section). already returns output required format, need set results function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-results-function-results-fun-","dir":"Reference","previous_headings":"","what":"The results function (results_fun)","title":"Do a Test on Each Replication — do_test","text":"test results extracted output test_fun function set results_fun, results function. test_fun already returns output expected format (see ), set results_fun NULL, default. output test_fun used estimating power. function set results_fun must accept output test_fun, first argument, return named list (can data frame) named vector following elements: est: Optional. estimate parameter, applicable. se: Optional. standard error estimate, applicable. cilo: Optional. lower limit confidence interval, applicable. cihi: Optional. upper limit confidence interval, applicable. sig: Required. 1, test significant. 0, test significant. test done reason, NA. results can used estimate power Type error test. example, null hypothesis false, proportion significant, , mean values sig across replications, power.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"built-in-test-functions","dir":"Reference","previous_headings":"","what":"Built-in test functions","title":"Do a Test on Each Replication — do_test","text":"package power4mome ready--use test functions: test_indirect_effect() test_cond_indirect() test_cond_indirect_effects() test_moderation() test_index_of_mome() test_parameters() Please refer help pages examples.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-argument-map-names","dir":"Reference","previous_headings":"","what":"The argument map_names","title":"Do a Test on Each Replication — do_test","text":"argument developers using test function different name argument fit object (\"fit\", default). test_fun set function works output , say, lavaan::sem() argument name output fit, mapping can changed map_names. example, lavaan::parameterEstimates() receives output lavaan::sem() reports test results model parameters. However, argument name lavaan output object. instruct do_test() test correctly setting test_fun lavaan::parameterEstimates, add map_names = c(object = \"fit\"). element fit replication set argument object lavaan::parameterEstimates().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"the-background-for-having-the-results-fun-argument","dir":"Reference","previous_headings":"","what":"The background for having the results_fun argument","title":"Do a Test on Each Replication — do_test","text":"early development power4mome, test_fun designed accept existing functions packages, manymome::indirect_effect(). outputs required format power analysis, results functions needed process outputs. current version power4mome, ready--use test functions, usually wrappers existing functions packages, developed, longer need results functions process output. argument results_fun kept backward compatibility advanced users use test functions packages.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/do_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do a Test on Each Replication — do_test","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate Monte Carlo estimates for forming Monte Carlo confidence intervals  mc_all <- gen_mc(fit_all,                  R = 50,                  iseed = 4567)  # Combine the results to a 'sim_all' object sim_all <- sim_out(data_all = data_all,                    fit = fit_all,                    mc_out = mc_all)  # Test the indirect effect in each replication test_all <- do_test(sim_all,                     test_fun = test_indirect_effect,                     test_args = list(x = \"x\",                                      m = \"m\",                                      y = \"y\",                                      mc_ci = TRUE),                     parallel = FALSE,                     progress = FALSE)  # The results lapply(test_all, function(x) x$test_results) #> [[1]] #>        est       cilo       cihi        sig  #> 0.10147276 0.02144103 0.18035550 1.00000000  #>  #> [[2]] #>          est         cilo         cihi          sig  #>  0.079776696 -0.002117072  0.194482289  0.000000000  #>  #> [[3]] #>          est         cilo         cihi          sig  #>  0.052746533 -0.001695808  0.117672020  0.000000000  #>  #> [[4]] #>        est       cilo       cihi        sig  #> 0.10461042 0.02975369 0.23184723 1.00000000  #>  #> [[5]] #>         est        cilo        cihi         sig  #> 0.116902305 0.003271956 0.251780798 1.000000000  #>"},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Model to a List of Datasets — fit_model","title":"Fit a Model to a List of Datasets — fit_model","text":"Get output sim_data() fit model stored datasets.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Model to a List of Datasets — fit_model","text":"","code":"fit_model(   data_all = NULL,   model = NULL,   fit_function = \"lavaan\",   arg_data_name = \"data\",   arg_model_name = \"model\",   arg_group_name = \"group\",   ...,   fit_out = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )"},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Model to a List of Datasets — fit_model","text":"data_all output sim_data(), sim_data class object. model model fitted. NULL, default, model stored data_all, data generation model, used. fit_function function used fit model. Can also string: \"lavaan\" (default) lavaan::sem(), \"lm\" many_lm lmhelprs::many_lm(). functions can also used necessary. arg_data_name name argument fit_function expecting dataset. Default \"data\". arg_model_name name argument fit_function expecting model definition. Default \"model\". arg_group_name name argument fit_function expecting name group variable. Used multigroup models. Default \"group\". ... Optional arguments passed fit_function fitting model. fit_out set fit_out object (output fit_model()), missing arguments retrieved fit_out. , users can use fit_model(data_all = new_data, fit_out = old_out) re-fit model originally fitted old_out new list dataset (new_data). need include arguments. parallel TRUE, parallel processing used fit models. Default FALSE. progress TRUE, progress model fitting displayed. Default `FALSE. ncores number CPU cores use parallel processing used.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Model to a List of Datasets — fit_model","text":"object class fit_out, list output fit_function (lavaan::sem() default). error occurred fitting model dataset, element error message fit function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a Model to a List of Datasets — fit_model","text":"default, extracts model stored output sim_data(), fits model dataset simulated using fit_function, default \"lavaan\" lavaan::sem() called, returns results. datasets generated multigroup model calling sim_data(), multigroup model fitted.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"the-role-of-fit-model-","dir":"Reference","previous_headings":"","what":"The role of fit_model()","title":"Fit a Model to a List of Datasets — fit_model","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize model fitting step power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/fit_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Model to a List of Datasets — fit_model","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all) fit_all[[1]] #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0  # Fit the population model using the MLR estimator  fit_all_mlr <- fit_model(data_all,                          estimator = \"MLR\") fit_all_mlr[[1]] #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                               Standard      Scaled #>   Test Statistic                                 0.000       0.000 #>   Degrees of freedom                                 0           0  # Fit a model different from the population model, # with the MLR estimator  mod2 <- \"m ~ x  y ~ m\"  fit_all_mlr2 <- fit_model(data_all,                           mod2,                           estimator = \"MLR\") fit_all_mlr2[[1]] #> lavaan 0.6-19 ended normally after 2 iterations #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         4 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                               Standard      Scaled #>   Test Statistic                                 0.975       1.128 #>   Degrees of freedom                                 1           1 #>   P-value (Chi-square)                           0.323       0.288 #>   Scaling correction factor                                  0.864 #>     Yuan-Bentler correction (Mplus variant)"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Bootstrap Estimates — gen_boot","title":"Generate Bootstrap Estimates — gen_boot","text":"Get list output lavaan::sem() lmhelprs::many_lm() generate bootstrap estimates model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Bootstrap Estimates — gen_boot","text":"","code":"gen_boot(   fit_all,   R = 100,   ...,   iseed = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   compute_implied_stats = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Bootstrap Estimates — gen_boot","text":"fit_all output fit_model() object class fit_out. R number replications generate bootstrap estimates fit output. ... Optional arguments passed manymome::do_boot() generating bootstrap estimates. iseed seed random number generator. Default NULL seed changed. parallel TRUE, parallel processing used generate bootstrap estimates fit outputs. Default FALSE. progress TRUE, progress displayed. Default `FALSE. ncores number CPU cores use parallel processing used. compute_implied_stats Whether implied statistics computed bootstrap samples. Usually needed default FALSE","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Bootstrap Estimates — gen_boot","text":"boot_list object, list output manymome::do_boot().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Bootstrap Estimates — gen_boot","text":"simply calls manymome::do_boot() output lavaan::sem() lmhelprs::many_lm() fit_all. simulated estimates can used test effects indirect effects, usually functions manymome package, manymome::indirect_effect().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"the-role-of-gen-boot-","dir":"Reference","previous_headings":"","what":"The role of gen_boot()","title":"Generate Bootstrap Estimates — gen_boot","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize workflow power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/gen_boot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Bootstrap Estimates — gen_boot","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 2,                      model = mod,                      pop_es = es,                      n = 50,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate bootstrap estimates for each replication  boot_all <- gen_boot(fit_all,                      R = 10,                      iseed = 4567) boot_all #> [[1]] #>  #> == A 'boot_out' class object == #>  #> Number of bootstrap samples: 10  #>  #>  #> [[2]] #>  #> == A 'boot_out' class object == #>  #> Number of bootstrap samples: 10  #>  #>  #> attr(,\"class\") #> [1] \"boot_list\" \"list\""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Monte Carlo Estimates — gen_mc","title":"Generate Monte Carlo Estimates — gen_mc","text":"Get list output lavaan::sem() generate Monte Carlo estimates model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Monte Carlo Estimates — gen_mc","text":"","code":"gen_mc(   fit_all,   R = 100,   ...,   iseed = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   compute_implied_stats = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Monte Carlo Estimates — gen_mc","text":"fit_all output fit_model() object class fit_out. R number replications generate Monte Carlo estimates fit output. ... Optional arguments passed manymome::do_mc() generating Monte Carlo estimates. iseed seed random number generator. Default NULL seed changed. parallel TRUE, parallel processing used generate Monte Carlo estimates fit outputs. Default FALSE. progress TRUE, progress displayed. Default `FALSE. ncores number CPU cores use parallel processing used. compute_implied_stats Whether implied statistics computed Monte Carlo replication. Usually needed default FALSE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Monte Carlo Estimates — gen_mc","text":"mc_list object, list output manymome::do_mc().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Monte Carlo Estimates — gen_mc","text":"simply calls manymome::do_mc() output lavaan::sem() fit_all. simulated estimates can used test effects indirect effects, usually functions manymome package, manymome::indirect_effect().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"the-role-of-gen-mc-","dir":"Reference","previous_headings":"","what":"The role of gen_mc()","title":"Generate Monte Carlo Estimates — gen_mc","text":"function used --one function power4test(). Users usually call function directly, though developers can use function customize workflow power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/gen_mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Monte Carlo Estimates — gen_mc","text":"","code":"# Specify the population model  mod <- \"m ~ x  y ~ m + x\"  # Specify the effect sizes (population parameter values)  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate several simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  # Fit the population model to each datasets  fit_all <- fit_model(data_all)  # Generate Monte Carlo estimates for each replication  mc_all <- gen_mc(fit_all,                  R = 100,                  iseed = 4567)  mc_all #> [[1]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[2]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[3]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[4]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> [[5]] #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> attr(,\"class\") #> [1] \"mc_list\" \"list\""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Power Curve — plot.power_curve","title":"Plot a Power Curve — plot.power_curve","text":"Plotting results 'power_curve' object, estimated power sample size, results power4test_by_n() power4test_by_es().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Power Curve — plot.power_curve","text":"","code":"# S3 method for class 'power_curve' plot(   x,   what = c(\"ci\", \"power_curve\"),   main = paste0(\"Power Curve \", \"(Predictor: \", switch(x$predictor, n = \"Sample Size\", es     = \"Effect Size\"), \")\"),   xlab = switch(x$predictor, n = \"Sample Size\", es = \"Effect Size\"),   ylab = \"Estimated Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )  # S3 method for class 'power4test_by_n' plot(   x,   main = \"Estimated Power vs. Sample Size\",   xlab = \"Sample Size\",   ylab = \"Estimated Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )  # S3 method for class 'power4test_by_n' plot(   x,   main = \"Estimated Power vs. Sample Size\",   xlab = \"Sample Size\",   ylab = \"Estimated Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )  # S3 method for class 'power4test_by_es' plot(   x,   main = paste0(\"Estimated Power vs. Effect Size / Parameter (\", attr(x[[1]],     \"pop_es_name\"), \")\"),   xlab = paste0(\"Effect Size / Parameter (\", attr(x[[1]], \"pop_es_name\"), \")\"),   ylab = \"Estiamted Power\",   pars_ci = list(),   type = \"l\",   ylim = c(0, 1),   ci_level = 0.95,   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Power Curve — plot.power_curve","text":"x object plotted. can power_curve object, output power_curve(). can also output power4test_by_n() power4test_by_es(). character vector include plot. Possible values \"ci\" (confidence intervals estimated sample size) \"power_curve\" (crude power curve, available). default values depend type x. main title plot. xlab, ylab labels horizontal vertical axes, respectively. pars_ci named list arguments passed arrows() customize drawing confidence intervals. type argument default plot method plot.default(). Default \"l\". See plot.default() options. ylim two-element numeric vector range vertical axis. ci_level level confidence confidence intervals, requested. Default .95, denoting 95%. ... Optional arguments. Passed plot() drawing base plot.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Power Curve — plot.power_curve","text":"plot-methods return x invisibly. called side effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a Power Curve — plot.power_curve","text":"currently plots relation estimated power predictor. elements can requested (see argument ), can customized individually.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/plot.power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a Power Curve — plot.power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 100, 200, 1000),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.550280     0.004213   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    54.55  #> Residual Deviance: 38.37 \tAIC: 42.37 plot(pout1)   # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = seq(0, .7, .15),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) plot(pout2)"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot The Results of 'x_from_power' — plot.x_from_power","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"plots results 'x_from_power', estimated power sample size.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"","code":"# S3 method for class 'x_from_power' plot(   x,   what = c(\"ci\", \"power_curve\", \"final_x\", \"final_power\", \"target_power\", switch(x$x, n =     \"sig_area\", es = NULL)),   text_what = c(\"final_x\", \"final_power\", switch(x$x, n = \"sig_area\", es = NULL)),   digits = 3,   main = paste0(\"Power Curve \", \"(Target Power: \", formatC(x$target_power, digits =     digits, format = \"f\"), \")\"),   xlab = NULL,   ylab = \"Estimated Power\",   ci_level = 0.95,   pars_ci = list(),   pars_power_curve = list(),   pars_ci_final_x = list(lwd = 2, length = 0.2, col = \"blue\"),   pars_target_power = list(lty = \"dashed\", lwd = 2, col = \"black\"),   pars_final_x = list(lty = \"dotted\"),   pars_final_power = list(lty = \"dotted\", col = \"blue\"),   pars_text_final_x = list(y = 0, pos = 3, cex = 1),   pars_text_final_power = list(pos = 3, cex = 1),   pars_sig_area = list(col = adjustcolor(\"lightblue\", alpha.f = 0.1)),   pars_text_sig_area = list(cex = 1),   ... )  # S3 method for class 'n_region_from_power' plot(   x,   what = c(\"ci\", \"power_curve\", \"final_x\", \"final_power\", \"target_power\", \"sig_area\"),   text_what = c(\"final_x\", \"final_power\", \"sig_area\"),   digits = 3,   main = paste0(\"Power Curve \", \"(Target Power: \", formatC(x$below$target_power, digits =     digits, format = \"f\"), \")\"),   xlab = NULL,   ylab = \"Estimated Power\",   ci_level = 0.95,   pars_ci = list(),   pars_power_curve = list(),   pars_ci_final_x = list(lwd = 2, length = 0.2, col = \"blue\"),   pars_target_power = list(lty = \"dashed\", lwd = 2, col = \"black\"),   pars_final_x = list(lty = \"dotted\"),   pars_final_power = list(lty = \"dotted\", col = \"blue\"),   pars_text_final_x = list(y = 0, pos = 3, cex = 1),   pars_text_final_power = list(pos = 3, cex = 1),   pars_sig_area = list(col = adjustcolor(\"lightblue\", alpha.f = 0.1)),   pars_text_sig_area = list(cex = 1),   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"x x_from_power object, output x_from_power(). character vector include plot. Possible values \"ci\" (confidence intervals estimated value predictor), \"power_curve\" (crude power curve, available), \"final_x\" (vertical line value predictor estimated power close enough target power confidence interval), \"final_power\" (horizontal line estimated power final value predictor), \"target_power\" (horizontal line target power), \"sig_area\" (area significantly higher lower target power, goal \"close_enough\" \"lb\" \"ub\"). default, elements plotted. text_what character vector numbers added labels. Possible values \"final_x\" (value predictor estimated power close enough target power confidence interval) \"final_power\" (estimated power final value predictor), \"sig_area\" (labeling area significantly higher lower target power, goal \"close_enough\" \"lb\" \"ub\"). default, labels added. digits number digits decimal used adding numbers. main title plot. xlab, ylab labels horizontal vertical axes, respectively. ci_level level confidence confidence intervals, requested. Default .95, denoting 95%. pars_ci named list arguments passed arrows() customize drawing confidence intervals. pars_power_curve named list arguments passed points() customize drawing power curve. pars_ci_final_x named list arguments passed arrows() customize drawing confidence interval final value predictor. pars_target_power named list arguments passed abline() drawing horizontal line target power. pars_final_x named list arguments passed abline() drawing vertical line final value predictor. pars_final_power named list arguments passed abline() drawing horizontal line estimated power final value predictor. pars_text_final_x named list arguments passed text() adding label final value predictor. pars_text_final_power named list arguments passed text() adding label estimated power final value predictor. pars_sig_area named list arguments passed rect() shading area significantly higher lower target power. pars_text_sig_area named list arguments passed text() labelling area significantly higher lower target power. ... Optional arguments. Passed plot() drawing estimated power predictor.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"plot-method x_from_power returns x invisibly. called side effect. plot-method n_region_from_power returns x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"currently plots relation estimated power values examined x_from_power(). elements can requested (see argument ), can customized individually. plot-method n_region_from_power objects modified version plot-method x_from_power. plots results two runs n_from_power() one plot. otherwise similar plot-method x_from_power.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/plot.x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot The Results of 'x_from_power' — plot.x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 10,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 10,                            max_trials = 1,                            seed = 2345) #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  ci_hit  #> What:  point   (Estimated Power)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [100, 125]  #>  #>  #> Do the simulation for the upper bound: #>  #> Try x = 125  #>  #> Updating the simulation for sample size: 125  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 0.900, 95.0% confidence interval: [0.714,1.086] #>  #> Initial interval: [100, 125]  #>  #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.320 1.000  0.800  0.552  1.048 #> 2 125 0.314 1.000  0.900  0.714  1.086 #>  #> One of the bounds in the interval is already a solution. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2025-07-16 13:31:30  #> - Rejection Rates: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.320 1.000  0.800  0.552  1.048 #> 2 125 0.314 1.000  0.900  0.714  1.086 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -1.85743      0.03244   #>  #> Degrees of Freedom: 19 Total (i.e. Null);  18 Residual #> Null Deviance:\t    16.91  #> Residual Deviance: 16.51 \tAIC: 20.51 #>  #>  #> - Final Value: 100  #>  #> - Final Estimated Power: 0.8000  #> - Confidence Interval: [0.5521; 1.0479] #> - CI Level: 95.00% plot(power_vs_n)"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Convert YAML string vector list pop_es specification.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"","code":"pop_es_yaml(text)"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"text multiline string parsed specification population values.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Either named vector (single-group model) list named vector (multigroup model).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"allows users specify population values model using one single string, 'lavaan' model syntax.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/pop_es_yaml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse YAML-Stye Values For 'pop_es' — pop_es_yaml","text":"","code":"mod_es <- c(\"y ~ m\" = \"l\",             \"m ~ x\" = \"m\",             \"y ~ x\" = \"nil\")  mod_es_yaml <- \" y ~ m: l m ~ x: m y ~ x: nil \"  pop_es_yaml(mod_es_yaml) #> y ~ m m ~ x y ~ x  #>   \"l\"   \"m\" \"nil\""},{"path":"https://sfcheung.github.io/power4mome/reference/power4mome-package.html","id":null,"dir":"Reference","previous_headings":"","what":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","title":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","text":"Power analysis sample size determination moderation, mediation, moderated mediation models fitted structural equation modeling.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4mome-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"power4mome: Power Analysis for Moderation and Mediation — power4mome-package","text":"Maintainer: Shu Fai Cheung shufai.cheung@gmail.com (ORCID) Authors: Sing-Hang Cheung (ORCID) Wendie Yang (ORCID)","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the Power of a Test — power4test","title":"Estimate the Power of a Test — power4test","text":"--one function receives model specification, generates datasets, fits model, target test, returns test results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the Power of a Test — power4test","text":"","code":"power4test(   object = NULL,   nrep = NULL,   ptable = NULL,   model = NULL,   pop_es = NULL,   standardized = TRUE,   n = NULL,   number_of_indicators = NULL,   reliability = NULL,   x_fun = list(),   e_fun = list(),   process_data = NULL,   fit_model_args = list(),   R = NULL,   ci_type = \"mc\",   gen_mc_args = list(),   gen_boot_args = list(),   test_fun = NULL,   test_args = list(),   map_names = c(fit = \"fit\"),   results_fun = NULL,   results_args = list(),   test_name = NULL,   test_note = NULL,   do_the_test = TRUE,   sim_all = NULL,   iseed = NULL,   parallel = FALSE,   progress = TRUE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1),   es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5, si = 0.141, mi = 0.361, li = 0.51),   es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15),   es_ind = c(\"si\", \"mi\", \"li\"),   n_std = 1e+05,   std_force_monte_carlo = FALSE )  # S3 method for class 'power4test' print(   x,   what = c(\"data\", \"test\"),   digits = 3,   digits_descriptive = 2,   data_long = FALSE,   test_long = FALSE,   fit_to_all_args = list(),   ... )"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the Power of a Test — power4test","text":"object Optional. set power4test object, updated using value(s) n, pop_es, /nrep changed, new test conducted added objet. See help page details. Default NULL. nrep number replications generate simulated datasets. Default NULL. Must set called create power4test object. ptable output ptable_pop(), ptable_pop object, representing population model. NULL, default, ptable_pop() called generate ptable_pop object using model pop_es. model lavaan model syntax population model, used ptable_pop(). See 'Details' specify model. Ignored ptable specified. pop_es character vector multiline string specify population effect sizes (population values parameters). See help page specify argument. Ignored ptable specified. standardized Logical. TRUE, default, variances error variances scaled ensure population variances endogenous variables close one, hence effect sizes (population values) standardized effect sizes variances continuous exogenous variables also equal one. n sample size dataset. Default 100. number_of_indicators named vector specify number indicators factors. See help page set argument. Default NULL variables model syntax observed variables. See help page use argument. reliability named vector (single-group model) named list named vectors (multigroup model) set reliability coefficient set indicators. Default NULL. See help page use argument. x_fun function(s) used generate exogenous variables error terms. supplied, set list(), default, variables generated multivariate normal distribution. See help page use argument. e_fun function(s) used generate error terms indicators, . supplied, set list(), default, error terms indicators generated multivariate normal distribution. Specify way x_fun. Refer help page x_fun use argument. process_data NULL, must named list elements: fun (required), function processing simulated data, generating missing data using functions mice::ampute(); args (optional), named list arguments passed fun, except one source data; sim_data_name (required) name argument receive simulated data (e.g., data mice::ampute()); processed_data_name (optional), name data frame processed fun, data frame missing data output fun (e.g., \"amp\" mice::ampute()), omitted, output fun data frame missing data. fit_model_args list arguments passed fit_model() fitting model. named list names names arguments. R number replications generate Monte Carlo bootstrapping estimates fit output. Monte Carlo bootstrapping estimates generated R set NULL. ci_type type simulation-based confidence intervals use. Can either \"mc\" Monte Carlo method (default) \"boot\" nonparametric bootstrapping method. Relevant test functions make use estimates generate gen_boot() gen_mc(), test_indirect_effect(). gen_mc_args list arguments passed manymome::do_mc() generating Monte Carlo estimates. named argument names names arguments. Used ci_type \"mc\". gen_boot_args list arguments passed manymome::do_boot() generating bootstrap estimates. named argument names names arguments. Used ci_type `\"boot\". test_fun function test. See 'Details' requirement function. built-test functions power4mome, described 'Details'. test_args list arguments passed test_fun function. Default list(). map_names named character vector specifying content element extra replication sim_all map argument test_fun. Default c(fit = \"fit\"), indicating element fit element extra set argument fit test_fun. , first replication, fit = sim_out[[1]]$extra$fit calling test_fun. results_fun function used extract test results. See Details requirements function. Default NULL, assuming output test_fun can used directly. results_args list arguments passed results_fun function. Default list(). test_name String. name test. Default NULL, name created test_fun. Note sim_out power4test object already test name stored, replaced new results. test_note String. optional note test, stored attribute test_note output do_test(). Default NULL. do_the_test TRUE, do_test() called test specified test_fun fit output dataset. sim_all set either sim_out object (output sim_out() power4test object (output power4test()), stored datasets fit outputs used test. Setting object output power4test() now preferred method, argument kept backward compatibility. iseed seed random number generator. Default NULL seed changed. seed set , calling sim_data(). parallel TRUE, parallel processing used calling functions, appropriate. Default FALSE. progress TRUE, progress step displayed. Default FALSE. ncores number CPU cores use parallel processing used. es1 Set values label effect size (population value) correlations regression paths. Used pop_es named vector multiline string. See help page specify argument. es2 Set values label effect size (population value) product term. Used pop_es named vector multiline string. See help page specify argument. es_ind names labels denoting effect size indirect effect. used determine population values component paths along indirect path. n_std sample size used determine error variances simulation std_force_monte_carlo TRUE. std_force_monte_carlo Logical. FALSE, default, standardization done analytically model product terms, simulation model product terms. , error variances required ensure implied variances equal one determined simulation. TRUE, simulation used whether model product terms . Always fall back simulation analytical standardization failed. x object printed. string vector print, \"data\" simulated data \"test\" stored test(s). Default c(\"data\", \"test\"). digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. data_long TRUE, detailed results printed printing simulated data. test_long TRUE, detailed results printed printing test(s). fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined ... Optional arguments passed print methods","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the Power of a Test — power4test","text":"object class power4test, list two elements: sim_all: output sim_out(). test_all: named list output do_test(). names values test_name. list can one test call power4test() can add new tests power4test object. print method power4test returns x invisibly. Called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate the Power of a Test — power4test","text":"--one function estimating power test model, given sample size effect sizes (population values model parameters).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"workflow","dir":"Reference","previous_headings":"","what":"Workflow","title":"Estimate the Power of a Test — power4test","text":"workflow: object output output previous call power4test() do_the_test set FALSE model simulated data, following steps skipped go directly test. Call sim_data() determine population model generate datasets, using arguments model pop_es. Call fit_model() fit model datasets, population model default. R NULL ci_type = \"mc\", call gen_mc() generate Monte Carlo estimates using manymome::do_mc(). estimates can used supported functions test_indirect_effect(). R NULL ci_type = \"boot\", call gen_boot() generate bootstrap estimates using manymome::do_boot(). estimates can used supported functions test_indirect_effect(). Merge results sim_out object calling sim_out(). do_the_test FALSE, skip remaining steps return power4test object, contains data generated optionally Monte Carlo bootstrap estimates. do_the_test TRUE, test. do_test() called test fit output dataset. Return power4test object include output sim_out , do_the_test TRUE, output do_test(). function used users interested power one several tests particular aspect model, parameter, given specific effect sizes sample sizes. Detailed description major arguments can found sections . NOTE: technical internal workflow power4test() can found page: https://sfcheung.github.io/power4mome/articles/power4test_workflow.html.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"updating-a-condition","dir":"Reference","previous_headings":"","what":"Updating a Condition","title":"Estimate the Power of a Test — power4test","text":"function power4test() can also used update condition selected aspects changed. example, instead calling function arguments set just change sample size, can called supplying existing power4test object set n new sample size. data tests updated automatically. See examples illustration.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"adding-another-test","dir":"Reference","previous_headings":"","what":"Adding Another Test","title":"Estimate the Power of a Test — power4test","text":"function power4test() can also used add test output previous call power4test(). example, simulating datasets one test, output can set object power4test(), set test_fun , optionally, test_fun_args one test generated datasets. output original object results new test added. See examples illustration.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"model-fitting-arguments-fit-model-args-","dir":"Reference","previous_headings":"","what":"Model Fitting Arguments ('fit_model_args')","title":"Estimate the Power of a Test — power4test","text":"power analysis, usually, population model (model) fitted, need set fit_model_args. power analysis conducted fitting model population model, non-default settings desired fitting model, argument fit_model_args needed set customize call fit_model(). example, users may want examine power test misspecified model fitted, power test MLR used estimator calling lavaan::sem(). See help page fit_model() examples.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Estimate the Power of a Test — power4test","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Estimate the Power of a Test — power4test","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Estimate the Power of a Test — power4test","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Estimate the Power of a Test — power4test","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Estimate the Power of a Test — power4test","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Estimate the Power of a Test — power4test","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Estimate the Power of a Test — power4test","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"set-number-of-indicators-and-reliability-","dir":"Reference","previous_headings":"","what":"Set 'number_of_indicators' and 'reliability'","title":"Estimate the Power of a Test — power4test","text":"arguments number_of_indicators reliability used specify number indicators (e.g., items) factor, population reliability coefficient factor, variables model syntax latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"single-group-model-3","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Estimate the Power of a Test — power4test","text":"variable model replaced indicators generated data, set number_of_indicators named numeric vector. names variables variables indicators, appeared model syntax. value name number indicators. argument reliability set named numeric vector (list, see section multigroup models) specify population reliability coefficient (\"omega\") set indicators. population standardized factor loadings computed ensure population reliability coefficient target value. examples single group model: numbers indicators m, x, y 3, 4, 5, respectively. population reliability coefficients m, x, y .90, .80, .70, respectively.","code":"number of indicator = c(m = 3, x = 4, y = 5) reliability = c(m = .90, x = .80, y = .70)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"multigroup-models","dir":"Reference","previous_headings":"","what":"Multigroup Models","title":"Estimate the Power of a Test — power4test","text":"Multigroup models supported. number groups inferred pop_es (see help page ptable_pop()), directly ptable. multigroup model, number indicators variable must across groups. However, population reliability coefficients can different across groups. multigroup model k groups, one population reliability coefficients differ across groups, argument reliability set named list. names variables population reliability coefficients set. element name either single value common reliability coefficient, numeric vector reliability coefficient group. example reliability model 2 groups: reliability coefficients x .80 groups, reliability coefficients m .70 one group .80 another.","code":"reliability = list(x = .80, m = c(.70, .80))"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"equal-numbers-of-indicators-and-or-reliability-coefficients","dir":"Reference","previous_headings":"","what":"Equal Numbers of Indicators and/or Reliability Coefficients","title":"Estimate the Power of a Test — power4test","text":"variables model number indicators, number_of_indicators can set one single value. Similarly, sets indicators population reliability groups, reliability can also set one single value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"specify-the-distributions-of-exogenous-variables-or-error-terms-using-x-fun-","dir":"Reference","previous_headings":"","what":"Specify The Distributions of Exogenous Variables Or Error Terms Using 'x_fun'","title":"Estimate the Power of a Test — power4test","text":"default, variables error terms generated multivariate normal distribution. desired, users can supply function used generate exogenous variable error term setting x_fun named list. names list variables user function used generate data. element list must also list. first element list, can unnamed, function used. arguments need supplied, included named elements list. example: variables x w generated user-supplied functions. x, function power4mome::rexp_rs. additional argument calling function. w, function power4mome::rbinary_rx. argument p1 = .70 passed function generating values w. variable endogenous variable (e.g., predicted another variable model), x_fun used generate error term. implied population distribution may still different generate x_fun distribution also depends distribution variables predicting . requirements user-functions: must return numeric vector. mush argument n number values. population mean standard deviation generated values must 0 1, respectively. package power4mome helper functions generating values common nonnormal distributions scaling population mean standard deviation equal 0 1 (default), respectively. : rbinary_rs(). rexp_rs(). rbeta_rs(). rlnorm_rs(). rpgnorm_rs(). use x_fun, variables must zero covariances variables population. possible generate nonnormal multivariate data believe rarely needed estimating power data.","code":"x_fun = list(x = list(power4mome::rexp_rs),              w = list(power4mome::rbinary_rs,                       p1 = .70)))"},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-test-function-test-fun-","dir":"Reference","previous_headings":"","what":"The test function (test_fun)","title":"Estimate the Power of a Test — power4test","text":"function set test_fun, test function, usually work output lavaan::sem(), lmhelprs::many_lm(), stats::lm(), can also function works output function set fit_function calling fit_model() power4test() (see fit_model_args). function two default requirements. First, argument fit, set output lavaan::sem() another output stored element extra$fit replication sim_all object. (requirement can relaxed; see section map_names.) , function definition : FUN(fit, ...). form test_* functions power4mome. arguments passed test function, can set test_args named list. Second, test function must returns output () can processed results function (see ), (b) required format output results function (see next section). already returns output required format, need set results function.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-results-function-results-fun-","dir":"Reference","previous_headings":"","what":"The results function (results_fun)","title":"Estimate the Power of a Test — power4test","text":"test results extracted output test_fun function set results_fun, results function. test_fun already returns output expected format (see ), set results_fun NULL, default. output test_fun used estimating power. function set results_fun must accept output test_fun, first argument, return named list (can data frame) named vector following elements: est: Optional. estimate parameter, applicable. se: Optional. standard error estimate, applicable. cilo: Optional. lower limit confidence interval, applicable. cihi: Optional. upper limit confidence interval, applicable. sig: Required. 1, test significant. 0, test significant. test done reason, NA. results can used estimate power Type error test. example, null hypothesis false, proportion significant, , mean values sig across replications, power.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"built-in-test-functions","dir":"Reference","previous_headings":"","what":"Built-in test functions","title":"Estimate the Power of a Test — power4test","text":"package power4mome ready--use test functions: test_indirect_effect() test_cond_indirect() test_cond_indirect_effects() test_moderation() test_index_of_mome() test_parameters() Please refer help pages examples.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"the-argument-map-names","dir":"Reference","previous_headings":"","what":"The argument map_names","title":"Estimate the Power of a Test — power4test","text":"argument developers using test function different name argument fit object (\"fit\", default). test_fun set function works output , say, lavaan::sem() argument name output fit, mapping can changed map_names. example, lavaan::parameterEstimates() receives output lavaan::sem() reports test results model parameters. However, argument name lavaan output object. instruct do_test() test correctly setting test_fun lavaan::parameterEstimates, add map_names = c(object = \"fit\"). element fit replication set argument object lavaan::parameterEstimates().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the Power of a Test — power4test","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  out <- power4test(nrep = 50,                   model = model_simple_med,                   pop_es = model_simple_med_es,                   n = 100,                   test_fun = test_parameters,                   test_args = list(pars = \"m~x\"),                   iseed = 1234,                   parallel = FALSE,                   progress = TRUE) #> Simulate the data: #> Fit the model(s): #> Do the test: test_parameters: CIs (pars: m~x)   print(out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.307 0.095 3.247  0.040 0.121 0.494 0.860 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000   # Change the sample size  out1 <- power4test(out,                    n = 200,                    iseed = 1234,                    parallel = FALSE,                    progress = TRUE) #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) :  print(out1,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  200  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           200 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.291 0.067 4.370  0.003 0.160 0.423 0.960 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000   # Add one more test  out2 <- power4test(out,                    test_fun = test_parameters,                    test_args = list(pars = \"y~x\"),                    parallel = FALSE,                    progress = TRUE) #> Do the test: test_parameters: CIs (pars: y~x)   print(out2,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  50  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ========== <test_parameters: CIs (pars: m~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs   est    se     z pvalue  cilo  cihi   sig #> 1        m~x   m  ~   x 0.307 0.095 3.247  0.040 0.121 0.494 0.860 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000  #>  #> ========== <test_parameters: CIs (pars: y~x)> ========== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        y~x   y  ~   x -0.021 0.091 -0.224  0.441 -0.200 0.158 0.060 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 50  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":null,"dir":"Reference","previous_headings":"","what":"Power By Effect Sizes — power4test_by_es","title":"Power By Effect Sizes — power4test_by_es","text":"Estimate power set effect sizes (population values model parameter).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power By Effect Sizes — power4test_by_es","text":"","code":"power4test_by_es(   object,   pop_es_name = NULL,   pop_es_values = NULL,   progress = TRUE,   ...,   by_seed = NULL,   by_nrep = NULL,   save_sim_all = TRUE )  # S3 method for class 'power4test_by_es' c(..., sort = TRUE, skip_checking_models = FALSE)  as.power4test_by_es(original_object, pop_es_name)  # S3 method for class 'power4test_by_es' print(x, print_all = FALSE, digits = 3, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power By Effect Sizes — power4test_by_es","text":"object power4test object, power4test_by_es object. power4test_by_es object, first element, power4test object, used value argument. pop_es_name name parameter. See help page ptable_pop() names argument pop_es. pop_es_values numeric vector population values parameter specified pop_es_names. progress Logical. Whether progress simulation displayed. ... power4test_by_es(), arguments passed power4test(). c.power4test_by_es(), power4test_by_es() outputs combined together. print method output power4test_by_es(), arguments passed print method output power4test() (print.power4test()). by_seed set number, used generate seeds call power4test(). NULL, default, seeds still randomly generated results easily reproduced. by_nrep set number, used generate number replications (nrep) call power4test(). set numeric vector length pop_es_values, nrep values calls, allowing different numbers replications population values. NULL, default, original nrep used. argument used x_from_power() efficiency, rarely used calling function directly. save_sim_all FALSE, dataset power4test objects saved, reduce size output. Default TRUE. sort combining objects, whether sorted population values. Default TRUE. skip_checking_models Whether check data generation model checked. Default TRUE. set FALSE users certain based model, model saved (e.g., save_sim_all set FALSE objects generated). argument used x_from_power() efficiency, rarely used calling c method directly. original_object object converted power4test_by_es object. x object printed. print_all TRUE, elements x, , results sample sizes examined, printed. FALSE, first value parameter printed. digits numbers digits displayed decimal.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power By Effect Sizes — power4test_by_es","text":"function power4test_by_es() returns power4test_by_es object, list power4test objects, one population value parameter. method c.power4test_by_es() returns power4test_by_es object elements (tests different values pop_es_values) combined. function .power4test_by_es() returns power4test_by_es object converted input object. print-method power4test_by_es objects returns object invisibly. called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power By Effect Sizes — power4test_by_es","text":"function regenerates datasets set effect sizes (population values model parmeter) stored tests . Optionally, can also run object stored tests. case, additional arguments must set instruct power4test() tests conducted. usually used examine power sets effect sizes (population values). method c.power4test_by_es() used combine tests different runs power4test_by_es(). function .power4test_by_es() used convert power4test object power4test_by_es object, already one. Useful concatenating power4test objects power4test_by_es objects.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_es.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power By Effect Sizes — power4test_by_es","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  sim_only <- power4test(nrep = 2,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 40,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Do the test: test_indirect: x->m->y   out <- power4test_by_es(test_out,                             pop_es_name = \"y ~ m\",                             pop_es_values = c(.10, .20)) #>  #> Updating the simulation for new value: y ~ m = 0.100  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for new value: y ~ m = 0.200  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : out_reject <- rejection_rates(out) out_reject #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     par    es   est   p.v reject r.cilo r.cihi #> 1 y ~ m 0.100 0.043 1.000  0.000  0.000  0.000 #> 2 y ~ m 0.200 0.038 1.000  0.500 -0.193  1.193 #> Notes: #> - par: The parameter being varied. #> - es: The population value of 'par' in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Power By Sample Sizes — power4test_by_n","title":"Power By Sample Sizes — power4test_by_n","text":"Estimate power set sample sizes.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power By Sample Sizes — power4test_by_n","text":"","code":"power4test_by_n(   object,   n = NULL,   progress = TRUE,   ...,   by_seed = NULL,   by_nrep = NULL,   save_sim_all = TRUE )  # S3 method for class 'power4test_by_n' c(..., sort = TRUE, skip_checking_models = FALSE)  as.power4test_by_n(original_object)  # S3 method for class 'power4test_by_n' print(x, print_all = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power By Sample Sizes — power4test_by_n","text":"object power4test object, power4test_by_n object. power4test_by_n object, first element, power4test object, used value argument. n numeric vector sample sizes simulation conducted. progress Logical. Whether progress simulation displayed. ... power4test_by_n(), arguments passed power4test(). c.power4test_by_n(), power4test_by_n() outputs combined together. print method output power4test_by_n(), arguments passed print method output power4test() (print.power4test()). by_seed set number, used generate seeds call power4test(). NULL, default, seeds still randomly generated results easily reproduced. by_nrep set number, used generate number replications (nrep) call power4test(). set numeric vector length n, nrep values calls, allowing different numbers replications sample sizes. NULL, default, original nrep used. argument used x_from_power() efficiency, rarely used calling function directly. save_sim_all FALSE, dataset power4test objects saved, reduce size output. Default TRUE. sort combining objects, whether sorted sample sizes. Default TRUE. skip_checking_models Whether check data generation model checked. Default TRUE. set FALSE users certain based model, model saved (e.g., save_sim_all set FALSE objects generated). argument used x_from_power() efficiency, rarely used calling c method directly. original_object object converted power4test_by_n object. x object printed. print_all TRUE, elements x, , results sample sizes examined, printed. FALSE, first sample size printed.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power By Sample Sizes — power4test_by_n","text":"function power4test_by_n() returns power4test_by_n object, list power4test objects, one sample size. method c.power4test_by_n() returns power4test_by_n object elements (tests different sample sizes) combined. function .power4test_by_n() returns power4test_by_n object converted input object. print-method power4test_by_n objects returns object invisibly. called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power By Sample Sizes — power4test_by_n","text":"function regenerates datasets set sample sizes stored tests . Optionally, can also run object stored tests. case, additional arguments must set instruct power4test() tests conducted. usually used examine power set sample sizes. method c.power4test_by_n() used combine tests different runs power4test_by_n(). function .power4test_by_n() used convert power4test object power4test_by_n object, already one. Useful concatenating power4test objects power4test_by_n objects.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power4test_by_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power By Sample Sizes — power4test_by_n","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  sim_only <- power4test(nrep = 2,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 40,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Do the test: test_indirect: x->m->y   out <- power4test_by_n(test_out,                        n = c(100, 110, 120)) #>  #> Updating the simulation for sample size: 100  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for sample size: 110  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : #>  #> Updating the simulation for sample size: 120  #> Re-simulate the data: #> Fit the model(s): #> Generate bootstrap estimates: #> Update the test(s): #> Update test_indirect: x->m->y : out_reject <- rejection_rates(out) out_reject #> [test]: test_indirect: x->m->y  #> [test_label]: Test  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.132 1.000  0.500 -0.193  1.193 #> 2 110 0.166 1.000  1.000  1.000  1.000 #> 3 120 0.162 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns."},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Power Curve — power_curve","title":"Power Curve — power_curve","text":"Estimate relation power characteristic, sample size population effect size (population value model parameter).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power Curve — power_curve","text":"","code":"power_curve(   object,   formula = NULL,   start = NULL,   lower_bound = NULL,   upper_bound = NULL,   nls_args = list(),   nls_control = list(),   verbose = FALSE,   models = c(\"nls\", \"logistic\", \"lm\") )  # S3 method for class 'power_curve' print(x, data_used = FALSE, digits = 3, right = FALSE, row.names = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power Curve — power_curve","text":"object object class power4test_by_n power4test_by_es, output power4test_by_n() power4test_by_es(). formula formula model stats::nls(). can also list formulas, models fitted successively stats::nls(), first model fitted successfully adopted. response variable formula must named reject, predictor named x. Whether x represents n es depends class object. NULL, default, determined internally based type object. start Either named vector start value(s) parameter(s) formula, list named vectors starting value(s) list formula(s). NULL, default, determined internally. lower_bound Either named vector lower bound(s) parameter(s) formula, list named vectors lower bound(s) list formula(s). passed lower stats::nls(). NULL, default, determined internally based type object. upper_bound Either named vector upper bound(s) parameter(s) formula, list named vectors upper bound(s) list formula(s). passed upper stats::nls(). NULL, default, determined internally based type object. nls_args named list arguments used calling stats::nls(). Used override internal default, algorithm (default \"port\"). Use argument cautions. nls_control named list arguments passed control argument stats::nls(). values override internal default values, also override nls_args. Use argument cautions. verbose Logical. Whether messages printed trying different models. models Models try. Support \"nls\" (fitted nls()), \"logistic\" (fitted glm()), \"lm\" (fitted lm()). default, three models attempted, order. x power_curve object. data_used Logical. Whether rejection rates data frame used fit model printed. digits, right, row.names Arguments names used print method data.frame object. Used data_used TRUE rejection rates data frame printed. ... print method power_curve objects, optional arguments passed print.data.frame() printing rejection rates data frame.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power Curve — power_curve","text":"returns list power_curve object, following elements: fit: model fitted, output stats::nls(), stats::glm(), stats::lm(). reject_df: table reject rates characteristics, generated rejection_rates(). predictor: predictor power curve, ether \"n\" (sample size) \"es\" (population effect size). call: call used run function. print method power_curve object returns x invisibly. Called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power Curve — power_curve","text":"retrieves information output power4test_by_n() power4test_by_es(), estimate power curve: relation characteristic varied, sample size power4test_by_n() population effect size power4test_by_es(), rejection rate test conducted power4test_by_n() power4test_by_es(). rejection rate power null hypothesis false (e.g., population value effect size tested nonzero). model fitted intended precise model relation across wide range. crude estimate based limited number values characteristic (e.g., sample size) examined, can small four even smaller. model intended used range covered, estimating probable sample size effect size desirable level power. value studied higher precision simulation using functions power4test(). models tried, following order: One nonlinear models, fitted stats::nls(). several models specified, fitted one smallest deviance used. nonlinear models failed, whatever reason, logistic regression fitted stats::glm() predict binary significant test results. logistic model also failed, whatever reason, simple linear regression model fitted. Although power curve nonlinear across wide range , say, sample size, linear model can still good enough approximation narrow range predictor. output can plotted visualize power curve, using plot method (plot.power_curve()) output power_curve(). function can used directly, also used internally functions x_from_power().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power Curve — power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 100, 200, 1000),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.550280     0.004213   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    54.55  #> Residual Deviance: 38.37 \tAIC: 42.37 plot(pout1)   # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = seq(0, .7, .15),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) pout2 #> Call: #> power_curve(object = out2) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      -3.347       17.231   #>  #> Degrees of Freedom: 49 Total (i.e. Null);  48 Residual #> Null Deviance:\t    65.34  #> Residual Deviance: 25 \tAIC: 29 plot(pout2)"},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for a 'power_curve' Object — predict.power_curve","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"Compute predicted values model fitted power_curve().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"","code":"# S3 method for class 'power_curve' predict(object, newdata, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"object power_curve object. newdata data frame column named x. can also named list, one element named x vector values. supplied, values x stored object used. ... Additional arguments. Passed corresponding predict method.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"returns numeric vector predicted rejection rates.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"works two modes. new data supplied (newdata), retrieves stored results calls corresponding methods compute predicted values, predicted rejection rates (power levels null hypothesis false, e.g., population effect size equal zero). new data supplied, named list vector sample sizes, used compute predicted rejection rates.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/predict.power_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for a 'power_curve' Object — predict.power_curve","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: s \"  # Simulate datasets to check the model  sim_only <- power4test(nrep = 10,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 50,                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234,                        parallel = FALSE,                        progress = FALSE)  # By n: Do a test for different sample sizes  out1 <- power4test_by_n(sim_only,                         nrep = 10,                         test_fun = test_parameters,                         test_args = list(par = \"y~x\"),                         n = c(25, 100, 200, 1000),                         by_seed = 1234,                         parallel = FALSE,                         progress = FALSE)  pout1 <- power_curve(out1) pout1 #> Call: #> power_curve(object = out1) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>   -1.550280     0.004213   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    54.55  #> Residual Deviance: 38.37 \tAIC: 42.37 predict(pout1,         newdata = list(x = c(150, 250, 500))) #>         1         2         3  #> 0.2852909 0.3782246 0.6355494   # By pop_es: Do a test for different population values of a model parameter  out2 <- power4test_by_es(sim_only,                              nrep = 10,                              test_fun = test_parameters,                              test_args = list(par = \"y~x\"),                              pop_es_name = \"y ~ x\",                              pop_es_values = seq(0, .7, .15),                              by_seed = 1234,                              parallel = FALSE,                              progress = FALSE)  pout2 <- power_curve(out2) pout2 #> Call: #> power_curve(object = out2) #>  #> Predictor: es (Effect Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>      -3.347       17.231   #>  #> Degrees of Freedom: 49 Total (i.e. Null);  48 Residual #> Null Deviance:\t    65.34  #> Residual Deviance: 25 \tAIC: 29 predict(pout2,         newdata = list(x = c(.25, .55))) #>         1         2  #> 0.7232684 0.9978282"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the Population Model — ptable_pop","title":"Generate the Population Model — ptable_pop","text":"Generate complete population model using model syntax user-specified effect sizes (population parameter values).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the Population Model — ptable_pop","text":"","code":"ptable_pop(   model = NULL,   pop_es = NULL,   es1 = c(n = 0, nil = 0, s = 0.1, m = 0.3, l = 0.5, si = 0.141, mi = 0.361, li = 0.51),   es2 = c(n = 0, nil = 0, s = 0.05, m = 0.1, l = 0.15),   es_ind = c(\"si\", \"mi\", \"li\"),   standardized = TRUE,   n_std = 1e+05,   std_force_monte_carlo = FALSE )  model_matrices_pop(x, ..., drop_list_single_group = TRUE)"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the Population Model — ptable_pop","text":"model String. model defined lavaan model syntax. See 'Details'. pop_es can data frame columns: lhs, op, rhs, pop. first three columns correspond lavaan parameter table. column pop stores population values. column es stores original labels, reference. can also named character vector (named list multigroup models) multiline string, preferred approaches. See help page specify vector. es1 Set values label effect size (population value) correlations regression paths. Used pop_es named vector multiline string. See help page specify argument. es2 Set values label effect size (population value) product term. Used pop_es named vector multiline string. See help page specify argument. es_ind names labels denoting effect size indirect effect. used determine population values component paths along indirect path. standardized Logical. TRUE, default, variances error variances scaled ensure population variances endogenous variables close one, hence effect sizes (population values) standardized effect sizes variances continuous exogenous variables also equal one. n_std sample size used determine error variances simulation std_force_monte_carlo TRUE. std_force_monte_carlo Logical. FALSE, default, standardization done analytically model product terms, simulation model product terms. , error variances required ensure implied variances equal one determined simulation. TRUE, simulation used whether model product terms . Always fall back simulation analytical standardization failed. x can 'lavaan' model syntax, passed ptable_pop(), parameter table column start set population values, output ptable_pop(). ... x model syntax, arguments passed ptable_pop(). drop_list_single_group TRUE number groups equal one, output list matrices one group . Default TRUE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() returns lavaan parameter table model, column start set population values. function model_matrices_pop() returns lavaan LISREL-style model matrices (like output lavaan::lavInspect() set \"free\"), matrix elements set population values. x model syntax, stored attributes model. model multigroup model k groups (k greater 1), returns list k lists lavaan LISREL-style model matrices unless drop_list_single_group TRUE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() generates lavaan parameter table can used generate data based population values model parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"the-role-of-ptable-pop-","dir":"Reference","previous_headings":"","what":"The role of ptable_pop()","title":"Generate the Population Model — ptable_pop","text":"function ptable_pop() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Generate the Population Model — ptable_pop","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Generate the Population Model — ptable_pop","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Generate the Population Model — ptable_pop","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Generate the Population Model — ptable_pop","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Generate the Population Model — ptable_pop","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Generate the Population Model — ptable_pop","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Generate the Population Model — ptable_pop","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Generate the Population Model — ptable_pop","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"the-role-of-model-matrices-pop-","dir":"Reference","previous_headings":"","what":"The role of model_matrices_pop()","title":"Generate the Population Model — ptable_pop","text":"function model_matrices_pop() generates models matrices population values, used ptable_pop(). Users usually call function directly, though developers can use build workflows generate data.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/ptable_pop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate the Population Model — ptable_pop","text":"","code":"# Specify the model  model1 <- \" m1 ~ x + c1 m2 ~ m1 + x2 + c1 y ~  m2 + m1 + x + w + x:w + c1 \"  # Specify the population values  model1_es <- c(\"m1 ~ x\" = \"-m\",                \"m2 ~ m1\" = \"s\",                \"y ~ m2\" = \"l\",                \"y ~ x\" = \"m\",                \"y ~ w\" = \"s\",                \"y ~ x:w\" = \"s\",                \"x ~~ w\" = \"s\")  ptable_final1 <- ptable_pop(model1,                             pop_es = model1_es) ptable_final1 #>    id lhs op rhs group user block free ustart exo label plabel      start est #> 1   1  m1  ~   x     1    1     1    1     NA   0         .p1. -0.3000000   0 #> 2   2  m1  ~  c1     1    1     1    2     NA   0         .p2.  0.0000000   0 #> 3   3  m2  ~  m1     1    1     1    3     NA   0         .p3.  0.1000000   0 #> 4   4  m2  ~  x2     1    1     1    4     NA   0         .p4.  0.0000000   0 #> 5   5  m2  ~  c1     1    1     1    5     NA   0         .p5.  0.0000000   0 #> 6   6   y  ~  m2     1    1     1    6     NA   0         .p6.  0.5000000   0 #> 7   7   y  ~  m1     1    1     1    7     NA   0         .p7.  0.0000000   0 #> 8   8   y  ~   x     1    1     1    8     NA   0         .p8.  0.3000000   0 #> 9   9   y  ~   w     1    1     1    9     NA   0         .p9.  0.1000000   0 #> 10 10   y  ~ x:w     1    1     1   10     NA   0        .p10.  0.0500000   0 #> 11 11   y  ~  c1     1    1     1   11     NA   0        .p11.  0.0000000   0 #> 12 12  m1 ~~  m1     1    0     1   12     NA   0        .p12.  0.9102952   1 #> 13 13  m2 ~~  m2     1    0     1   13     NA   0        .p13.  0.9899976   1 #> 14 14   y ~~   y     1    0     1   14     NA   0        .p14.  0.6509433   1 #> 15 15   x ~~   x     1    0     1   15     NA   0        .p15.  1.0000000   1 #> 16 16   x ~~  c1     1    0     1   16     NA   0        .p16.  0.0000000   0 #> 17 17   x ~~  x2     1    0     1   17     NA   0        .p17.  0.0000000   0 #> 18 18   x ~~   w     1    0     1   18     NA   0        .p18.  0.1000000   0 #> 19 19   x ~~ x:w     1    0     1   19     NA   0        .p19.  0.0000000   0 #> 20 20  c1 ~~  c1     1    0     1   20     NA   0        .p20.  1.0000000   1 #> 21 21  c1 ~~  x2     1    0     1   21     NA   0        .p21.  0.0000000   0 #> 22 22  c1 ~~   w     1    0     1   22     NA   0        .p22.  0.0000000   0 #> 23 23  c1 ~~ x:w     1    0     1   23     NA   0        .p23.  0.0000000   0 #> 24 24  x2 ~~  x2     1    0     1   24     NA   0        .p24.  1.0000000   1 #> 25 25  x2 ~~   w     1    0     1   25     NA   0        .p25.  0.0000000   0 #> 26 26  x2 ~~ x:w     1    0     1   26     NA   0        .p26.  0.0000000   0 #> 27 27   w ~~   w     1    0     1   27     NA   0        .p27.  1.0000000   1 #> 28 28   w ~~ x:w     1    0     1   28     NA   0        .p28.  0.0000000   0 #> 29 29 x:w ~~ x:w     1    0     1   29     NA   0        .p29.  1.0000000   1  # Use multiline string, illustrated by a simpler model  model2 <- \" m ~ x y ~ m + x \"  model2_es_a <- c(\"m ~ x\" = \"s\",                \"y ~ m\" = \"m\",                \"y ~ x\" = \"nil\")  model2_es_b <- \" m ~ x: s y ~ m: m y ~ x: nil \"  ptable_model2_a <- ptable_pop(model2,                               pop_es = model2_es_a) ptable_model2_b <- ptable_pop(model2,                               pop_es = model2_es_b)  ptable_model2_a #>   id lhs op rhs group user block free ustart exo label plabel start est #> 1  1   m  ~   x     1    1     1    1     NA   0         .p1.  0.10   0 #> 2  2   y  ~   m     1    1     1    2     NA   0         .p2.  0.30   0 #> 3  3   y  ~   x     1    1     1    3     NA   0         .p3.  0.00   0 #> 4  4   m ~~   m     1    0     1    4     NA   0         .p4.  0.99   1 #> 5  5   y ~~   y     1    0     1    5     NA   0         .p5.  0.91   1 #> 6  6   x ~~   x     1    0     1    6     NA   0         .p6.  1.00   1 ptable_model2_b #>   id lhs op rhs group user block free ustart exo label plabel start est #> 1  1   m  ~   x     1    1     1    1     NA   0         .p1.  0.10   0 #> 2  2   y  ~   m     1    1     1    2     NA   0         .p2.  0.30   0 #> 3  3   y  ~   x     1    1     1    3     NA   0         .p3.  0.00   0 #> 4  4   m ~~   m     1    0     1    4     NA   0         .p4.  0.99   1 #> 5  5   y ~~   y     1    0     1    5     NA   0         .p5.  0.91   1 #> 6  6   x ~~   x     1    0     1    6     NA   0         .p6.  1.00   1  identical(ptable_model2_a,           ptable_model2_b) #> [1] TRUE  # model_matrices_pop  model_matrices_pop(ptable_final1) #> $lambda #>     m1 m2 y x c1 x2 w x:w #> m1   0  0 0 0  0  0 0   0 #> m2   0  0 0 0  0  0 0   0 #> y    0  0 0 0  0  0 0   0 #> x    0  0 0 0  0  0 0   0 #> c1   0  0 0 0  0  0 0   0 #> x2   0  0 0 0  0  0 0   0 #> w    0  0 0 0  0  0 0   0 #> x:w  0  0 0 0  0  0 0   0 #>  #> $theta #>     m1 m2 y x c1 x2 w x:w #> m1   0                    #> m2   0  0                 #> y    0  0 0               #> x    0  0 0 0             #> c1   0  0 0 0  0          #> x2   0  0 0 0  0  0       #> w    0  0 0 0  0  0 0     #> x:w  0  0 0 0  0  0 0   0 #>  #> $psi #>        m1    m2     y     x    c1    x2     w   x:w #> m1  0.910                                           #> m2  0.000 0.990                                     #> y   0.000 0.000 0.651                               #> x   0.000 0.000 0.000 1.000                         #> c1  0.000 0.000 0.000 0.000 1.000                   #> x2  0.000 0.000 0.000 0.000 0.000 1.000             #> w   0.000 0.000 0.000 0.100 0.000 0.000 1.000       #> x:w 0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000 #>  #> $beta #>      m1  m2 y    x c1 x2   w  x:w #> m1  0.0 0.0 0 -0.3  0  0 0.0 0.00 #> m2  0.1 0.0 0  0.0  0  0 0.0 0.00 #> y   0.0 0.5 0  0.3  0  0 0.1 0.05 #> x   0.0 0.0 0  0.0  0  0 0.0 0.00 #> c1  0.0 0.0 0  0.0  0  0 0.0 0.00 #> x2  0.0 0.0 0  0.0  0  0 0.0 0.00 #> w   0.0 0.0 0  0.0  0  0 0.0 0.00 #> x:w 0.0 0.0 0  0.0  0  0 0.0 0.00 #>  #> attr(,\"model\") #> [1] \"\\nm1 ~ x + c1\\nm2 ~ m1 + x2 + c1\\ny ~  m2 + m1 + x + w + x:w + c1\\n\"  model_matrices_pop(model1,                    pop_es = model1_es) #> $lambda #>     m1 m2 y x c1 x2 w x:w #> m1   0  0 0 0  0  0 0   0 #> m2   0  0 0 0  0  0 0   0 #> y    0  0 0 0  0  0 0   0 #> x    0  0 0 0  0  0 0   0 #> c1   0  0 0 0  0  0 0   0 #> x2   0  0 0 0  0  0 0   0 #> w    0  0 0 0  0  0 0   0 #> x:w  0  0 0 0  0  0 0   0 #>  #> $theta #>     m1 m2 y x c1 x2 w x:w #> m1   0                    #> m2   0  0                 #> y    0  0 0               #> x    0  0 0 0             #> c1   0  0 0 0  0          #> x2   0  0 0 0  0  0       #> w    0  0 0 0  0  0 0     #> x:w  0  0 0 0  0  0 0   0 #>  #> $psi #>       m1   m2    y    x   c1   x2    w  x:w #> m1  0.91                                    #> m2  0.00 0.99                               #> y   0.00 0.00 0.65                          #> x   0.00 0.00 0.00 1.00                     #> c1  0.00 0.00 0.00 0.00 1.00                #> x2  0.00 0.00 0.00 0.00 0.00 1.00           #> w   0.00 0.00 0.00 0.10 0.00 0.00 1.00      #> x:w 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1.00 #>  #> $beta #>      m1  m2 y    x c1 x2   w  x:w #> m1  0.0 0.0 0 -0.3  0  0 0.0 0.00 #> m2  0.1 0.0 0  0.0  0  0 0.0 0.00 #> y   0.0 0.5 0  0.3  0  0 0.1 0.05 #> x   0.0 0.0 0  0.0  0  0 0.0 0.00 #> c1  0.0 0.0 0  0.0  0  0 0.0 0.00 #> x2  0.0 0.0 0  0.0  0  0 0.0 0.00 #> w   0.0 0.0 0  0.0  0  0 0.0 0.00 #> x:w 0.0 0.0 0  0.0  0  0 0.0 0.00 #>  #> attr(,\"model\") #> [1] \"\\nm1 ~ x + c1\\nm2 ~ m1 + x2 + c1\\ny ~  m2 + m1 + x + w + x:w + c1\\n\""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Beta Distribution — rbeta_rs","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"Generate random numbers beta distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"","code":"rbeta_rs(n = 10, shape1 = 0.5, shape2 = 0.5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"n number random numbers generate. shape1 shape1 stats::rbeta(). shape2 shape2 stats::rbeta(). pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"First, specify two parameters, shape1 shape2, desired population mean standard deviation. random numbers, drawn beta distribution stats::rbeta() rescaled desired population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Beta Distribution — rbeta_rs","text":"","code":"set.seed(90870962) x <- rbeta_rs(n = 5000,               shape1 = .5,               shape2 = .5,               pmean = 3,               psd = 1) mean(x) #> [1] 3.003229 sd(x) #> [1] 0.9983932 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"Generate random numbers beta distribution, rescaled user-specified population mean standard deviation, within specific range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"","code":"rbeta_rs2(n = 10, bmean, bsd, blow = 0, bhigh = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"n number random numbers generate. bmean population mean. bsd population standard deviation. bsd zero negative, random numbers equal bmean. blow lower bound target range. bhigh upper bound target range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"First, specify two parameters, shape1 shape2, desired population mean standard deviation. random numbers, drawn beta distribution stats::rbeta() rescaled desired population range.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbeta_rs2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Beta Distribution (User Range) — rbeta_rs2","text":"","code":"set.seed(90870962) x <- rbeta_rs2(n = 5000,                bmean = .80,                bsd = .10,                blow = .00,                bhigh = .95) mean(x) #> [1] 0.7991104 sd(x) #> [1] 0.1005175 hist(x)  y <- rbeta_rs2(n = 5000,                bmean = 4,                bsd = 3,                blow = -10,                bhigh = 10) mean(y) #> [1] 4.003419 sd(y) #> [1] 3.045306 hist(y)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Binary Variable — rbinary_rs","title":"Random Binary Variable — rbinary_rs","text":"Generate random numbers distribution 0 1, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Binary Variable — rbinary_rs","text":"","code":"rbinary_rs(n = 10, p1 = 0.5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Binary Variable — rbinary_rs","text":"n number random numbers generate. p1 probability 1, rescaling. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Binary Variable — rbinary_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Binary Variable — rbinary_rs","text":"First, specify probability 1 (p1), desired population mean standard deviation. random numbers, drawn distribution 0 (1 - p1 probability) 1 (p1 probability), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rbinary_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Binary Variable — rbinary_rs","text":"","code":"set.seed(90870962) x <- rbinary_rs(n = 5000,                 p1 = .5,                 pmean = 3,                 psd = 1) mean(x) #> [1] 3.0244 sd(x) #> [1] 0.9998023 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":null,"dir":"Reference","previous_headings":"","what":"Rejection Rates — rejection_rates","title":"Rejection Rates — rejection_rates","text":"Get rejection rates tests stored power4test object supported objects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rejection Rates — rejection_rates","text":"","code":"rejection_rates(object, ...)  # Default S3 method rejection_rates(object, ...)  # S3 method for class 'power4test' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'power4test_by_es' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'power4test_by_n' rejection_rates(   object,   all_columns = FALSE,   ci = TRUE,   level = 0.95,   se = FALSE,   ... )  # S3 method for class 'rejection_rates_df' print(x, digits = 3, annotation = TRUE, abbreviate_col_names = TRUE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rejection Rates — rejection_rates","text":"object object rejection rates computed, power4test object, power4test_by_n object, power4test_by_es object. ... Optional arguments. print method, arguments passed print method data.frame objects print.data.frame(). used methods. all_columns TRUE, columns stored test extracted. Default FALSE essential columns related power printed. ci TRUE, confidence intervals rejection rates (column reject sig) computed. Normal approximation used forming confidence intervals. level level confidence confidence intervals, ci TRUE. Default .95, denoting 95%. se TRUE, standard errors rejection rates (column reject sig) computed. Normal approximation used compute standard errors. x rejection_rates_df object printed. digits number digits printed decimal. annotation Logical. Whether additional notes printed. abbreviate_col_names Logical. Whether column names abbreviated.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rejection Rates — rejection_rates","text":"rejection_rates method returns rejection_rates_df object, print method. input (object) power4test object, output data-frame like object number rows equal number tests. Note tests, test test_parameters(), conduct one test parameters. test counted one test. data frame least columns: test: name test. label: label test, \"Test\" test one test (e.g., test_indirect_effect()). pvalid: proportion valid tests across replications. reject: rejection rate test. null hypothesis false, power. rejection_rates method power4test_by_es objects returns object class rejection_rates_df_by_es, subclass rejection_rates_df. data frame similar output rejection_rates(), two columns added effect size (pop_es_name pop_es_values) test. rejection_rates method power4test_by_n objects returns object class rejection_rates_df_by_n, subclass rejection_rates_df. data frame similar output power4test object, column n added sample size test. print method rejection_rates_df object return object invisibly. called side-effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rejection Rates — rejection_rates","text":"power4test object, loops tests stored power4test object retrieves rejection rate test. rejection_rates method power4test_by_es objects used compute rejection rates power4test_by_es object, effect sizes added output. rejection_rates method power4test_by_n objects used compute rejection rates, sample sizes added output.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/rejection_rates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rejection Rates — rejection_rates","text":"","code":"# Specify the population model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the effect sizes (population parameter values)  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Generate some datasets to check the model  sim_only <- power4test(nrep = 4,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 50,                        ci_type = \"boot\",                        fit_model_args = list(fit_function = \"lm\"),                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate bootstrap estimates:  # Do the test 'test_indirect_effect' on each datasets  test_out <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         boot_ci = TRUE,                                         mc_ci = FALSE)) #> Do the test: test_indirect: x->m->y   # Do the test 'test_parameters' on each datasets # and add the results to 'test_out'  test_out <- power4test(object = test_out,                        test_fun = test_parameters) #> Do the test: test_parameters: CIs    # Compute and print the rejection rates for stored tests  rejection_rates(test_out) #>                     test test_label    est   p.v reject r.cilo r.cihi #> 1 test_indirect: x->m->y       Test  0.149 1.000  1.000  1.000  1.000 #> 2  test_parameters: CIs         m~x  0.317 1.000  1.000  1.000  1.000 #> 3  test_parameters: CIs         y~m  0.475 1.000  1.000  1.000  1.000 #> 4  test_parameters: CIs         y~x -0.080 1.000  0.000  0.000  0.000 #> Notes: #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns.  # See the help pages of power4test_by_n() and power4test_by_es() # for other examples."},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From an Exponential Distribution — rexp_rs","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"Generate random numbers exponential distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"","code":"rexp_rs(n = 10, rate = 1, pmean = 0, psd = 1, rev = FALSE)"},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"n number random numbers generate. rate rate stats::rexp(). pmean Population mean. psd Population standard deviation. rev TRUE, distribution revered generate negatively skewed distribution. Default FALSE.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"First, specify parameter, rate, desired population mean standard deviation. random numbers, drawn exponential distribution stats::rexp(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rexp_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From an Exponential Distribution — rexp_rs","text":"","code":"set.seed(90870962) x <- rexp_rs(n = 5000,              rate = 4,              pmean = 3,              psd = 1) mean(x) #> [1] 2.999214 sd(x) #> [1] 1.008795 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Lognormal Distribution — rlnorm_rs","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"Generate random numbers lognormal distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"","code":"rlnorm_rs(n = 10, mui = 0, sigma = 1, rev = FALSE, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"n number random numbers generate. mui parameter mui used stats::rlnorm(). sigma parameter sigma used stats::rlnorm(). rev TRUE, distribution revered generate negatively skewed distribution. Default FALSE. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"First, specify parameter, mui sigma, desired population mean standard deviation. random numbers, drawn lognormal distribution stats::rlnorm(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rlnorm_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Lognormal Distribution — rlnorm_rs","text":"","code":"set.seed(90870962) x <- rlnorm_rs(n = 5000, mui = 0, sigma = 1, pmean = 0, psd = 1) mean(x) #> [1] -0.005312214 sd(x) #> [1] 0.9400859 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"Generate random numbers generalized normal distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"","code":"rpgnorm_rs(n = 10, p = 2, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"n number random numbers generate. p parameter distribution. Must positive non-zero number. Default 2, resulting normal distribution. Higher 2 results negative excess kurtosis. Lower 2 results positive excess kurtosis. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"First, specify parameter p desired population mean standard deviation. random numbers, drawn generalized normal distribution pgnorm::rpgnorm(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rpgnorm_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Generalized Normal Distribution — rpgnorm_rs","text":"","code":"set.seed(90870962) x <- rpgnorm_rs(n = 5000,                 p = 2,                 pmean = 0, psd = 1) mean(x) #> [1] -0.01118704 sd(x) #> [1] 1.010004 hist(x)  x_kurt <- function(p) {gamma(5/p)*gamma(1/p)/(gamma(3/p)^2) - 3} p <- 6 x <- rpgnorm_rs(n = 50000, p = p, pmean = 0, psd = 1) mean(x) #> [1] 0.002266498 sd(x) #> [1] 1.001834 x_kurt(p) #> [1] -1 qqnorm(x); qqline(x)  p <- 1 x <- rpgnorm_rs(n = 50000, p = p, pmean = 0, psd = 1) mean(x) #> [1] 0.007350372 sd(x) #> [1] 0.9993787 x_kurt(p) #> [1] 3 qqnorm(x); qqline(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a t Distribution — rt_rs","title":"Random Variable From a t Distribution — rt_rs","text":"Generate random numbers t distribution, rescaled user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a t Distribution — rt_rs","text":"","code":"rt_rs(n = 10, df = 5, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a t Distribution — rt_rs","text":"n number random numbers generate. df df stats::rt(). pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a t Distribution — rt_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a t Distribution — rt_rs","text":"First, specify parameter df desired population mean standard deviation. random numbers, drawn generalized normal distribution stats::rt(), rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/rt_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a t Distribution — rt_rs","text":"","code":"set.seed(90870962) x <- rt_rs(n = 5000,            df = 5,            pmean = 3,            psd = 1) mean(x) #> [1] 3.004783 sd(x) #> [1] 0.9926204 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Variable From a Uniform Distribution — runif_rs","title":"Random Variable From a Uniform Distribution — runif_rs","text":"Generate random numbers uniform distribution, user-specified population mean standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Variable From a Uniform Distribution — runif_rs","text":"","code":"runif_rs(n = 10, min = 0, max = 1, pmean = 0, psd = 1)"},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Variable From a Uniform Distribution — runif_rs","text":"n number random numbers generate. min min runif. max max runif. pmean Population mean. psd Population standard deviation.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Variable From a Uniform Distribution — runif_rs","text":"vector generated random numbers.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Variable From a Uniform Distribution — runif_rs","text":"First, user specifies parameters, min max, desired population mean standard deviation. random numbers generated rescaled desired population mean standard.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/runif_rs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Variable From a Uniform Distribution — runif_rs","text":"","code":"set.seed(90870962) x <- runif_rs(n = 5000, min = 2, max = 4, pmean = 3, psd = 1) mean(x) #> [1] 2.987606 sd(x) #> [1] 0.9978981 hist(x)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Datasets Based on a Model — sim_data","title":"Simulate Datasets Based on a Model — sim_data","text":"Get model matrix effect size specification simulate number datasets, along information. function","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Datasets Based on a Model — sim_data","text":"","code":"sim_data(   nrep = 10,   ptable = NULL,   model = NULL,   pop_es = NULL,   ...,   n = 100,   iseed = NULL,   number_of_indicators = NULL,   reliability = NULL,   x_fun = list(),   e_fun = list(),   process_data = NULL,   parallel = FALSE,   progress = FALSE,   ncores = max(1, parallel::detectCores(logical = FALSE) - 1) )  # S3 method for class 'sim_data' print(   x,   digits = 3,   digits_descriptive = 2,   data_long = TRUE,   fit_to_all_args = list(),   est_type = \"standardized\",   variances = NULL,   pure_x = TRUE,   pure_y = TRUE,   ... )  pool_sim_data(object, as_list = FALSE)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Datasets Based on a Model — sim_data","text":"nrep number replications generate simulated datasets. Default 10. ptable output ptable_pop(), ptable_pop object, representing population model. NULL, default, ptable_pop() called generate ptable_pop object, using arguments model pop_es. model lavaan model syntax population model. Ignored ptable specified. See ptable_pop specify argument. pop_es character specify population effect sizes. See ptable_pop specify argument. Ignored ptable specified. ... sim_data, parameters passed ptable_pop(). print.sim_data(), arguments ignored. n sample size dataset. Default 100. iseed seed random number generator. Default NULL seed changed. number_of_indicators named vector specify number indicators factors. See help page set argument. Default NULL variables model syntax observed variables. See help page use argument. reliability named vector (single-group model) named list named vectors (multigroup model) set reliability coefficient set indicators. Default NULL. See help page use argument. x_fun function(s) used generate exogenous variables error terms. supplied, set list(), default, variables generated multivariate normal distribution. See help page use argument. e_fun function(s) used generate error terms indicators, . supplied, set list(), default, error terms indicators generated multivariate normal distribution. Specify way x_fun. Refer help page x_fun use argument. process_data NULL, must named list elements: fun (required), function processing simulated data, generating missing data using functions mice::ampute(); args (optional), named list arguments passed fun, except one source data; sim_data_name (required) name argument receive simulated data (e.g., data mice::ampute()); processed_data_name (optional), name data frame processed fun, data frame missing data output fun (e.g., \"amp\" mice::ampute()), omitted, output fun data frame missing data. parallel TRUE, parallel processing used simulate datasets. Default FALSE. progress TRUE, progress data simulation displayed. Default `FALSE. ncores number CPU cores use parallel processing used. x sim_data object printed. digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. data_long TRUE, detailed information printed. fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined samples stored. est_type type estimates printed. Can character vector one two elements. \"standardized\", standardized estimates printed. \"unstandardized\", unstandardized estimates printed. vector like c(\"standardized\", \"unstandardized\"), unstandardized standardized estimates printed. variances Logical. Whether variances error variances printed. Default depends est_type. \"unstandardized\" est_type, default TRUE \"standardized\" est_type, default FALSE. pure_x, pure_y Logical. printing indirect effects, whether \"pure\" x-variables (variables predicted another variables) /\"pure\" y-variables (variables predict variables indicators) included enumerating paths. object Either sim_data object power4test object. extracts simulated data return , combined one single data frame , as_list TRUE, list data frames. as_list Logical. TRUE, simulated datasets returned one single data frame. FALSE, returned list data frames.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_out() returns list class sim_data, length nrep. element sim_data_i object, following major elements: ptable: lavaan parameter table model, population values set column start. (output function ptable_pop().) mm_out: population model represented model matrices lavaan. (output function model_matrices_pop().) mm_lm_out: list regression model formula, one endogenous variable. (output internal function mm_lm().) mm_lm_dat_out: simulated dataset generated population model. (output internal function mm_lm_data()). model_original: original model syntax (.e., argument model). model_final: modified model syntax model latent variable model. Indicators added syntax. fit0: output lavaan::sem() ptable model .fit set FALSE. Used easy retrieval information model. print method sim_data returns x invisibly. called side effect. function pool_sim_data() returns either one data frame list data frames, depending argument as_list","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() generates list datasets based population model.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"the-role-of-sim-data-","dir":"Reference","previous_headings":"","what":"The role of sim_data()","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"workflow","dir":"Reference","previous_headings":"","what":"Workflow","title":"Simulate Datasets Based on a Model — sim_data","text":"function sim_data() two tasks: Determine actual population model population values based : model syntax observed variables (path model) latent factors (latent variable model). textual specification effect sizes parameters. number indicators latent factor model latent variable model. reliability latent factor measured indicators model latent factor model. Generate nrep simulated datasets population model. simulated datasets can used fit model, test parameters, estimate power. output usually used fit_model() fit target model, default population model, dataset.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"set-number-of-indicators-and-reliability-","dir":"Reference","previous_headings":"","what":"Set 'number_of_indicators' and 'reliability'","title":"Simulate Datasets Based on a Model — sim_data","text":"arguments number_of_indicators reliability used specify number indicators (e.g., items) factor, population reliability coefficient factor, variables model syntax latent variables.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"variable model replaced indicators generated data, set number_of_indicators named numeric vector. names variables variables indicators, appeared model syntax. value name number indicators. argument reliability set named numeric vector (list, see section multigroup models) specify population reliability coefficient (\"omega\") set indicators. population standardized factor loadings computed ensure population reliability coefficient target value. examples single group model: numbers indicators m, x, y 3, 4, 5, respectively. population reliability coefficients m, x, y .90, .80, .70, respectively.","code":"number of indicator = c(m = 3, x = 4, y = 5) reliability = c(m = .90, x = .80, y = .70)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-models","dir":"Reference","previous_headings":"","what":"Multigroup Models","title":"Simulate Datasets Based on a Model — sim_data","text":"Multigroup models supported. number groups inferred pop_es (see help page ptable_pop()), directly ptable. multigroup model, number indicators variable must across groups. However, population reliability coefficients can different across groups. multigroup model k groups, one population reliability coefficients differ across groups, argument reliability set named list. names variables population reliability coefficients set. element name either single value common reliability coefficient, numeric vector reliability coefficient group. example reliability model 2 groups: reliability coefficients x .80 groups, reliability coefficients m .70 one group .80 another.","code":"reliability = list(x = .80, m = c(.70, .80))"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"equal-numbers-of-indicators-and-or-reliability-coefficients","dir":"Reference","previous_headings":"","what":"Equal Numbers of Indicators and/or Reliability Coefficients","title":"Simulate Datasets Based on a Model — sim_data","text":"variables model number indicators, number_of_indicators can set one single value. Similarly, sets indicators population reliability groups, reliability can also set one single value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-the-distributions-of-exogenous-variables-or-error-terms-using-x-fun-","dir":"Reference","previous_headings":"","what":"Specify The Distributions of Exogenous Variables Or Error Terms Using 'x_fun'","title":"Simulate Datasets Based on a Model — sim_data","text":"default, variables error terms generated multivariate normal distribution. desired, users can supply function used generate exogenous variable error term setting x_fun named list. names list variables user function used generate data. element list must also list. first element list, can unnamed, function used. arguments need supplied, included named elements list. example: variables x w generated user-supplied functions. x, function power4mome::rexp_rs. additional argument calling function. w, function power4mome::rbinary_rx. argument p1 = .70 passed function generating values w. variable endogenous variable (e.g., predicted another variable model), x_fun used generate error term. implied population distribution may still different generate x_fun distribution also depends distribution variables predicting . requirements user-functions: must return numeric vector. mush argument n number values. population mean standard deviation generated values must 0 1, respectively. package power4mome helper functions generating values common nonnormal distributions scaling population mean standard deviation equal 0 1 (default), respectively. : rbinary_rs(). rexp_rs(). rbeta_rs(). rlnorm_rs(). rpgnorm_rs(). use x_fun, variables must zero covariances variables population. possible generate nonnormal multivariate data believe rarely needed estimating power data.","code":"x_fun = list(x = list(power4mome::rexp_rs),              w = list(power4mome::rbinary_rs,                       p1 = .70)))"},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-1","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"single-group model, model lavaan model syntax string form model. population values model parameters determined pop_es. model latent factors, syntax model specify structural model latent factors. need specify measurement part. functions generate measurement part top model. example, simple mediation model: Whether m, x, y denote observed variables latent factors determined functions, power4test().","code":"\"m ~ x  y ~ m + x\""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"model population model, equality constraints irrelevant model syntax specifies form model. Therefore, model specified case single group models.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-pop-es-using-named-vectors","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using Named Vectors","title":"Simulate Datasets Based on a Model — sim_data","text":"argument pop_es specifying population values model parameters. section describes using named vectors.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-2","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"pop_es specified named vector, must follow convention . names vectors lavaan names selected parameters. example, m ~ x denotes path x m. Alternatively, names can either \".beta.\" \".cov.\". Use \".beta.\" set default values regression coefficients. Use \".cov.\" set default values correlations exogenous variables (e.g., predictors). names can also form: \".ind.(<path>)\", whether <path> denote path model. example, \".ind.(x->m->y)\" denotes path x m y. Alternatively, lavaan symbol ~ can also used: \".ind.(y~m~x)\". form used set indirect effect (standardized, default) along path. value name override settings. using lavaan names, can specify one parameter using +. example, y ~ m + x denotes two paths m x y. value element can label effect size: n nil, s small, m medium, l large. value label determined es1 es2. See section specifying two arguments. value pop_es can also set value, must quoted string, \"y ~ x\" = \".31\". example: example, regression coefficients set small (s) default, unless specified otherwise. path x m1 set medium negative (-m). path m1 m2 set large (l). coefficient product term x:w predicting y set small (s).","code":"c(\".beta.\" = \"s\",   \"m1 ~ x\" = \"-m\",   \"m2 ~ m1\" = \"l\",   \"y ~ x:w\" = \"s\")"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"indirect-effect","dir":"Reference","previous_headings":"","what":"Indirect Effect","title":"Simulate Datasets Based on a Model — sim_data","text":"setting indirect effect symbol (default: \"si\", \"mi\", \"li\", \"\" added differentiate labels direct path), corresponding value used determine population values component paths along pathway. values assumed equal. Therefore, \".ind.(x->m->y)\" = \".20\" equivalent setting m ~ x y ~ m square root .20, corresponding indirect effect equal designated value. behavior, though restricted, quick manipulation indirect effect. different values along pathway, set value path directly. nonnegative value supported. Therefore, \".ind.(x->m->y)\" = \"-si\" \".ind.(x->m->y)\" = \"-.20\" throw error.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model-1","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"argument pop_es also supports multigroup models. pop_es, instead named vectors, named list named vectors used. names parameters, keywords .beta. .cov., like specifying population values single group model. elements character vectors. one element (e.g., single string), population value groups. one element (e.g., vector three strings), population values groups. model k groups, vector must either k elements one element. example: model, population value path m ~ x medium (m) groups, population values path y ~ m small (s), medium (m), large (l), respectively.","code":"list(\"m ~ x\" = \"m\",      \"y ~ m\" = c(\"s\", \"m\", \"l\"))"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"specify-pop-es-using-a-multiline-string","dir":"Reference","previous_headings":"","what":"Specify 'pop_es' Using a Multiline String","title":"Simulate Datasets Based on a Model — sim_data","text":"setting argument pop_es, instead using named vector named list pop_es, population values model parameters can also specified using multiline string, illustrated , parsed pop_es_yaml().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"single-group-model-3","dir":"Reference","previous_headings":"","what":"Single-Group Model","title":"Simulate Datasets Based on a Model — sim_data","text":"example multiline string single-group model: string must follow format: line starts tag:. tag can name parameter, lavaan model syntax format. example, m ~ x denotes path x m. tag lavaan model syntax can specify one parameter using +. example, y ~ m + x denotes two paths m x y. Alternatively, tag can either .beta. .cov.. Use .beta. set default values regression coefficients. Use .cov. set default values correlations exogenous variables (e.g., predictors). tag value population value: -nil nil (zero), s small, m medium, l large. si, mi, li small, medium, large standardized indirect effect, respectively. Note: n used mode. value label determined es1 es2 described ptable_pop(). value can also set numeric value, .30 -.30. another example: example, regression coefficients small, path m y large.","code":"y ~ m: l m ~ x: m y ~ x: nil .beta.: s y ~ m: l"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"multigroup-model-2","dir":"Reference","previous_headings":"","what":"Multigroup Model","title":"Simulate Datasets Based on a Model — sim_data","text":"example string multigroup model: format similar single-group model. parameter value groups, line can specified case single-group model: tag: value. parameter different values across groups, must format: line starts tag, followed two lines. line starts hyphen - value group. example: denotes model two groups. values path x m two groups 0 (nil) small (s), respectively. Another equivalent way specify values using [], line tag. example: number groups inferred number values parameter. Therefore, tag one value, tag must number value, one value. tag .beta. .cov. can also used multigroup models.","code":"y ~ m: l m ~ x:   - nil   - s y ~ x: nil m ~ x:   - nil   - s m ~ x: [nil, s]"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"which-approach-to-use","dir":"Reference","previous_headings":"","what":"Which Approach To Use","title":"Simulate Datasets Based on a Model — sim_data","text":"Note using named vectors named lists reliable. However, using multiline string user-friendly. method failed, please use named vectors named list instead.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"technical-details","dir":"Reference","previous_headings":"","what":"Technical Details","title":"Simulate Datasets Based on a Model — sim_data","text":"multiline string parsed yaml::read_yaml(). Therefore, format requirement actually YAML. Users knowledgeable YAML can use equivalent way specify string.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"set-the-values-for-effect-size-labels-es-and-es-","dir":"Reference","previous_headings":"","what":"Set the Values for Effect Size Labels ('es1' and 'es2')","title":"Simulate Datasets Based on a Model — sim_data","text":"vector es1 correlations, regression coefficients, indirect effect, vector es2 standardized moderation effect, coefficients product term. labels used interpreting specification pop_es.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Datasets Based on a Model — sim_data","text":"","code":"# Specify the model  mod <- \"m ~ x  y ~ m + x\"  # Specify the population values  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate the simulated datasets  data_all <- sim_data(nrep = 5,                      model = mod,                      pop_es = es,                      n = 100,                      iseed = 1234)  data_all #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #>  y ~ m + x #> == Model on Variables/Indicators == #> m ~ x #>  y ~ m + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.910   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.090 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars   n  mean   sd  skew kurtosis   se #> m    1 500 -0.03 1.00 -0.09    -0.03 0.04 #> y    2 500 -0.01 0.98  0.03     0.41 0.04 #> x    3 500  0.01 0.94 -0.21     0.17 0.04 #>  #> ===== Parameter Estimates Based on All 5 Samples Combined ===== #>  #> Total Sample Size: 500  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.323 #>   y ~                       #>     m                 0.277 #>     x                -0.098 #>"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a 'sim_out' Object — sim_out","title":"Create a 'sim_out' Object — sim_out","text":"Combine outputs sim_data(), fit_model(), optionally gen_mc() /gen_boot() one single object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a 'sim_out' Object — sim_out","text":"","code":"sim_out(data_all, ...)  # S3 method for class 'sim_out' print(x, digits = 3, digits_descriptive = 2, fit_to_all_args = list(), ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a 'sim_out' Object — sim_out","text":"data_all output sim_data(). ... Named arguments objects added replication element extra. example, set fit = fit_all, fit_all output fit_model(), data_all[[1]]$extra$fit set first output fit_all. x sim_out object printed. digits numbers digits displayed decimal. digits_descriptive number digits displayed decimal descriptive statistics table. fit_to_all_args named list arguments passed lavaan::sem() model fitted sample combined ","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a 'sim_out' Object — sim_out","text":"function sim_out() returns sim_out object, list length equal length data_all. element list sim_data object element extra added . named elements added name. example. output fit_model() replication can added fit, extra. See description argument ... details. print method sim_out returns x invisibly. Called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a 'sim_out' Object — sim_out","text":"merges one object output sim_data(), list nrep simulated datasets, fit_model(), list lavaan::sem() output nrep datasets, optionally output gen_mc() gen_boot(), list R sets Monte Carlo bootstrap estimates based results fit_model(). list nrep elements, element data, model fit results, optionally Monte Carlo estimates matched. object can used testing effects interests, processed estimate power test. function sim_out() used --one function power4test(). Users usually call function directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/sim_out.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a 'sim_out' Object — sim_out","text":"","code":"# Specify the model  mod <- \"m ~ x  y ~ m + x\"  # Specify the population values  es <- \" y ~ m: m m ~ x: m y ~ x: n \"  # Generate the simulated datasets  dats <- sim_data(nrep = 5,                  model = mod,                  pop_es = es,                  n = 100,                  iseed = 1234)  # Fit the population model to each dataset  fits <- fit_model(dats)  # Combine the results to one object  sim_out_all <- sim_out(data_all = dats,                        fit = fits) sim_out_all #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #> m ~ x #>  y ~ m + x #> == Model on Variables/Indicators == #> m ~ x #>  y ~ m + x #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.300   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.910   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.090 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> ==== Descriptive Statistics ==== #>  #>   vars   n  mean   sd  skew kurtosis   se #> m    1 500 -0.03 1.00 -0.09    -0.03 0.04 #> y    2 500 -0.01 0.98  0.03     0.41 0.04 #> x    3 500  0.01 0.94 -0.21     0.17 0.04 #>  #> ===== Parameter Estimates Based on All 5 Samples Combined ===== #>  #> Total Sample Size: 500  #>  #> ==== Standardized Estimates ==== #>  #> Variances and error variances omitted. #>  #> Regressions: #>                     est.std #>   m ~                       #>     x                 0.323 #>   y ~                       #>     m                 0.277 #>     x                -0.098 #>   # Verify that the elements of fits are set to extra$fit  library(lavaan) #> This is lavaan 0.6-19 #> lavaan is FREE software! Please report any bugs. parameterEstimates(fits[[1]]) #>   lhs op rhs   est    se     z pvalue ci.lower ci.upper #> 1   m  ~   x 0.382 0.099 3.837  0.000    0.187    0.577 #> 2   y  ~   m 0.266 0.103 2.591  0.010    0.065    0.467 #> 3   y  ~   x 0.108 0.109 0.990  0.322   -0.106    0.322 #> 4   m ~~   m 0.903 0.128 7.071  0.000    0.653    1.153 #> 5   y ~~   y 0.951 0.134 7.071  0.000    0.687    1.214 #> 6   x ~~   x 0.913 0.000    NA     NA    0.913    0.913 parameterEstimates(sim_out_all[[1]]$extra$fit) #>   lhs op rhs   est    se     z pvalue ci.lower ci.upper #> 1   m  ~   x 0.382 0.099 3.837  0.000    0.187    0.577 #> 2   y  ~   m 0.266 0.103 2.591  0.010    0.065    0.467 #> 3   y  ~   x 0.108 0.109 0.990  0.322   -0.106    0.322 #> 4   m ~~   m 0.903 0.128 7.071  0.000    0.653    1.153 #> 5   y ~~   y 0.951 0.134 7.071  0.000    0.687    1.214 #> 6   x ~~   x 0.913 0.000    NA     NA    0.913    0.913 parameterEstimates(fits[[2]]) #>   lhs op rhs    est    se      z pvalue ci.lower ci.upper #> 1   m  ~   x  0.383 0.108  3.559  0.000    0.172    0.594 #> 2   y  ~   m  0.208 0.104  1.995  0.046    0.004    0.413 #> 3   y  ~   x -0.172 0.119 -1.442  0.149   -0.406    0.062 #> 4   m ~~   m  0.988 0.140  7.071  0.000    0.714    1.262 #> 5   y ~~   y  1.078 0.153  7.071  0.000    0.780    1.377 #> 6   x ~~   x  0.854 0.000     NA     NA    0.854    0.854 parameterEstimates(sim_out_all[[2]]$extra$fit) #>   lhs op rhs    est    se      z pvalue ci.lower ci.upper #> 1   m  ~   x  0.383 0.108  3.559  0.000    0.172    0.594 #> 2   y  ~   m  0.208 0.104  1.995  0.046    0.004    0.413 #> 3   y  ~   x -0.172 0.119 -1.442  0.149   -0.406    0.062 #> 4   m ~~   m  0.988 0.140  7.071  0.000    0.714    1.262 #> 5   y ~~   y  1.078 0.153  7.071  0.000    0.780    1.377 #> 6   x ~~   x  0.854 0.000     NA     NA    0.854    0.854"},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Test Results — summarize_tests","title":"Summarize Test Results — summarize_tests","text":"Extract summarize test results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Test Results — summarize_tests","text":"","code":"summarize_tests(object)  # S3 method for class 'test_summary_list' print(x, digits = 3, ...)  # S3 method for class 'test_summary' print(x, digits = 2, ...)  # S3 method for class 'test_out_list' print(x, digits = 3, test_long = FALSE, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Test Results — summarize_tests","text":"object power4test object element test_all power4test object. x object printed. digits numbers digits decimal printing numeric results. ... Optional arguments. used. test_long TRUE, detailed report printed.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() returns list class test_summary_list. element contains summary test stored. elements class test_summary, elements: test_attributes: stored information test, printing. nrep: number datasets (replications). mean: means numeric information. significance tests, rejection rates. nvalid: number non-NA replications used compute mean. print methods returns x invisibly. called side effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() used extract information test stored power4test object. method print.test_out_list() used print content list test stored power4test object, option print just names tests.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"the-role-of-summarize-tests-and-related-functions","dir":"Reference","previous_headings":"","what":"The role of summarize_tests() and related functions","title":"Summarize Test Results — summarize_tests","text":"function summarize_tests() related print methods used --one function power4test() summary method. Users usually call directly, though developers can use function develop functions power analysis, build workflows power analysis.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/summarize_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Test Results — summarize_tests","text":"","code":"# Specify the model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulated datasets  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Test the parameters in each dataset  test_out <- power4test(object = sim_only,                        test_fun = test_parameters) #> Do the test: test_parameters: CIs    # Print the summary  summarize_tests(test_out) #>  #> =============== <test_parameters: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #> 4       m~~m   m ~~   m  0.945 0.134  7.071  0.000  0.683 1.207 1.000 #> 5       y~~y   y ~~   y  0.836 0.118  7.071  0.000  0.604 1.068 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize 'x_from_power' Results — summary.x_from_power","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"summary method output x_from_power().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"","code":"# S3 method for class 'x_from_power' summary(object, ...)  # S3 method for class 'n_region_from_power' summary(object, ...)  # S3 method for class 'summary.x_from_power' print(x, digits = 3, ...)  # S3 method for class 'summary.n_region_from_power' print(x, digits = 3, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"object x_from_power-class object, output x_from_power(), object class n_region_from_power, output n_region_from_power(). ... Additional arguments. used now. x output summary.x_from_power(), summary method x_from_power object, output x_from_power(), output summary.n_region_from_power(), summary method n_region_from_power object (output n_region_from_power()). digits number digits decimal printing results.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"summary method x_from_power objects returns object class summary.x_from_power, simply output x_from_power(), print method dedicated detailed summary. Please refer x_from_power() contents. print-method summary.x_from_power objects returns object x invisibly. called side effect. print-method summary.n_region_from_power objects returns object x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"simply prepares results x_from_power() printed details.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/summary.x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize 'x_from_power' Results — summary.x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 5,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 2345) #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 5,                            max_trials = 1,                            seed = 1234) #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  ci_hit  #> What:  point   (Estimated Power)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [100, 125]  #>  #>  #> Do the simulation for the upper bound: #>  #> Try x = 125  #>  #> Updating the simulation for sample size: 125  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 1.000, 95.0% confidence interval: [1.000,1.000] #>  #> Initial interval: [100, 125]  #>  #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.298 1.000  0.800  0.449  1.151 #> 2 125 0.310 1.000  1.000  1.000  1.000 #>  #> One of the bounds in the interval is already a solution. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2025-07-16 13:32:01  #> - Rejection Rates: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.298 1.000  0.800  0.449  1.151 #> 2 125 0.310 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -75.3328       0.7672   #>  #> Degrees of Freedom: 9 Total (i.e. Null);  8 Residual #> Null Deviance:\t    6.502  #> Residual Deviance: 5.004 \tAIC: 9.004 #>  #>  #> - Final Value: 100  #>  #> - Final Estimated Power: 0.8000  #> - Confidence Interval: [0.4494; 1.1506] #> - CI Level: 95.00% summary(power_vs_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = test_out, x = \"n\", target_power = 0.8,  #>     progress = TRUE, max_trials = 1, final_nrep = 5, seed = 1234) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 100 #>  #> - Final Estimated Power: 0.800  #> - Confidence Interval: [0.449; 1.151] #> - Level of confidence: 95.0% #> - Based on 5 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 125  #> - Time spent in the search: 0.4181 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -75.3328       0.7672   #>  #> Degrees of Freedom: 9 Total (i.e. Null);  8 Residual #> Null Deviance:\t    6.502  #> Residual Deviance: 5.004 \tAIC: 9.004 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.298 1.000  0.800  0.449  1.151 #> 2 125 0.310 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a Conditional Indirect Effect — test_cond_indirect","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"Test conditional indirect effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"","code":"test_cond_indirect(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   wvalues = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"fit fit object, passed manymome::cond_indirect(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. wvalues numeric vector named elements. names variable names moderators, values values moderators set . Default NULL. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed manymome::cond_indirect(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"function used power4test() testing conditional indirect effect, setting test_fun argument. uses manymome::cond_indirect() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm(). can also used test conditional effect direct path mediator. Just omit m calling function.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a Conditional Indirect Effect — test_cond_indirect","text":"","code":"# Specify the model  model_simple_mod <- \" m ~ x + w + x:w y ~ m + x \"  # Specify the population values  model_simple_mod_es <- \" y ~ m: l y ~ x: n m ~ x: m m ~ w: n m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_mod,                        pop_es = model_simple_mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_cond_indirect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         wvalues = c(w = 1),                                         mc_ci = TRUE)) #> Do the test: test_cond_indirect: x->m->y (w = 1)  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.000   #>     x:w               0.150   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.887   #>    .y                 0.751   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #> w -> m -> y 0.000 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.530 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.104 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ======== <test_cond_indirect: x->m->y (w = 1)> ======== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.206 0.061 0.377 0.800 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 5  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"Test several conditional indirect effects power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"","code":"test_cond_indirect_effects(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   wlevels = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"fit fit object, passed manymome::cond_indirect_effects(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. wlevels output manymome::merge_mod_levels(), moderator(s) passed manymome::mod_levels_list(). moderators can represented one variable, , moderator () numeric variable, (b) dichotomous categorical variable, (c) factor string variable used stats::lm() fit, vector names moderators appeared data frame. least one moderators categorical variable represented one variable, user-created dummy variables used lavaan::sem(), must list names moderators, moderators represented vector names. example: list(\"w1\", c(\"gpgp2\", \"gpgp3\"), first moderator w1 second moderator three-category variable represented gpgp2 gpgp3. See help page manymome::cond_indirect_effects() details. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed manymome::cond_indirect_effects(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"normal usage, returns output returned manymome::cond_indirect_effects(), following modifications: est: estimated conditional indirect effects. cilo cihi: lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated label conditional effects.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"function used power4test() testing several conditional indirect effects, setting test_fun argument. uses manymome::cond_indirect_effects() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm(). can also used test conditional effects direct path mediator. Just omit m calling function.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_cond_indirect_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test Several Conditional Indirect Effects — test_cond_indirect_effects","text":"","code":"# Specify the model  model_simple_mod <- \" m ~ x + w + x:w y ~ m + x \"  # Specify the population values  model_simple_mod_es <- \" y ~ m: l y ~ x: n m ~ x: m m ~ w: n m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_mod,                        pop_es = model_simple_mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the tests in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_cond_indirect_effects,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         wlevels = c(\"w\"),                                         mc_ci = TRUE)) #> Do the test: test_cond_indirect_effects: x->m->y  print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>     w                 0.000   #>     x:w               0.150   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.886   #>    .y                 0.750   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #> w -> m -> y 0.000 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.530 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.104 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ======== <test_cond_indirect_effects: x->m->y> ======== #>  #> Mean(s) across replication: #>             test_label     [w]    (w)   est   cilo  cihi   sig   m~x   y~m #> 1 x->m->y | w: M+1.0SD M+1.0SD  1.060 0.212  0.075 0.365 0.800 0.438 0.474 #> 2    x->m->y | w: Mean    Mean  0.061 0.132  0.027 0.256 0.800 0.275 0.474 #> 3 x->m->y | w: M-1.0SD M-1.0SD -0.939 0.053 -0.086 0.202 0.000 0.112 0.474 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 5  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a Moderated Mediation Effect — test_index_of_mome","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"Test moderated mediation effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"","code":"test_index_of_mome(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   w = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"fit fit object, passed manymome::index_of_mome(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. w name moderator. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed manymome::index_of_mome(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"function used power4test() testing moderated mediation effect, setting test_fun argument. uses manymome::index_of_mome() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_index_of_mome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a Moderated Mediation Effect — test_index_of_mome","text":"","code":"# Specify the model  mod <- \" m ~ x + w + x:w y ~ m \"  # Specify the population values  mod_es <- \" m ~ x: n y ~ x: m m ~ w: l m ~ x:w: l \"  # Simulate the data  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = mod_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_index_of_mome,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         w = \"w\",                                         mc_ci = TRUE)) #> Do the test: test_index_of_mome: x->m->y, moderated by w   print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w + x:w #> y ~ m #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w + x:w #> y ~ m #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.000   #>     w                 0.500   #>     x:w               0.150   #>   y ~                         #>     m                 0.000   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w                 0.000   #>     x:w               0.000   #>   w ~~                        #>     x:w               0.000   #>  #> Variances: #>                    Population #>    .m                 0.726   #>    .y                 1.000   #>     x                 1.000   #>     w                 1.000   #>     x:w               1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>             ind #> x -> m -> y   0 #> w -> m -> y   0 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         6 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 5.501 #>   Degrees of freedom                                 3 #>   P-value (Chi-square)                           0.139 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ==== <test_index_of_mome: x->m->y, moderated by w> ==== #>  #> Mean(s) across replication: #>     est   cilo  cihi   sig #>  -0.006 -0.053 0.024 0.000 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 2  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Test an Indirect Effect — test_indirect_effect","title":"Test an Indirect Effect — test_indirect_effect","text":"Test indirect effect power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test an Indirect Effect — test_indirect_effect","text":"","code":"test_indirect_effect(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test an Indirect Effect — test_indirect_effect","text":"fit fit object, passed manymome::indirect_effect(). x name x-variable, predictor. m character vector name(s) mediator(s). path moves first mediator vector last mediator vector. Can NULL path direct path without mediator. y name y-variable, outcome variable. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed manymome::indirect_effect(). fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test an Indirect Effect — test_indirect_effect","text":"normal usage, returns named numeric vector following elements: est: mean estimated indirect effect across datasets. cilo cihi: means lower upper limits confidence interval (95% default), respectively. sig: Whether test confidence interval significant (1) significant (0).","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test an Indirect Effect — test_indirect_effect","text":"function used power4test() testing indirect effect, setting test_fun argument. uses manymome::indirect_effect() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test an Indirect Effect — test_indirect_effect","text":"","code":"# Specify the model  model_simple_med <- \" m ~ x y ~ m + x \"  # Specify the population values  model_simple_med_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_indirect_effect,                        test_args = list(x = \"x\",                                         m = \"m\",                                         y = \"y\",                                         mc_ci = TRUE)) #> Do the test: test_indirect: x->m->y  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> =============== <test_indirect: x->m->y> =============== #>  #> Mean(s) across replication: #>    est  cilo  cihi   sig #>  0.163 0.051 0.296 1.000 #>  #> - The value 'sig' is the rejection rate. #> - If the null hypothesis is false, this is the power. #> - Number of valid replications for rejection rate: 5  #> - Proportion of valid replications for rejection rate: 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Several Indirect Effects — test_indirect_effects","title":"Test Several Indirect Effects — test_indirect_effects","text":"Test several indirect effects power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Several Indirect Effects — test_indirect_effects","text":"","code":"test_indirect_effects(   fit = fit,   x = NULL,   m = NULL,   y = NULL,   mc_ci = TRUE,   mc_out = NULL,   boot_ci = FALSE,   boot_out = NULL,   check_post_check = TRUE,   ...,   omnibus = c(\"no\", \"all_sig\", \"at_least_one_sig\"),   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Several Indirect Effects — test_indirect_effects","text":"fit fit object, passed manymome::indirect_effect(). x name x-variable, predictor. m Must list character vectors. character vector stores name(s) mediator(s) along path. path moves first mediator vector last mediator vector. NULL, stored paths used, indirect paths model x y, default. y name y-variable, outcome variable. mc_ci Logical. TRUE, default, Monte Carlo confidence intervals formed. argument boot_ci TRUE. mc_out pre-generated Monte Carlo estimates generated manymome::do_mc, stored power4test object. Users set argument let power4test() set automatically. boot_ci Logical. TRUE, default, nonparametric bootstrap confidence intervals formed. argument mc_ci TRUE. boot_out pre-generated bootstrap estimates generated manymome::do_boot, stored power4test object. Users set argument let power4test() set automatically. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed manymome::many_indirect_effects(). omnibus \"\", default, test results paths stored. \"all_sig\", one row test stored, test declared significant paths significant. \"at_least_one_sig\", one row test stored, test declared significant least one paths significant. fit_name name model fit object extracted. Default \"fit\". Used one model fitted replication. name model test conducted. get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Several Indirect Effects — test_indirect_effects","text":"normal usage, returns data frame following columns: est: estimated indirect effect path. cilo cihi: lower upper limits confidence interval (95% default), respectively, indirect effect sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated label indirect effects. omnibus \"all_sig\" \"at_least_one\"sig\", data frame one row, columns \"est\", \"cilo\", \"cihi\" NA. column sig determined whether paths significant (\"all_sig\") whether least one path significant (\"at_least_one_sig\").","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test Several Indirect Effects — test_indirect_effects","text":"function used power4test() testing indirect effect, setting test_fun argument. uses manymome::many_indirect_effects() test. can used models fitted lavaan::sem() fitted sequence calls stats::lm(), although nonparametric bootstrap confidence interval supported models fitted regression using stats::lm().","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_indirect_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test Several Indirect Effects — test_indirect_effects","text":"","code":"# Specify the model  model_simple_med <- \" m1 ~ x m2 ~ x y ~ m1 + m2 + x \"  # Specify the population values  model_simple_med_es <- \" y ~ m1: s m1 ~ x: m y ~ m2: s m2 ~ x: l y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 5,                        model = model_simple_med,                        pop_es = model_simple_med_es,                        n = 100,                        R = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s): #> Generate Monte Carlo estimates:  # Do the test in each replication  test_ind <- power4test(object = sim_only,                        test_fun = test_indirect_effects,                        test_args = list(x = \"x\",                                         y = \"y\",                                         mc_ci = TRUE)) #> Do the test: test_indirects: x-...->y  print(test_ind,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.500   #>   y ~                         #>     m1                0.100   #>     m2                0.100   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.750   #>    .y                 0.977   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>                ind #> x -> m1 -> y 0.030 #> x -> m2 -> y 0.050 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         8 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.219 #>   Degrees of freedom                                 1 #>   P-value (Chi-square)                           0.640 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ============== <test_indirects: x-...->y> ============== #>  #> Mean(s) across replication: #>     test_label   est   cilo  cihi   sig #> 1 x -> m1 -> y 0.026 -0.042 0.103 0.000 #> 2 x -> m2 -> y 0.034 -0.081 0.155 0.200 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 5  #> - Proportion of valid replications for rejection rate(s): 1.000   # Set omnibus = \"all_sig\" to declare # significant only if all paths are # significant  test_ind_all_sig <- power4test(                        object = sim_only,                        test_fun = test_indirect_effects,                        test_args = list(x = \"x\",                                         y = \"y\",                                         mc_ci = TRUE,                                         omnibus = \"all_sig\")) #> Do the test: test_indirects: x-...->y  print(test_ind_all_sig,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> == Model on Variables/Indicators == #>  #> m1 ~ x #> m2 ~ x #> y ~ m1 + m2 + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m1 ~                        #>     x                 0.300   #>   m2 ~                        #>     x                 0.500   #>   y ~                         #>     m1                0.100   #>     m2                0.100   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m1                0.910   #>    .m2                0.750   #>    .y                 0.977   #>     x                 1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>                ind #> x -> m1 -> y 0.030 #> x -> m2 -> y 0.050 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  5  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #> - mc_out #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         8 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.219 #>   Degrees of freedom                                 1 #>   P-value (Chi-square)                           0.640 #>  #> =========== <mc_out> =========== #>  #>  #> == A 'mc_out' class object == #>  #> Number of Monte Carlo replications: 100  #>  #>  #> ============== <test_indirects: x-...->y> ============== #>  #> Mean(s) across replication: #>           test_label  est cilo cihi   sig #> 1 x-...->y (All sig)  NaN  NaN  NaN 0.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 5  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test All Moderation Effects — test_moderation","title":"Test All Moderation Effects — test_moderation","text":"Test moderation effects testing product terms power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test All Moderation Effects — test_moderation","text":"","code":"test_moderation(   fit = fit,   standardized = FALSE,   check_post_check = TRUE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )"},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test All Moderation Effects — test_moderation","text":"fit fit object, passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). standardized Logical. TRUE, lavaan::standardizedSolution() used. Can used models fitted lavaan. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). fit_name name fit results parameter names displayed. Default \"fit\". get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test All Moderation Effects — test_moderation","text":"normal usage, returns output returned lavaan::parameterEstimates() lmhelprs::lm_list_to_partable(), following modifications: est: parameter estimates, even standardized estimates requested (est.std). cilo cihi: lower upper limits confidence interval (95% default), respectively (ci.lower ci.upper). sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated lavaan::lav_partable_labels(), usually labels used coef() label parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test All Moderation Effects — test_moderation","text":"function used power4test() testing product terms, setting test_fun argument. just wrapper test_parameters(). first identifies product terms (terms : names), call test_parameters(), pars set select regression coefficients terms.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_moderation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test All Moderation Effects — test_moderation","text":"","code":"# Specify the model  mod <- \" m ~ x + w1 + x:w1 y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: n y ~ x: m m ~ w1: n m ~ x:w1: l \"  # Simulate the data  sim_only <- power4test(nrep = 4,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Do the test in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_moderation) #> Do the test: test_moderation: CIs    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x + w1 + x:w1 #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x + w1 + x:w1 #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.000   #>     w1                0.000   #>     x:w1              0.150   #>   y ~                         #>     m                 0.000   #>     x                 0.300   #>  #> Covariances: #>                    Population #>   x ~~                        #>     w1                0.000   #>     x:w1              0.000   #>   w1 ~~                       #>     x:w1              0.000   #>  #> Variances: #>                    Population #>    .m                 0.977   #>    .y                 0.909   #>     x                 1.000   #>     w1                1.000   #>     x:w1              1.000   #>  #> (Computing indirect effects for 2 paths ...) #>  #> (Computing indirect effects for 2 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>              ind #> x -> m -> y    0 #> w1 -> m -> y   0 #>  #>  - The 'ind' column shows the indirect effects. #>   #> NOTE: One or more path(s) is/are moderated. #>  #> ======================= Data Information ======================= #>  #> Number of Replications:  4  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         7 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 4.537 #>   Degrees of freedom                                 2 #>   P-value (Chi-square)                           0.103 #>  #> =============== <test_moderation: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op  rhs   est    se     z pvalue   cilo  cihi   sig #> 1     m~x:w1   m  ~ x:w1 0.150 0.101 1.557  0.160 -0.047 0.348 0.250 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 4  #> - Proportion of valid replications for rejection rate(s): 1.000"},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Test All Free Parameters — test_parameters","title":"Test All Free Parameters — test_parameters","text":"Test free parameters, including user-defined parameters, power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test All Free Parameters — test_parameters","text":"","code":"test_parameters(   fit = fit,   standardized = FALSE,   pars = NULL,   op = NULL,   remove.nonfree = TRUE,   check_post_check = TRUE,   ...,   fit_name = \"fit\",   get_map_names = FALSE,   get_test_name = FALSE )  find_par_names(object, fit_name = \"fit\")"},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test All Free Parameters — test_parameters","text":"fit fit object, passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). standardized Logical. TRUE, lavaan::standardizedSolution() used. Can used models fitted lavaan. pars Optional. set character vector, parameters test_label equal values pars returned. See help page valid names. op Optional. set character vector, parameters operators (e.g., \"~\", \"=~\") returned. pars op specified, parameters meeting requirements returned. remove.nonfree Logical. TRUE, default, free parameters returned. Ignored standardized TRUE model fitted lavaan. check_post_check Logical. TRUE, default, model fitted lavaan, test conducted model passes post.check conducted lavaan::lavInspect() (= \"post.check\"). ... Additional arguments passed lavaan::parameterEstimates(), lavaan::standardizedSolution(), lmhelprs::lm_list_to_partable(). fit_name name fit results parameter names displayed. Default \"fit\". get_map_names Logical. Used power4test() determine extract stored information assign function. Users use argument. get_test_name Logical. Used power4test() get default name test. Users use argument. object power4test object.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test All Free Parameters — test_parameters","text":"normal usage, returns output returned lavaan::parameterEstimates() lmhelprs::lm_list_to_partable(), following modifications: est: parameter estimates, even standardized estimates requested (est.std). cilo cihi: lower upper limits confidence interval (95% default), respectively (ci.lower ci.upper). sig: Whether test confidence interval significant (1) significant (0). test_label: column labels generated lavaan::lav_partable_labels(), usually labels used coef() label parameters.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test All Free Parameters — test_parameters","text":"function used power4test() testing free user-defined model parameters, setting test_fun argument. models fitted lavaan, uses lavaan::parameterEstimates() test. bootstrapping requested (setting se = \"boot\"), supports bootstrap confidence intervals returned lavaan::parameterEstimates(). preliminary, though limited, supported models fitted stats::lm() (lmhelprs::many_lm()). Tests conducted ordinary least squares confidence intervals based t statistic, reported stats::confint() applied output stats::lm().","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"find-the-names-of-parameters","dir":"Reference","previous_headings":"","what":"Find the names of parameters","title":"Test All Free Parameters — test_parameters","text":"use argument pars, names appeared function coef() must used. output lavaan, can usually inferred parameter syntax (e.g., y~x, space). sure, call coef() output lavaan. parameter labelled, label used par. sure, function find_par_names() can used find valid names.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/test_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test All Free Parameters — test_parameters","text":"","code":"# Specify the model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" y ~ m: l m ~ x: m y ~ x: n \"  # Simulate the data  sim_only <- power4test(nrep = 2,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 1234) #> Simulate the data: #> Fit the model(s):  # Do the tests in each replication  test_out <- power4test(object = sim_only,                        test_fun = test_parameters) #> Do the test: test_parameters: CIs    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> =============== <test_parameters: CIs > =============== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #> 4       m~~m   m ~~   m  0.945 0.134  7.071  0.000  0.683 1.207 1.000 #> 5       y~~y   y ~~   y  0.836 0.118  7.071  0.000  0.604 1.068 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000   # Do the tests in each replication: Standardized solution # Delta method SEs will be used to do the tests  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(standardized = TRUE)) #> Do the test: test_parameters: CIs (standardized)    print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ======== <test_parameters: CIs (standardized) > ======== #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.347 0.085  4.069  0.000  0.180 0.514 1.000 #> 2        y~m   y  ~   m  0.446 0.086  5.190  0.000  0.277 0.615 1.000 #> 3        y~x   y  ~   x -0.024 0.094 -0.233  0.232 -0.209 0.160 0.000 #> 4       m~~m   m ~~   m  0.880 0.059 14.888  0.000  0.764 0.995 1.000 #> 5       y~~y   y ~~   y  0.791 0.071 11.181  0.000  0.652 0.931 1.000 #> 6       x~~x   x ~~   x  1.000 0.000    NaN    NaN  1.000 1.000 1.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000   # Do the tests in each replication: Parameters with the selected operator  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(op = \"~\")) #> Do the test: test_parameters: CIs (op: ~)   print(test_out,       test_long = TRUE) #>  #> ====================== Model Information ====================== #>  #> == Model on Factors/Variables == #>  #> m ~ x #> y ~ m + x #>  #> == Model on Variables/Indicators == #>  #> m ~ x #> y ~ m + x #>  #> ====== Population Values ====== #>  #> Regressions: #>                    Population #>   m ~                         #>     x                 0.300   #>   y ~                         #>     m                 0.500   #>     x                 0.000   #>  #> Variances: #>                    Population #>    .m                 0.910   #>    .y                 0.750   #>     x                 1.000   #>  #> (Computing indirect effects for 1 paths ...) #>  #> == Population Indirect Effect(s) == #>  #> ==  Indirect Effect(s)   == #>               ind #> x -> m -> y 0.150 #>  #>  - The 'ind' column shows the indirect effects. #>   #> ======================= Data Information ======================= #>  #> Number of Replications:  2  #> Sample Sizes:  100  #>  #> Call print with 'data_long = TRUE' for further information. #>  #> ==================== Extra Element(s) Found ==================== #>  #> - fit #>  #> === Element(s) of the First Dataset === #>  #> ============ <fit> ============ #>  #> lavaan 0.6-19 ended normally after 1 iteration #>  #>   Estimator                                         ML #>   Optimization method                           NLMINB #>   Number of model parameters                         5 #>  #>   Number of observations                           100 #>  #> Model Test User Model: #>                                                        #>   Test statistic                                 0.000 #>   Degrees of freedom                                 0 #>  #> ============ <test_parameters: CIs (op: ~)> ============ #>  #> Mean(s) across replication: #>   test_label lhs op rhs    est    se      z pvalue   cilo  cihi   sig #> 1        m~x   m  ~   x  0.382 0.103  3.698  0.000  0.179 0.585 1.000 #> 2        y~m   y  ~   m  0.443 0.094  4.715  0.000  0.259 0.627 1.000 #> 3        y~x   y  ~   x -0.029 0.104 -0.226  0.236 -0.232 0.174 0.000 #>  #> - The column 'sig' shows the rejection rates. #> - If the null hypothesis is false, the rate is the power. #> - Number of valid replications for rejection rate(s): 2  #> - Proportion of valid replications for rejection rate(s): 1.000    # Finding valid parameter names  find_par_names(sim_only) #> [1] \"m~x\"  \"y~m\"  \"y~x\"  \"m~~m\" \"y~~y\""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Size and Effect Size Determination — x_from_power","title":"Sample Size and Effect Size Determination — x_from_power","text":"searches simulation sample size (given factors, effect sizes) effect size (given factors, sample size) power detect effect close target value.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Size and Effect Size Determination — x_from_power","text":"","code":"x_from_power(   object,   x,   pop_es_name = NULL,   target_power = 0.8,   what = c(\"point\", \"ub\", \"lb\"),   goal = switch(what, point = \"ci_hit\", ub = \"close_enough\", lb = \"close_enough\"),   ci_level = 0.95,   tolerance = 0.02,   x_interval = switch(x, n = c(50, 2000), es = NULL),   extendInt = NULL,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   final_nrep = 400,   final_R = 1000,   seed = NULL,   x_include_interval = FALSE,   check_es_interval = TRUE,   power_curve_args = list(power_model = NULL, start = NULL, lower_bound = NULL,     upper_bound = NULL, nls_control = list(), nls_args = list()),   save_sim_all = FALSE,   algorithm = NULL,   control = list() )  n_from_power(   object,   pop_es_name = NULL,   target_power = 0.8,   what = c(\"point\", \"ub\", \"lb\"),   goal = switch(what, point = \"ci_hit\", ub = \"close_enough\", lb = \"close_enough\"),   ci_level = 0.95,   tolerance = 0.02,   x_interval = c(50, 2000),   extendInt = NULL,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   final_nrep = 400,   final_R = 1000,   seed = NULL,   x_include_interval = FALSE,   check_es_interval = TRUE,   power_curve_args = list(power_model = NULL, start = NULL, lower_bound = NULL,     upper_bound = NULL, nls_control = list(), nls_args = list()),   save_sim_all = FALSE,   algorithm = NULL,   control = list() )  n_region_from_power(   object,   pop_es_name = NULL,   target_power = 0.8,   ci_level = 0.95,   tolerance = 0.02,   x_interval = c(50, 2000),   extendInt = NULL,   progress = TRUE,   simulation_progress = TRUE,   max_trials = 10,   final_nrep = 400,   final_R = 1000,   seed = NULL,   x_include_interval = FALSE,   check_es_interval = TRUE,   power_curve_args = list(power_model = NULL, start = NULL, lower_bound = NULL,     upper_bound = NULL, nls_control = list(), nls_args = list()),   save_sim_all = FALSE,   algorithm = NULL,   control = list() )  # S3 method for class 'x_from_power' print(x, digits = 3, ...)  # S3 method for class 'n_region_from_power' print(x, digits = 3, ...)"},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Size and Effect Size Determination — x_from_power","text":"object power4test object, output power4test(). Can also power4test_by_n object, output power4test_by_n(), power4test_by_es object, output power4test_by_es(). two types objects, attempt power closest target_power used object, attempts included estimation subsequent attempts final output. Last, can also output previous call x_from_power(), stored trials retrieved. x x_from_power(), x set value searched. Can \"n\", sample size, \"es\", population value parameter (set pop_es_name). print method x_from_power objects, output x_from_power(). pop_es_name name parameter. Required x \"es\". See help page ptable_pop() names argument pop_es. target_power target power, value greater 0 less one. value searched: estimate power (\"point\"), upper bound confidence interval (\"ub\"), lower bound confidence interval (\"lb\"). goal goal search. \"ci_hit\", goal find value x confidence interval estimated power including target power. \"close_enough\", goal find value x value \"close enough\" target power, defined absolute difference target power less tolerance. ci_level level confidence confidence intervals computed estimated power. Default .95, denoting 95%. tolerance Used goal \"close_enough\". x_interval vector two values, minimum value maximum values x, search values (sample sizes population values). NULL, default x = \"es\", determined internally. extendInt Whether x_interval can expanded estimating values try. value passed argument name stats::uniroot(). x \"n\", default value \"upX\". , value higher maximum x_interval allowed, predicted tentative model. Otherwise, default value \"\". See help page stats::uniroot() information. progress Logical. Whether searching progress reported. simulation_progress Logical. Whether progress call power4test(), power4test_by_n(), power4test_by_es() shown. passed progress argument functions. max_trials maximum number trials searching value target power. Rounded integer. final_nrep number replications final stage, also maximum number replications call power4test(), power4test_by_n(), power4test_by_es(). final_R number Monte Carlo simulation bootstrapping samples final stage. R calling power4test(), power4test_by_n(), power4test_by_es() stepped value approaching target power. need large goal estimate power replications, high precision one single replication. seed NULL, set.seed() used make process reproducible. always possible many stages parallel processing involved. x_include_interval Logical. Whether minimum maximum values x_interval mandatory included values searched. check_es_interval TRUE, default, x \"es\", conservative probable range valid values selected parameter determined, used instead x_interval. range spans positive negative values, interval sign population value object used. power_curve_args named list arguments passed power_curve() estimating relation power x (sample size effect size). Please refer power_curve() available arguments. one except: power_model mapped formula argument power_curve(). save_sim_all FALSE, default, data power4test object value x saved, reduce size output. set TRUE, size output can large size. algorithm algorithm finding x. Can \"power_curve\" \"bisection\". default algorithm depends x. control named list additional arguments passed algorithm used. advanced users. digits number digits decimal printing results. ... Optional arguments. used now.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Size and Effect Size Determination — x_from_power","text":"function x_from_power() returns x_from_power object, list following elements: power4test_trials: output power4test_by_n() sample sizes examined, power4test_by_es() population values selected parameter examined. rejection_rates: output rejection_rates(). x_tried: sample sizes population values examined. power_tried: estimated rejection rates values examined. x_final: sample size population value solution. NA solution found. power_final: estimated power value solution. NA solution found. i_final: position solution power4test_trials. NA solution found. ci_final: confidence interval estimated power solution, formed normal approximation. NA solution found. ci_level: level confidence ci_final. nrep_final: number replications (nrep) estimating power solution. power_curve: output power_curve() estimating power curve. target_power: requested target power. power_tolerance: allowed difference solution's estimated power target power. Determined number replications level confidence confidence intervals. x_estimated: value (sample size population value) target power, estimated power_curve. used, solution found, determine range values search calling function . start: time date process started. end: time date process ended. time_spent: time spent search. args: named list arguments x_from_power() used search. call: call function called. function n_region_from_power() returns named list two output n_from_power(), class n_region_from_power. output = \"ub\" named \"\", output = \"lb\" namd \"\". print-method x_from_power objects returns object x invisibly. called side effect. print-method x_from_power_region objects returns object x invisibly. called side effect.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Size and Effect Size Determination — x_from_power","text":"use function: Specify model power4test(), do_the_test = FALSE, set magnitude effect sizes minimum levels detect. Add test using power4test() using test_fun test_args (see help page power4test() details). Run starting sample size effect size. Call x_from_power() output power4test() returned previous step. function iteratively repeat analysis either sample sizes, values selected model parameter (effect sizes), trying achieve goal (goal) value interest (). goal \"ci_hit\", search try find value (sample size, population value selected model parameter) power level close enough target power, defined confidence interval power including target power. goal \"close_enough\", search try find value x level power (\"point\"), upper bound confidence interval level power (\"ub\"), lower bound confidence interval fro level power (\"lb\") \"close enough\" target level power, defined absolute difference less tolerance. several values x (sample size population value model parameter) already examined power4test_by_n() power4test_by_es(), output two functions can also used object x_from_power(). Usually, default values arguments sufficient. results can viewed using summary(), output plot method (plot.x_from_power()) plot relation power values (x) examined. detailed illustration use function sample size can found page: https://sfcheung.github.io/power4mome/articles/x_from_power_for_n.html function n_from_power() just wrapper x_from_power(), x set \"n\". function n_region_from_power() just wrapper x_from_power(), x set \"n\", two passes, one = \"ub\" one = \"lb\". print method print basic information. Call summary method x_from_power objects (summary.x_from_power()) print method detailed results","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"algorithms","dir":"Reference","previous_headings":"","what":"Algorithms","title":"Sample Size and Effect Size Determination — x_from_power","text":"Two algorithms currently available, simple (though inefficient) bisection method, method makes use estimated crude power curve. Unlike typical root-finding problems, prediction level power stochastic. Moreover, computational cost high Monte Carlo bootstrap confidence intervals used test estimation power one single value x can sometimes take one minute longer. Therefore, addition simple bisection method, method, named power curve method, also specifically developed scenario.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"bisection-method","dir":"Reference","previous_headings":"","what":"Bisection Method","title":"Sample Size and Effect Size Determination — x_from_power","text":"method, algorithm = \"bisection\", basically starts interval probably encloses value x meets goal, successively narrows interval. mid-point interval used estimate. Though simple, cases can slow. Nevertheless, preliminary examination suggests method good enough common scenarios. Therefore, method default algorithm x n.","code":""},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"power-curve-method","dir":"Reference","previous_headings":"","what":"Power Curve Method","title":"Sample Size and Effect Size Determination — x_from_power","text":"method, algorithm = \"power_curve\", starts crude power curve based points. tentative model used suggest values examine next iteration. form, just parameters, model can change across iterations, data points available. method can used goal \"ci_hit\". method default method x = \"es\" goal = \"ci_hit\" relation power population value parameter varies across parameters, unlike relation power sample size. Therefore, taking account working power curve may help finding desired value x. technical internal workflow method implemented x_from_power() can found page: https://sfcheung.github.io/power4mome/articles/x_from_power_workflow.html.","code":""},{"path":[]},{"path":"https://sfcheung.github.io/power4mome/reference/x_from_power.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Size and Effect Size Determination — x_from_power","text":"","code":"# Specify the population model  mod <- \" m ~ x y ~ m + x \"  # Specify the population values  mod_es <- \" m ~ x: m y ~ m: l y ~ x: n \"  # Generate the datasets  sim_only <- power4test(nrep = 5,                        model = mod,                        pop_es = mod_es,                        n = 100,                        do_the_test = FALSE,                        iseed = 2345) #> Simulate the data: #> Fit the model(s):  # Do a test  test_out <- power4test(object = sim_only,                        test_fun = test_parameters,                        test_args = list(pars = \"m~x\")) #> Do the test: test_parameters: CIs (pars: m~x)   # Determine the sample size with a power of .80 (default)  # In real analysis, to have more stable results: # - Use a larger final_nrep (e.g., 400).  # If the default values are OK, this call is sufficient: # power_vs_n <- x_from_power(test_out, #                            x = \"n\", #                            seed = 4567) power_vs_n <- x_from_power(test_out,                            x = \"n\",                            progress = TRUE,                            target_power = .80,                            final_nrep = 5,                            max_trials = 1,                            seed = 1234) #>  #> --- Setting --- #>  #> Algorithm:  bisection  #> Goal:  ci_hit  #> What:  point   (Estimated Power)  #>  #> --- Progress  --- #>  #> - Set 'progress = FALSE' to suppress displaying the progress. #> - Set 'simulation progress = FALSE' to suppress displaying the progress #>   in the simulation. #>  #> Initial interval: [100, 125]  #>  #>  #> Do the simulation for the upper bound: #>  #> Try x = 125  #>  #> Updating the simulation for sample size: 125  #> Re-simulate the data: #> Fit the model(s): #> Update the test(s): #> Update test_parameters: CIs (pars: m~x) : #>  #> Estimated power at n: 1.000, 95.0% confidence interval: [1.000,1.000] #>  #> Initial interval: [100, 125]  #>  #> - Rejection Rates: #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.298 1.000  0.800  0.449  1.151 #> 2 125 0.310 1.000  1.000  1.000  1.000 #>  #> One of the bounds in the interval is already a solution. #>  #> - 'nls()' estimation skipped when less than 4 values of predictor examined. #> Solution found. #>  #>  #> --- Final Stage --- #>  #> - Start at 2025-07-16 13:32:15  #> - Rejection Rates: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.298 1.000  0.800  0.449  1.151 #> 2 125 0.310 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  #> - Estimated Power Curve: #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -75.3328       0.7672   #>  #> Degrees of Freedom: 9 Total (i.e. Null);  8 Residual #> Null Deviance:\t    6.502  #> Residual Deviance: 5.004 \tAIC: 9.004 #>  #>  #> - Final Value: 100  #>  #> - Final Estimated Power: 0.8000  #> - Confidence Interval: [0.4494; 1.1506] #> - CI Level: 95.00% summary(power_vs_n) #>  #> ====== x_from_power Results ====== #>  #> Call: #> x_from_power(object = test_out, x = \"n\", target_power = 0.8,  #>     progress = TRUE, max_trials = 1, final_nrep = 5, seed = 1234) #>  #> Predictor (x): Sample Size  #>  #> - Target Power: 0.800  #> - Goal: Find 'x' with the confidence interval of the estimated power #>   enclosing the target power. #>  #> === Major Results === #>  #> - Final Value (Sample Size): 100 #>  #> - Final Estimated Power: 0.800  #> - Confidence Interval: [0.449; 1.151] #> - Level of confidence: 95.0% #> - Based on 5 replications. #>  #> === Technical Information === #>  #> - Algorithm: bisection  #> - The range of values explored: 100 to 125  #> - Time spent in the search: 0.4824 secs  #> - The final crude model for the power-predictor relation: #>  #> Model Type: Logistic Regression  #>  #> Call: #> power_curve(object = by_x_1, formula = power_model, start = power_curve_start,  #>     lower_bound = lower_bound, upper_bound = upper_bound, nls_args = nls_args,  #>     nls_control = nls_control, verbose = progress) #>  #> Predictor: n (Sample Size) #>  #> Model: #>  #> Call:  stats::glm(formula = reject ~ x, family = \"binomial\", data = reject1) #>  #> Coefficients: #> (Intercept)            x   #>    -75.3328       0.7672   #>  #> Degrees of Freedom: 9 Total (i.e. Null);  8 Residual #> Null Deviance:\t    6.502  #> Residual Deviance: 5.004 \tAIC: 9.004 #>  #> - Detailed Results: #>  #> [test]: test_parameters: CIs (pars: m~x)  #> [test_label]: m~x  #>     n   est   p.v reject r.cilo r.cihi #> 1 100 0.298 1.000  0.800  0.449  1.151 #> 2 125 0.310 1.000  1.000  1.000  1.000 #> Notes: #> - n: The sample size in a trial. #> - p.v: The proportion of valid replications. #> - est: The mean of the estimates in a test across replications. #> - reject: The proportion of 'significant' replications, that is, the #>   rejection rate. If the null hypothesis is true, this is the Type I #>   error rate. If the null hypothesis is false, this is the power. #> - r.cilo,r.cihi: The confidence interval of the rejection rate, based #>   on normal approximation. #> - Refer to the tests for the meanings of other columns. #>  plot(power_vs_n)"},{"path":"https://sfcheung.github.io/power4mome/news/index.html","id":"power4mome-00185","dir":"Changelog","previous_headings":"","what":"power4mome 0.0.1.85","title":"power4mome 0.0.1.85","text":"Initialized package. (0.0.0.9000) Major functions drafted main workflows finalized. Ready documenting changes. (0.0.0.9001) Documented set pop_es. (0.0.0.9002) Added preliminary support covariance-models (regression path) confirmatory factor analytic models (CFA). (0.0.0.9003) Added support multigroup models. (0.0.0.9004) sim_data(), number_of_indicators reliability can set one single values. (0.0.0.9005) Added check negative variances variances greater one model. (0.0.0.9006) warning raised ptable_pop() pop_es one variables model. (0.0.0.9007) Added error warning checking code fit_model(). (0.0.0.9008) Added error checking code gen_mc(). (0.0.0.9009) Added tests sim_out() do_test(). (0.0.0.9010) Updated help do_test() requirement results test functions. (0.0.0.9011) Updated fit_model() support user-supplied models. (0.0.0.9012) Updated do_test() sim_out() arbitrary number models arbitrary elements used test_fun(). (0.0.0.9013) Updated do_test() sim_out() support tests compare two models. (0.0.0.9014) Added tests power4test(). (0.0.0.9015) Removed redundant arguments tests power4test(). (0.0.0.9016) Updated power4test() store one test. (0.0.0.9017) Updated fit_model() support fitting model another function (0.0.0.9018) Added argument x_fun() sim_data() generating nonnormal exogenous variables. (0.0.0.9019) Updated power4test() related functions support updating power4test object different population effect sizes sample size(s). (0.0.0.9020) Added option generate nonparametric bootstrap estimates. Slow lavaan can used models fitted lm(). (0.0.0.9021) Added test_indirect_effect() testing indirect effect calling power4test(). (0.0.0.9022) Added test_index_mome() testing moderated mediation effect (testing index moderated mediation) calling power4test(). (0.0.0.9023) Added test_parameters() testing free parameters calling power4test(). (0.0.0.9024) Added test_moderation() testing product terms calling power4test(). (0.0.0.9024) test functions can support models fitted lmhelprs::many_lm(). (0.0.0.9024) Simplified argument fit_function fit_model(). can now strings, lavaan lm. (0.0.0.9025) Added summarize_tests(), along print method, summarize te test results power4test object. (0.0.0.9026) Added print method power4test objects. (0.0.0.9027) sim_out can now used update sim_out object adding elements extra. (0.0.0.9028) power4test() can updata power4test object using new nrep. (0.0.0.9029) Added get_rejection_rates() extract rejection rates stored tests. (0.0.0.9030) Added power4test_by_n() power4test_by_pop_es() finding power range sample sizes effect sizes. (0.0.0.9031) Update help pages examples. (0.0.0.9032) Minor fixes boot_ci mc_ci arguments test_indirect_effect() test_index_of_mome(). (0.0.0.9033) Revised fit_model() can used refit model new set data. (0.0.0.9034) Revised power4test() support fitting one model datasets. test_ functions also updated allow users specifying model uesd tests. (0.0.0.9035) Drafted pkgdown site. (0.0.0.9036) Added pop_es_yaml() revised ptable_pop() support method specify population values. (0.0.0.9037) Added option disable computation implied statistics. Default FALSE becasue required testing unstandardized effects. Require manymome 0.2.7.1 . (0.0.0.9038) Finalized internal testing. (0.0.1) Fixed bug using x_fun. (0.0.1.1) Added temporary check package versions. (0.0.1.2) Fixed issue printing boot_out mc_out objects print.sim_data(). (0.0.1.3) Revised get_rejection_rates_* functions add option return columns stored test. (0.0.1.4) Added version requirements lmhelprs manymome. (0.0.1.5) Added test_cond_indirect() test_cond_indirect_effects(). (0.0.1.7) Fixed issues column names. (0.0.1.8) Added es1 es2 power4test(), allow users change effect sizes labels. (0.0.1.9) Added c() method output power4test_by_n(). (0.0.1.10) Added c() method output power4test_by_pop_es(). (0.0.1.11) Added by_seed power4test_by_n() power4test_by_pop_es() reproducible results. (0.0.1.12) Results now reproducible parallel TRUE. (0.0.1.13) Updated power4test_by_pop_es() power4test_by_n() accept output two functions. (0.0.1.14) Added by_nrep power4test_by_n(). (0.0.1.15) Added columns results functions returning rejection rates. (0.0.1.16) Added n_from_power() search sample size target power. (0.0.1.17) Updated psi_std() skip checking variances product terms. (0.0.1.18) Improved rejection_rates_add_ci() usable functions. (0.0.1.19) Updated get_rejection_rates() report confidence intervals standard errors rejection rates. (0.0.1.20) Revised get_rejection_rates() related functions. column rejection rates now always named \"reject\". (0.0.1.21) Added ptable_pop() arguments power4test(). (0.0.1.22) Added power_curve() estimate relation rejection rates predictor. Updated n_from_power() use power_curve() internally. (0.0.1.23) print method sim_out objects can print standardized /unstandardized estimates fitting model merged data. (0.0.1.24) Renamed power4test_by_pop_es() power4test_by_es(), \"n\" \"es\" (\"pop_es\") used functions distinguish predictor used. (0.0.1.25) Renamed get_rejection_rates_by_pop_es() get_rejection_rates_by_es(), consistent name power4test_by_es(). (0.0.1.26) Replaced n_from_power() general version x_from_power(), updated related functions. (0.0.1.27) Updated x_from_power() fully support x = \"es\". (0.0.1.28) Minor changes printout progress power4test_by_n() power4test_by_es(). (0.0.1.29) Fixed minor bug internal function fix_nls_args(). (0.0.1.30) Renamed get_rejection_rates* rejection_rates* looks consistent common naming convention. (0.0.1.31) Convert rejection_rates() S3 generic method. (0.0.1.32) Add rejection_rates methods power4test_by_n power4test_by_es objects. original functions rejection_rates_by_n() rejection_rates_by_es() longer exported. relevant functions revised use rejection_rates method instead two functions. (0.0.1.33) Created class output rejection_rates added print method. (0.0.1.34) Updated arguments print method rejection_rate() output power4test_by_es power4test_by_es objects. (0.0.1.35) Removed power_curve_by_n() power_curve_by_es(). longer needed. (0.0.1.36) Updated power_by_n() power_by_es() option save data model sim_all, updated c() method skip testing model. option used x_from_power(). (0.0.1.37) Updated x_from_power() save data model default. Dramatically reduce size output. (0.0.1.37) Updated doc do_test(). (0.0.1.38) Updated doc test_parameters() valid parameter names. Also added helper find_par_names() finding valid names power4test object. (0.0.1.39) Updated help pages. (0.0.1.40) Added initial_R initial_nrep x_from_power(). (0.0.1.41) Changed default value final_nrep x_from_power() 400. (0.0.1.41) Updated x_from_power() use outputs power4test_by_n() power4test_by_es(). (0.0.1.42) Updated x_from_power() reuse outputs x_from_power(). (0.0.1.43) Fixed issues related R CMD Check. (0.0.1.44) Fixed typo help page power4test(). (0.0.1.45) Fixed bug handling .cov. pop_es. (0.0.1.46) Added tag .ind. setting values component paths along indirect path. tag also supported power4test_by_es() x_from_power(). (0.0.1.47) print method sim_data print population indirect effect(s), . (0.0.1.48) Corrected value mi. (0.0.1.49) Improved search algorithm. (0.0.1.49) Clarified x_fun argument can also specify function generate error terms. (0.0.1.50) Added e_fun generating nonnormal error terms indicators. (0.0.1.51) Added gen_missing generating missing data. (0.0.1.52) Adopted robust way process fit_model_args power4test(). (0.0.1.53) Fixed bug pop_es numeric processed. (0.0.1.54) Cleared obsolete TODOs comments. (0.0.1.55) argument map_names now work properly. (0.0.1.56) Rename gen_missing process_data. (0.0.1.57) Added support printing missing data pattern. (0.0.1.58) Improved search algorithm x_from_power(). (0.0.1.59) Update print.sim_data() compute indirect paths “pure x-variables ”pure y-variables”, default. (0.0.1.60) Added bisection method x_from_power() set default algorithm. (0.0.1.61) Added check_valid_es_values() identify range valid values parameter. (0.0.1.62) default algorithm x_from_power() now depends x. (0.0.1.63) Updated x_from_power() determine interval es automatically. (0.0.1.64) Optimized power curve algorithm. (0.0.1.65) Added .power4test_by_n() .power4test_by_es(). (0.0.1.66) Updated x_from_power() quit early solution already found input. (0.0.1.67) Updated x_from_power() related functions store information. (0.0.1.68) Updated methods x_from_power() goal . (0.0.1.69) Disabled sig_area x = \"es\". (0.0.1.70) Updated power4test_by_n() power4test_by_es() catch error power4test() skip value. (0.0.1.71) Added error catching test functions. (0.0.1.72) test functions now check whether model fit passed post.check test lavaan. (0.0.1.73) Updated allow using expressions (e.g., \"s * 2\", \"sqrt(.30)\") specify population value parameter. (0.0.1.74) print method rejection_rates() output now always print column estimates. (0.0.1.75) Added print method output power4test_by_n(). (0.0.1.76) Added print method output power4test_by_es(). (0.0.1.77) Added plot methods output power4test_by_n() power4test_by_es(). (0.0.1.78) Added (back) n_from_power(), wrapper x_from_power() x set \"n\". (0.0.1.79, 0.0.1.80) Updated sim_data() fit_model() try finding indirect paths store output fit_model_i(). (0.0.1.82) Added test_indirect_effects() test two paths. (0.0.1.83, 0.0.1.84) Added n_region_from_power() methods output. (0.0.1.85)","code":""}]
